--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\GrindrPlus.kt --- 
package com.grindrplus
@SuppressLint("StaticFieldLeak")
object GrindrPlus {
    lateinit var context: Context
        private set
    lateinit var classLoader: ClassLoader
        private set
    lateinit var database: GPDatabase
        private set
    lateinit var bridgeClient: BridgeClient
        internal set
    lateinit var instanceManager: InstanceManager
        private set
    lateinit var httpClient: Client
        private set
    lateinit var packageName: String
        private set
    lateinit var hookManager: HookManager
    var shouldTriggerAntiblock = true
    var blockCaller: String = ""
    var isImportingSomething = false
    var myProfileId: String = ""
    var hasCheckedVersions = false
    var shouldShowVersionMismatchDialog = false
    var shouldShowBridgeConnectionError = false
    private var isInitialized = false
    private var isMainInitialized = false
    private var isInstanceManagerInitialized = false
    var spline = PCHIP(
        listOf(
            1238563200L to 0,          // 2009-04-01
            1285027200L to 1000000,    // 2010-09-21
            1462924800L to 35512000,   // 2016-05-11
            1501804800L to 132076000,  // 2017-08-04
            1546547829L to 201948000,  // 2019-01-03
            1618531200L to 351220000,  // 2021-04-16
            1636150385L to 390338000,  // 2021-11-05
            1637963460L to 394800000,  // 2021-11-26
            1680393600L to 505225000,  // 2023-04-02
            1717200000L to 630495000,  // 2024-06-01
            1717372800L to 634942000,  // 2024-06-03
            1729950240L to 699724000,  // 2024-10-26
            1732986600L to 710609000,  // 2024-11-30
            1733349060L to 711676000,  // 2024-12-04
            1735229820L to 718934000,  // 2024-12-26
            1738065780L to 730248000,  // 2025-01-29
            1739059200L to 733779000,  // 2025-02-09
            1741564800L to 744008000   // 2025-03-10
        )
    )
    val currentActivity: Activity?
        get() = currentActivityRef?.get()
    internal val userAgent = "U7.q" // search for 'grindr3/'
    internal val hardcodedUserAgent = "grindr3/25.16.0.144399;144399;Free;Android 15;SM-A166P;samsung"
    internal val userSession = "com.grindrapp.android.usersession.a" // search for 'com.grindrapp.android.storage.UserSessionImpl$1'
    private val deviceInfo =
        "i5.w" // search for 'AdvertisingIdClient.Info("00000000-0000-0000-0000-000000000000", true)'
    internal val grindrLocationProvider = "Ia.d" // search for 'system settings insufficient for location request, attempting to resolve'
    internal val serverDrivenCascadeRepo = "com.grindrapp.android.persistence.repository.ServerDrivenCascadeRepo"
    internal val ageVerificationActivity = "com.grindrapp.android.ageverification.presentation.ui.AgeVerificationActivity"
    internal val browseExploreActivity = "com.grindrapp.android.ui.browse.BrowseExploreMapActivity"
    internal val serverNotification = "com.grindrapp.android.network.websocket.model.WebSocketNotification\$ServerNotification"
    private val ioScope = CoroutineScope(Dispatchers.IO)
    private val taskScheduer = TaskScheduler(ioScope)
    internal val taskManager = TaskManager(taskScheduer)
    private var currentActivityRef: WeakReference<Activity>? = null
    private val splineDataEndpoint =
        "https://raw.githubusercontent.com/R0rt1z2/GrindrPlus/refs/heads/master/spline.json"
    val serverNotifications = EventManager.serverNotifications
    fun init(modulePath: String, application: Application,
             versionCodes: IntArray, versionNames: Array<String>) {
        if (isInitialized) {
            Logger.d("GrindrPlus already initialized, skipping", LogSource.MODULE)
            return
        }
        setupCrashLogging()
        this.context = application
        this.bridgeClient = BridgeClient(context)
        Logger.initialize(context, bridgeClient, true)
        Logger.i("Initializing GrindrPlus...", LogSource.MODULE)
        try {
        //    HttpBodyLogger.initialize()
            Logger.i("HTTP Body Logger database initialized.", LogSource.MODULE)
        } catch (e: Exception) {
            Logger.e("Failed to initialize HttpBodyLogger database: ${e.message}", LogSource.MODULE)
        }
        checkVersionCodes(versionCodes, versionNames)
        val connected = runBlocking {
            try {
                withTimeout(10000) {
                    bridgeClient.connectWithRetry(5, 1000)
                }
            } catch (e: Exception) {
                Logger.e("Connection timeout: ${e.message}", LogSource.MODULE)
                false
            }
        }
        if (!connected) {
            Logger.e("Failed to connect to the bridge service", LogSource.MODULE)
            shouldShowBridgeConnectionError = true
        }
        Config.initialize(application.packageName)
        val newModule = File(context.filesDir, "grindrplus.dex")
        File(modulePath).copyTo(newModule, true)
        newModule.setReadOnly()
        this.classLoader =
            DexClassLoader(newModule.absolutePath, null, null, context.classLoader)
        this.database = GPDatabase.create(context)
        this.hookManager = HookManager()
        this.instanceManager = InstanceManager(classLoader)
        this.packageName = context.packageName
        if (bridgeClient.shouldRegenAndroidId(packageName)) {
            Logger.i("Generating new Android device ID", LogSource.MODULE)
            val androidId = java.util.UUID.randomUUID()
                .toString().replace("-", "").lowercase().take(16)
            Config.put("android_device_id", androidId)
        }
        val forcedCoordinates = bridgeClient.getForcedLocation(packageName)
        if (forcedCoordinates.isNotEmpty()) {
            val parts = forcedCoordinates.split(",").map { it.trim() }
            if (parts.size != 2 || parts.any { it.toDoubleOrNull() == null }) {
                Logger.w("Invalid forced coordinates format: $forcedCoordinates", LogSource.MODULE)
            } else {
                if (parts[0] == "0.0" && parts[1] == "0.0") {
                    Logger.w("Ignoring forced coordinates: $forcedCoordinates", LogSource.MODULE)
                } else {
                    Logger.i("Using forced coordinates: $forcedCoordinates", LogSource.MODULE)
                    Config.put("forced_coordinates", forcedCoordinates)
                }
            }
        } else if (Config.get("forced_coordinates", "") != "") {
            Logger.i("Clearing previously set forced coordinates", LogSource.MODULE)
            Config.put("forced_coordinates", "")
        }
        registerActivityLifecycleCallbacks(application)
        if (shouldShowVersionMismatchDialog) {
            Logger.i("Version mismatch detected, stopping initialization", LogSource.MODULE)
            return
        }
        try {
            setupInstanceManager()
            setupServerNotificationHook()
        } catch (t: Throwable) {
            Logger.e("Failed to hook critical classes: ${t.message}", LogSource.MODULE)
            Logger.writeRaw(t.stackTraceToString())
            showToast(Toast.LENGTH_LONG, "Failed to hook critical classes: ${t.message}")
            return
        }
        fetchRemoteData(splineDataEndpoint) { points ->
            spline = PCHIP(points)
            Logger.i("Updated spline with remote data", LogSource.MODULE)
        }
        try {
            val initTime = measureTimeMillis { initializeCore() }
            Logger.i("Initialization completed in $initTime ms", LogSource.MODULE)
            isInitialized = true
        } catch (t: Throwable) {
            Logger.e("Failed to initialize: ${t.message}", LogSource.MODULE)
            Logger.writeRaw(t.stackTraceToString())
            showToast(Toast.LENGTH_LONG, "Failed to initialize: ${t.message}")
            return
        }
    }
    private fun setupServerNotificationHook() {
        try {
            classLoader.loadClass(serverNotification).hookConstructor(HookStage.AFTER) { param ->
                try {
                    val serverNotification = param.thisObject()
                    val typeValue = callMethod(serverNotification, "getTypeValue") as String
                    val notificationId = callMethod(serverNotification, "getNotificationId") as String?
                    val payload = callMethod(serverNotification, "getPayload") as JSONObject?
                    val status = callMethod(serverNotification, "getStatus") as Int?
                    val refValue = callMethod(serverNotification, "getRefValue") as String?
                    EventManager.emitServerNotification(typeValue, notificationId, payload, status, refValue)
                    Logger.d("ServerNotification hooked and event emitted: $typeValue", LogSource.MODULE)
                } catch (e: Exception) {
                    Logger.e("Failed to emit server notification event: ${e.message}", LogSource.MODULE)
                }
            }
        } catch (e: Exception) {
            Logger.e("Failed to setup server notification hook: ${e.message}", LogSource.MODULE)
        }
    }
    private fun registerActivityLifecycleCallbacks(application: Application) {
        application.registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacks {
            override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) {
                when {
                    activity.javaClass.name == ageVerificationActivity -> {
                        showAgeVerificationComplianceDialog(activity)
                    }
                    activity.javaClass.name == browseExploreActivity -> {
                        if ((Config.get("maps_api_key", "") as String).isEmpty()) {
                            if (!bridgeClient.isLSPosed()) {
                                showMapsApiKeyDialog(activity)
                            }
                        }
                    }
                    shouldShowBridgeConnectionError -> {
                        showBridgeConnectionError(activity)
                        shouldShowBridgeConnectionError = false
                    }
                    shouldShowVersionMismatchDialog -> {
                        showVersionMismatchDialog(activity)
                        shouldShowVersionMismatchDialog = false
                    }
                }
                if (isImportingSomething) {
                    handleImports(activity)
                }
            }
            override fun onActivityStarted(activity: Activity) {}
            override fun onActivityResumed(activity: Activity) {
                Logger.d("Resuming activity: ${activity.javaClass.name}", LogSource.MODULE)
                currentActivityRef = WeakReference(activity)
            }
            override fun onActivityPaused(activity: Activity) {
                Logger.d("Pausing activity: ${activity.javaClass.name}", LogSource.MODULE)
                if (currentActivity == activity) {
                    currentActivityRef = null
                }
            }
            override fun onActivityStopped(activity: Activity) {}
            override fun onActivitySaveInstanceState(activity: Activity, outState: Bundle) {}
            override fun onActivityDestroyed(activity: Activity) {}
        })
    }
    private fun setupInstanceManager() {
        if (isInstanceManagerInitialized) {
            Logger.d("InstanceManager already initialized, skipping", LogSource.MODULE)
            return
        }
        instanceManager.hookClassConstructors(
            userAgent,
            userSession,
            deviceInfo,
            grindrLocationProvider,
            serverDrivenCascadeRepo
        )
        instanceManager.setCallback(userSession) { uSession ->
            instanceManager.setCallback(userAgent) { uAgent ->
                instanceManager.setCallback(deviceInfo) { dInfo ->
                    httpClient = Client(Interceptor(uSession, uAgent, dInfo))
                    executeAsync {
                        kotlinx.coroutines.delay(1500)
                        fetchOwnUserId()
                    }
                    taskManager.registerTasks()
                }
            }
        }
        isInstanceManagerInitialized = true
    }
    private fun initializeCore() {
        if (isMainInitialized) {
            Logger.d("Core already initialized, skipping", LogSource.MODULE)
            return
        }
        Logger.i("Initializing GrindrPlus core...", LogSource.MODULE)
        if ((Config.get("reset_database", false) as Boolean)) {
            Logger.i("Resetting database...", LogSource.MODULE)
            database.clearAllTables()
            Config.put("reset_database", false)
        }
        hookManager.init()
        isMainInitialized = true
    }
    fun runOnMainThread(appContext: Context? = null, block: (Context) -> Unit) {
        val useContext = appContext ?: context
        Handler(useContext.mainLooper).post {
            block(useContext)
        }
    }
    fun runOnMainThreadWithCurrentActivity(block: (Activity) -> Unit) {
        runOnMainThread {
            currentActivity?.let { activity ->
                block(activity)
            } ?: Logger.e("Cannot execute action - no active activity", LogSource.MODULE)
        }
    }
    fun executeAsync(block: suspend () -> Unit) {
        ioScope.launch {
            try {
                block()
            } catch (e: Exception) {
                Logger.e("Async operation failed: ${e.message}", LogSource.MODULE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }
    }
    fun showToast(duration: Int, message: String, appContext: Context? = null) {
        val useContext = appContext ?: context
        runOnMainThread(useContext) {
            Toast.makeText(useContext, message, duration).show()
        }
    }
    fun loadClass(name: String): Class<*> {
        return classLoader.loadClass(name)
    }
    fun restartGrindr(timeout: Long = 0, toast: String? = null) {
        toast?.let { showToast(Toast.LENGTH_LONG, it) }
        if (timeout > 0) {
            Handler(Looper.getMainLooper()).postDelayed({
                val intent = context.packageManager
                    .getLaunchIntentForPackage(context.packageName)?.apply {
                        addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
                    }
                context.startActivity(intent)
                android.os.Process.killProcess(android.os.Process.myPid())
            }, timeout)
        } else {
            val intent = context.packageManager
                .getLaunchIntentForPackage(context.packageName)?.apply {
                    addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
                }
            context.startActivity(intent)
            android.os.Process.killProcess(android.os.Process.myPid())
        }
    }
    private fun checkVersionCodes(versionCodes: IntArray, versionNames: Array<String>) {
        val pkgInfo = context.packageManager.getPackageInfo(context.packageName, 0)
        val versionCode: Long = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            pkgInfo.longVersionCode
        } else {
            @Suppress("DEPRECATION")
            pkgInfo.versionCode.toLong()
        }
        val isVersionNameSupported = pkgInfo.versionName in versionNames
        val isVersionCodeSupported = versionCodes.any { it.toLong() == versionCode }
        if (!isVersionNameSupported || !isVersionCodeSupported) {
            val installedInfo = "${pkgInfo.versionName} (code: $versionCode)"
            val expectedInfo = "${versionNames.joinToString(", ")} " +
                    "(code: ${BuildConfig.TARGET_GRINDR_VERSION_CODES.joinToString(", ")})"
            shouldShowVersionMismatchDialog = true
            Logger.w("Version mismatch detected. Installed: $installedInfo, Required: $expectedInfo", LogSource.MODULE)
        }
        hasCheckedVersions = true
    }
    private fun showVersionMismatchDialog(activity: Activity) {
        try {
            val pkgInfo = context.packageManager.getPackageInfo(context.packageName, 0)
            val versionCode: Long = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                pkgInfo.longVersionCode
            } else {
                @Suppress("DEPRECATION")
                pkgInfo.versionCode.toLong()
            }
            val installedInfo = "${pkgInfo.versionName} (code: $versionCode)"
            val expectedInfo = "${BuildConfig.TARGET_GRINDR_VERSION_NAMES.joinToString(", ")} " +
                    "(code: ${BuildConfig.TARGET_GRINDR_VERSION_CODES.joinToString(", ")})"
            val dialog = android.app.AlertDialog.Builder(activity)
                .setTitle("GrindrPlus: Version Mismatch")
                .setMessage("Incompatible Grindr version detected.\n\n" +
                        "• Installed: $installedInfo\n" +
                        "• Required: $expectedInfo\n\n" +
                        "GrindrPlus has been disabled. Please install a compatible Grindr version.")
                .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setCancelable(false)
                .create()
            dialog.show()
            Logger.i("Version mismatch dialog shown", LogSource.MODULE)
        } catch (e: Exception) {
            Logger.e("Failed to show version mismatch dialog: ${e.message}", LogSource.MODULE)
            showToast(Toast.LENGTH_LONG, "Version mismatch detected. Please install a compatible Grindr version.")
        }
    }
    private fun showBridgeConnectionError(activity: Activity? = null) {
        try {
            val targetActivity = activity ?: currentActivity
            if (targetActivity != null) {
                val dialog = android.app.AlertDialog.Builder(targetActivity)
                    .setTitle("Bridge Connection Failed")
                    .setMessage("Failed to connect to the bridge service. The module will not work properly.\n\n" +
                            "This may be caused by:\n" +
                            "• Battery optimization settings\n" +
                            "• System killing background processes\n" +
                            "• App being force stopped\n\n" +
                            "Try restarting the app or reinstalling the module.")
                    .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
                    .setIcon(android.R.drawable.ic_dialog_alert)
                    .setCancelable(false)
                    .create()
                targetActivity.runOnUiThread {
                    dialog.show()
                }
                Logger.i("Bridge connection error dialog shown", LogSource.MODULE)
            } else {
                showToast(Toast.LENGTH_LONG, "Bridge service connection failed - module features unavailable")
            }
        } catch (e: Exception) {
            Logger.e("Failed to show bridge error dialog: ${e.message}", LogSource.MODULE)
            showToast(Toast.LENGTH_LONG, "Bridge service connection failed - module features unavailable")
        }
    }
    private fun showAgeVerificationComplianceDialog(activity: Activity) {
        try {
            val dialog = AlertDialog.Builder(activity)
                .setTitle("Age Verification Required")
                .setMessage("You are accessing Grindr from the UK where age verification is legally mandated.\n\n" +
                        "LEGAL COMPLIANCE NOTICE:\n" +
                        "GrindrPlus does NOT bypass, disable, or interfere with age verification systems. Any attempt to circumvent age verification requirements is illegal under UK law and is strictly prohibited.\n\n" +
                        "MANDATORY REQUIREMENTS:\n" +
                        "1. Complete age verification using the official Grindr application\n" +
                        "2. Comply with all UK legal verification processes\n" +
                        "3. Install GrindrPlus only after successful verification through official channels\n\n" +
                        "WARNING:\n" +
                        "The developers of this module are not responsible for any legal consequences resulting from non-compliance with age verification requirements.")
                .setPositiveButton("I Understand") { dialog, _ ->
                    activity.finish()
                    dialog.dismiss()
                    showToast(Toast.LENGTH_LONG,
                        "Please complete age verification in the official Grindr app first, then reinstall GrindrPlus")
                }
                .setNegativeButton("Exit App") { dialog, _ ->
                    dialog.dismiss()
                    android.os.Process.killProcess(android.os.Process.myPid())
                }
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setCancelable(false)
                .create()
            dialog.show()
            Logger.i("Age verification compliance dialog shown", LogSource.MODULE)
        } catch (e: Exception) {
            Logger.e("Failed to show age verification dialog: ${e.message}", LogSource.MODULE)
            showToast(Toast.LENGTH_LONG,
                "Age verification required. Please use official Grindr app to verify, then reinstall GrindrPlus.")
            activity.finish()
        }
    }
    private fun showMapsApiKeyDialog(context: Context) {
        try {
            AlertDialog.Builder(context)
                .setTitle("Maps API Key Required")
                .setMessage("Maps functionality requires a Google Maps API key for LSPatch users due to signature validation issues.\n\n" +
                        "Quick Setup:\n" +
                        "1. Create a Google Cloud project at console.cloud.google.com\n" +
                        "2. Enable: Maps SDK for Android, Geocoding API, Maps JavaScript API\n" +
                        "3. Create API key with NO restrictions\n" +
                        "4. Add key to GrindrPlus settings\n" +
                        "5. REINSTALL GrindrPlus (restart won't work)\n\n" +
                        "Note: Google may request credit card for free tier.")
                .setPositiveButton("Open Console") { dialog, _ ->
                    dialog.dismiss()
                    try {
                        val intent = Intent(Intent.ACTION_VIEW).apply {
                            data = "https://console.cloud.google.com/".toUri()
                            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                        }
                        val appContext = context.applicationContext
                        appContext.startActivity(intent)
                    } catch (e: Exception) {
                        showToast(Toast.LENGTH_LONG, "Unable to open browser. Please visit console.cloud.google.com manually")
                    }
                }
                .setNegativeButton("Dismiss") { dialog, _ -> dialog.dismiss() }
                .setIcon(android.R.drawable.ic_dialog_info)
                .setCancelable(true)
                .show()
        } catch (e: Exception) {
            Logger.e("Maps API key dialog error: ${e.message}")
        }
    }
    private fun fetchRemoteData(url: String, callback: (List<Pair<Long, Int>>) -> Unit) {
        val client = OkHttpClient()
        val request = Request.Builder().url(url).build()
        client.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                Logger.e("Failed to fetch remote data: ${e.message}", LogSource.MODULE)
                Logger.writeRaw(e.stackTraceToString())
            }
            override fun onResponse(call: Call, response: Response) {
                response.body?.string()?.let { jsonString ->
                    try {
                        val jsonArray = JSONArray(jsonString)
                        val parsedPoints = mutableListOf<Pair<Long, Int>>()
                        for (i in 0 until jsonArray.length()) {
                            val obj = jsonArray.getJSONObject(i)
                            val time = obj.getLong("time")
                            val id = obj.getInt("id")
                            parsedPoints.add(time to id)
                        }
                        callback(parsedPoints)
                    } catch (e: Exception) {
                        Logger.e("Failed to parse remote data: ${e.message}", LogSource.MODULE)
                        Logger.writeRaw(e.stackTraceToString())
                    }
                }
            }
        })
    }
    private fun fetchOwnUserId() {
        executeAsync {
            try {
                Logger.d("Fetching own user ID...", LogSource.MODULE)
                val response = httpClient.sendRequest(
                    url = "https://grindr.mobi/v5/me/profile",
                    method = "GET"
                )
                if (response.isSuccessful) {
                    val responseBody = response.body?.string()
                    if (!responseBody.isNullOrEmpty()) {
                        val jsonResponse = JSONObject(responseBody)
                        val profilesArray = jsonResponse.optJSONArray("profiles")
                        if (profilesArray != null && profilesArray.length() > 0) {
                            val profile = profilesArray.getJSONObject(0)
                            val profileId = profile.optString("profileId")
                            if (profileId.isNotEmpty()) {
                                myProfileId = profileId
                                Logger.i(
                                    "Own user ID fetched and saved: $myProfileId",
                                    LogSource.MODULE
                                )
                            } else {
                                Logger.w("Profile ID field is empty in response", LogSource.MODULE)
                            }
                        } else {
                            Logger.w("No profiles array found in response", LogSource.MODULE)
                        }
                    } else {
                        Logger.w("Empty response body from profile endpoint", LogSource.MODULE)
                    }
                } else {
                    Logger.e("Failed to fetch own profile: HTTP ${response.code}", LogSource.MODULE)
                }
            } catch (e: Exception) {
                Logger.e("Error fetching own user ID: ${e.message}", LogSource.MODULE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }
    }
        private fun setupCrashLogging() {
            val defaultHandler = Thread.getDefaultUncaughtExceptionHandler()
            Thread.setDefaultUncaughtExceptionHandler { thread, throwable ->
                try {
                    Logger.e("Uncaught exception in thread: ${thread.name}", LogSource.MODULE)
                    Logger.e("Exception: ${throwable.javaClass.simpleName}: ${throwable.message}", LogSource.MODULE)
                    Logger.writeRaw("Thread: ${thread.name} (id=${thread.id})")
                    Logger.writeRaw("Exception: ${throwable.javaClass.name}")
                    Logger.writeRaw("Message: ${throwable.message}")
                    Logger.writeRaw("Stack trace:")
                    Logger.writeRaw(throwable.stackTraceToString())
                    throwable.cause?.let { cause ->
                        Logger.writeRaw("Caused by: ${cause.javaClass.name}: ${cause.message}")
                        Logger.writeRaw(cause.stackTraceToString())
                    }
                } catch (e: Exception) {
                    Timber.tag("GrindrPlus").e("Failed to log crash: ${e.message}")
                    Timber.tag("GrindrPlus").e("Original crash: ${throwable.message}")
                } finally {
                    defaultHandler?.uncaughtException(thread, throwable)
                }
            }
        }
    } 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\XposedLoader.kt --- 
package com.grindrplus
class XposedLoader : IXposedHookZygoteInit, IXposedHookLoadPackage {
    private lateinit var modulePath: String
    override fun initZygote(startupParam: IXposedHookZygoteInit.StartupParam) {
        modulePath = startupParam.modulePath
    }
    override fun handleLoadPackage(lpparam: XC_LoadPackage.LoadPackageParam) {
        if (lpparam.packageName.startsWith("com.grindrplus")) {
            findAndHookMethod(
                "com.grindrplus.manager.utils.MiscUtilsKt",
                lpparam.classLoader,
                "isLSPosed",
                XC_MethodReplacement.returnConstant(true)
            )
        }
        if (!lpparam.packageName.contains(GRINDR_PACKAGE_NAME)) return
        spoofSignatures(lpparam)
        if (BuildConfig.DEBUG) {
            sslUnpinning(lpparam)
        }
        Application::class.java.hook("attach", HookStage.AFTER) {
            val application = it.thisObject()
            GrindrPlus.init(modulePath, application,
                BuildConfig.TARGET_GRINDR_VERSION_CODES,
                BuildConfig.TARGET_GRINDR_VERSION_NAMES)
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\bridge\BridgeClient.kt --- 
package com.grindrplus.bridge
class BridgeClient(private val context: Context) {
    private var bridgeService: IBridgeService? = null
    private val isConnecting = AtomicBoolean(false)
    private val isBound = AtomicBoolean(false)
    private val coroutineScope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    private val mainHandler = Handler(Looper.getMainLooper())
    private val serviceWatchdog = Handler(Looper.getMainLooper())
    private var lastConnectionAttempt = 0L
    private var connectionDeferreds = mutableMapOf<String, CompletableDeferred<Boolean>>()
    private val bindingExecutor = Executors.newSingleThreadExecutor()
    companion object {
        const val CONNECTION_TIMEOUT_MS = 5000L
        private const val WATCHDOG_CHECK_INTERVAL_MS = 30000L
        private const val RECONNECT_DELAY_MS = 2000L
    }
    init {
        Logger.initialize(context, this, false)
    }
    private val connection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, binder: IBinder?) {
            bridgeService = IBridgeService.Stub.asInterface(binder)
            isBound.set(true)
            isConnecting.set(false)
            connectionDeferreds.forEach { (_, deferred) ->
                if (!deferred.isCompleted) deferred.complete(true)
            }
            connectionDeferreds.clear()
            Logger.i("Connected to bridge service", LogSource.BRIDGE)
        }
        override fun onServiceDisconnected(name: ComponentName?) {
            bridgeService = null
            isBound.set(false)
            Logger.i("Disconnected from bridge service", LogSource.BRIDGE)
            if (!isConnecting.get()) {
                mainHandler.postDelayed({
                    if (!isBound.get() && !isConnecting.get()) {
                        Logger.d("Auto-reconnecting after service disconnection", LogSource.BRIDGE)
                        coroutineScope.launch {
                            connect()
                        }
                    }
                }, RECONNECT_DELAY_MS)
            }
        }
    }
    private val watchdogRunnable = object : Runnable {
        override fun run() {
            if (!isBound.get() && !isConnecting.get()) {
                val now = System.currentTimeMillis()
                if (now - lastConnectionAttempt > 5000) {
                    Logger.w("Service watchdog detected disconnection, reconnecting...", LogSource.BRIDGE)
                    coroutineScope.launch {
                        connectWithRetry()
                    }
                }
            }
            serviceWatchdog.postDelayed(this, WATCHDOG_CHECK_INTERVAL_MS)
        }
    }
    fun startWatchdog() {
        serviceWatchdog.removeCallbacks(watchdogRunnable)
        serviceWatchdog.postDelayed(watchdogRunnable, WATCHDOG_CHECK_INTERVAL_MS)
        Logger.d("Started service watchdog", LogSource.BRIDGE)
    }
    fun stopWatchdog() {
        serviceWatchdog.removeCallbacks(watchdogRunnable)
        Logger.d("Stopped service watchdog", LogSource.BRIDGE)
    }
    fun isConnected(): Boolean {
        return isBound.get()
    }
    fun getService(): IBridgeService? = bridgeService
    suspend fun connectWithRetry(maxRetries: Int = 3, retryDelay: Long = 1000): Boolean {
        var attempts = 0
        var connected = false
        while (!connected && attempts < maxRetries) {
            attempts++
            Logger.d("Connection attempt $attempts/$maxRetries", LogSource.BRIDGE)
            connected = connect()
            if (connected) {
                Logger.i("Successfully connected on attempt $attempts", LogSource.BRIDGE)
                return true
            }
            if (attempts < maxRetries) {
                delay(retryDelay)
            }
        }
        if (!connected) {
            Logger.w("Failed to connect after $maxRetries attempts", LogSource.BRIDGE)
        }
        return connected
    }
    fun connectAsync(onConnected: ((Boolean) -> Unit)? = null) {
        coroutineScope.launch {
            val result = connect()
            withContext(Dispatchers.Main) {
                onConnected?.invoke(result)
            }
        }
    }
    suspend fun connect(): Boolean {
        if (isBound.get()) {
            return true
        }
        if (isConnecting.getAndSet(true)) {
            Logger.d("Connection already in progress, waiting...", LogSource.BRIDGE)
            val connectionKey = "connect-${System.currentTimeMillis()}"
            val deferred = CompletableDeferred<Boolean>()
            connectionDeferreds[connectionKey] = deferred
            try {
                return withTimeout(CONNECTION_TIMEOUT_MS) {
                    deferred.await()
                }
            } catch (e: Exception) {
                Logger.w("Timeout waiting for existing connection", LogSource.BRIDGE)
                connectionDeferreds.remove(connectionKey)
                return false
            }
        }
        lastConnectionAttempt = System.currentTimeMillis()
        try {
            startService()
        } catch (e: Exception) {
            Logger.e("Failed to start service: ${e.message}", LogSource.BRIDGE)
            isConnecting.set(false)
            return false
        }
        val intent = Intent().apply {
            setClassName(
                BuildConfig.APPLICATION_ID,
                BridgeService::class.java.name
            )
        }
        return suspendCancellableCoroutine { continuation ->
            val bindResult = try {
                bindServiceSafely(intent)
            } catch (e: Exception) {
                Logger.e("Error binding service: ${e.message}", LogSource.BRIDGE)
                isConnecting.set(false)
                continuation.resume(false)
                return@suspendCancellableCoroutine
            }
            if (!bindResult) {
                Logger.w("bindService returned false", LogSource.BRIDGE)
                isConnecting.set(false)
                continuation.resume(false)
                return@suspendCancellableCoroutine
            }
            val timeoutHandler = Handler(Looper.getMainLooper())
            val timeoutOccurred = AtomicBoolean(false)
            val timeoutRunnable = Runnable {
                if (continuation.isActive && !timeoutOccurred.getAndSet(true)) {
                    Logger.w("Connection timeout", LogSource.BRIDGE)
                    try {
                        context.unbindService(connection)
                    } catch (e: Exception) {
                        Logger.e("Error unbinding service after timeout: ${e.message}", LogSource.BRIDGE)
                    }
                    isConnecting.set(false)
                    continuation.resume(false)
                }
            }
            timeoutHandler.postDelayed(timeoutRunnable, CONNECTION_TIMEOUT_MS)
            continuation.invokeOnCancellation {
                timeoutHandler.removeCallbacks(timeoutRunnable)
                try {
                    context.unbindService(connection)
                } catch (e: Exception) {
                    Logger.e("Error unbinding service on cancellation: ${e.message}", LogSource.BRIDGE)
                }
                isConnecting.set(false)
            }
            val connectionKey = "connect-${continuation.hashCode()}"
            val deferred = CompletableDeferred<Boolean>()
            connectionDeferreds[connectionKey] = deferred
            coroutineScope.launch {
                val result = try {
                    withTimeout(CONNECTION_TIMEOUT_MS) {
                        deferred.await()
                    }
                } catch (_: Exception) {
                    false
                }
                connectionDeferreds.remove(connectionKey)
                timeoutHandler.removeCallbacks(timeoutRunnable)
                if (continuation.isActive && !timeoutOccurred.get()) {
                    continuation.resume(result)
                }
            }
        }
    }
    fun connectBlocking(timeoutMs: Long = CONNECTION_TIMEOUT_MS): Boolean {
        if (isBound.get()) {
            return true
        }
        Logger.d("Attempting to connect to bridge service (blocking)", LogSource.BRIDGE)
        val result = runBlocking {
            try {
                withTimeout(timeoutMs) {
                    connect()
                }
            } catch (e: Exception) {
                Logger.w("Connection timeout in blocking mode", LogSource.BRIDGE)
                false
            }
        }
        return result
    }
    private fun bindServiceSafely(intent: Intent): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            context.bindService(
                intent,
                Context.BIND_AUTO_CREATE,
                bindingExecutor,
                connection
            )
        } else {
            try {
                val handlerThread = HandlerThread("BridgeClientThread")
                handlerThread.start()
                val handler = Handler(handlerThread.looper)
                val bindResult = try {
                    val userHandle = Process::class.java.getMethod("myUserHandle").invoke(null)
                    context.javaClass.getMethod(
                        "bindServiceAsUser",
                        Intent::class.java,
                        ServiceConnection::class.java,
                        Int::class.javaPrimitiveType,
                        Handler::class.java,
                        userHandle.javaClass
                    ).invoke(
                        context,
                        intent,
                        connection,
                        Context.BIND_AUTO_CREATE,
                        handler,
                        userHandle
                    ) as Boolean
                } catch (e: Exception) {
                    Logger.w("bindServiceAsUser failed, falling back to bindService: ${e.message}", LogSource.BRIDGE)
                    context.bindService(intent, connection, Context.BIND_AUTO_CREATE)
                }
                bindResult
            } catch (e: Exception) {
                Logger.e("Failed to bind service with any method: ${e.message}", LogSource.BRIDGE)
                context.bindService(intent, connection, Context.BIND_AUTO_CREATE)
            }
        }
    }
    private fun startService() {
        try {
            val serviceIntent = Intent().apply {
                setClassName(
                    BuildConfig.APPLICATION_ID,
                    "${BuildConfig.APPLICATION_ID}.bridge.BridgeService"
                )
            }
            try {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    context.startForegroundService(serviceIntent)
                    Logger.d("Service start attempt via startForegroundService", LogSource.BRIDGE)
                } else {
                    context.startService(serviceIntent)
                    Logger.d("Service start attempt via startService", LogSource.BRIDGE)
                }
                Thread.sleep(100)
            } catch (e: Exception) {
                Logger.w("Failed to start service directly: ${e.message}", LogSource.BRIDGE)
                try {
                    val forceStartIntent = ForceStartActivity.createIntent(context)
                    context.startActivity(forceStartIntent)
                    Logger.d("Service start attempt via ForceStartActivity (fallback)", LogSource.BRIDGE)
                    Thread.sleep(50)
                } catch (e2: Exception) {
                    Logger.e("All service start methods failed: ${e2.message}", LogSource.BRIDGE)
                }
            }
        } catch (e: Exception) {
            Logger.e("Failed to start service: ${e.message}", LogSource.BRIDGE)
        }
    }
    fun unbind() {
        if (isBound.getAndSet(false)) {
            try {
                context.unbindService(connection)
                bridgeService = null
            } catch (e: Exception) {
                Logger.e("Error unbinding service: ${e.message}", LogSource.BRIDGE)
            }
        }
    }
    fun getConfig(): JSONObject {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for getConfig", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot get config, service not bound", LogSource.BRIDGE)
                return JSONObject()
            }
        }
        return try {
            bridgeService?.config?.let { JSONObject(it) } ?: JSONObject()
        } catch (e: Exception) {
            Logger.e("Error getting config: ${e.message}", LogSource.BRIDGE)
            JSONObject()
        }
    }
    fun setConfig(config: JSONObject) {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for setConfig", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot set config, service not bound", LogSource.BRIDGE)
                return
            }
        }
        try {
            bridgeService?.setConfig(config.toString(4))
        } catch (e: Exception) {
            Logger.e("Error setting config: ${e.message}", LogSource.BRIDGE)
        }
    }
    fun logBlockEvent(profileId: String, displayName: String, isBlock: Boolean, packageName: String) {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for logBlockEvent", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot log block event, service not bound", LogSource.BRIDGE)
                return
            }
        }
        try {
            bridgeService?.logBlockEvent(profileId, displayName, isBlock, packageName)
        } catch (e: Exception) {
            Logger.e("Error logging block event: ${e.message}", LogSource.BRIDGE)
        }
    }
    fun getBlockEvents(): JSONArray {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for getBlockEvents", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot get block events, service not bound", LogSource.BRIDGE)
                return JSONArray()
            }
        }
        return try {
            bridgeService?.blockEvents?.let { JSONArray(it) } ?: JSONArray()
        } catch (e: Exception) {
            Logger.e("Error getting block events: ${e.message}", LogSource.BRIDGE)
            JSONArray()
        }
    }
    fun clearBlockEvents() {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for clearBlockEvents", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot clear block events, service not bound", LogSource.BRIDGE)
                return
            }
        }
        try {
            bridgeService?.clearBlockEvents()
        } catch (e: Exception) {
            Logger.e("Error clearing block events: ${e.message}", LogSource.BRIDGE)
        }
    }
    fun sendNotification(
        title: String,
        message: String,
        notificationId: Int,
        channelId: String = "default_channel_id",
        channelName: String = "Default Channel",
        channelDescription: String = "Default notifications"
    ) {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for sendNotification", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot send notification, service not bound", LogSource.BRIDGE)
                return
            }
        }
        try {
            bridgeService?.sendNotification(
                title,
                message,
                notificationId,
                channelId,
                channelName,
                channelDescription
            )
        } catch (e: Exception) {
            Logger.e("Error sending notification: ${e.message}", LogSource.BRIDGE)
        }
    }
    fun sendNotificationWithMultipleActions(
        title: String,
        message: String,
        notificationId: Int,
        actionLabels: List<String>,
        actionTypes: List<String>,
        actionData: List<String>,
        channelId: String = "default_channel_id",
        channelName: String = "Default Channel",
        channelDescription: String = "Default notifications"
    ) {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for sendNotificationWithActions", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot send notification, service not bound", LogSource.BRIDGE)
                return
            }
        }
        try {
            bridgeService?.sendNotificationWithActions(
                title,
                message,
                notificationId,
                channelId,
                channelName,
                channelDescription,
                actionLabels.toTypedArray(),
                actionTypes.toTypedArray(),
                actionData.toTypedArray()
            )
        } catch (e: Exception) {
            Logger.e("Error sending notification with multiple actions: ${e.message}", LogSource.BRIDGE)
        }
    }
    fun shouldRegenAndroidId(packageName: String): Boolean {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d(
                    "Connected to service on-demand for shouldRegenAndroidId",
                    LogSource.BRIDGE
                )
            } else {
                Logger.w(
                    "Cannot check Android ID regeneration, service not bound",
                    LogSource.BRIDGE
                )
                return false
            }
        }
        return try {
            bridgeService?.shouldRegenAndroidId(packageName) ?: false
        } catch (e: Exception) {
            Logger.e("Error checking Android ID regeneration: ${e.message}", LogSource.BRIDGE)
            false
        }
    }
    fun getForcedLocation(packageName: String): String {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for getForcedLocation", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot get forced location, service not bound", LogSource.BRIDGE)
                return ""
            }
        }
        return try {
            bridgeService?.getForcedLocation(packageName) ?: ""
        } catch (e: Exception) {
            Logger.e("Error getting forced location: ${e.message}", LogSource.BRIDGE)
            ""
        }
    }
    fun deleteForcedLocation(packageName: String) {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for deleteForcedLocation", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot delete forced location, service not bound", LogSource.BRIDGE)
                return
            }
        }
        try {
            bridgeService?.deleteForcedLocation(packageName)
        } catch (e: Exception) {
            Logger.e("Error deleting forced location: ${e.message}", LogSource.BRIDGE)
        }
    }
    fun isRooted(): Boolean {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for isRooted", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot check root status, service not bound", LogSource.BRIDGE)
                return false
            }
        }
        return try {
            bridgeService?.isRooted() ?: false
        } catch (e: Exception) {
            Logger.e("Error checking root status: ${e.message}", LogSource.BRIDGE)
            false
        }
    }
    fun isLSPosed(): Boolean {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for isLSPosed", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot check LSPosed status, service not bound", LogSource.BRIDGE)
                return false
            }
        }
        return try {
            bridgeService?.isLSPosed() ?: false
        } catch (e: Exception) {
            Logger.e("Error checking LSPosed status: ${e.message}", LogSource.BRIDGE)
            false
        }
    }
}
private fun <T> runBlocking(block: suspend () -> T): T {
    return java.util.concurrent.CompletableFuture<T>().let { future ->
        CoroutineScope(Dispatchers.IO).launch {
            try {
                future.complete(block())
            } catch (e: Exception) {
                future.completeExceptionally(e)
            }
        }
        try {
            future.get(BridgeClient.CONNECTION_TIMEOUT_MS + 1000, TimeUnit.MILLISECONDS)
        } catch (e: Exception) {
            throw e.cause ?: e
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\bridge\BridgeService.kt --- 
package com.grindrplus.bridge
@SuppressLint("MissingPermission")
class BridgeService : Service() {
    private val configFile by lazy { File(getExternalFilesDir(null), "grindrplus.json") }
    private val logFile by lazy { File(getExternalFilesDir(null), "grindrplus.log") }
    private val blockEventsFile by lazy { File(getExternalFilesDir(null), "block_events.json") }
    private val blockEventsLock = ReentrantLock()
    private val ioExecutor = Executors.newSingleThreadExecutor()
    private val logLock = ReentrantLock()
    private val MAX_LOG_SIZE = 5 * 1024 * 1024
    private val periodicTasksExecutor = Executors.newSingleThreadScheduledExecutor()
    private var isForegroundStarted = false
    override fun onCreate() {
        super.onCreate()
        Logger.i("BridgeService created", LogSource.BRIDGE)
        Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND)
        initializeFiles()
    }
    override fun onBind(intent: Intent?): IBinder {
        Logger.i("BridgeService bound", LogSource.BRIDGE)
        startForegroundSafely()
        return binder
    }
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Logger.i("BridgeService started", LogSource.BRIDGE)
        startForegroundSafely()
        return START_STICKY
    }
    private fun startForegroundSafely() {
        if (isForegroundStarted) {
            return
        }
        try {
            val channelId = "bridge_service_channel"
            createNotificationChannel(channelId, "GrindrPlus Background Service", "Keeps GrindrPlus running in background")
            val notification = NotificationCompat.Builder(this, channelId)
                .setContentTitle("GrindrPlus")
                .setContentText("Background service active")
                .setSmallIcon(android.R.drawable.ic_dialog_info)
                .setPriority(NotificationCompat.PRIORITY_MIN)
                .setVisibility(NotificationCompat.VISIBILITY_SECRET)
                .setOngoing(true)
                .setShowWhen(false)
                .build()
            try {
                periodicTasksExecutor.scheduleWithFixedDelay(
                    { runBlocking { fetchNotifs(this@BridgeService) } },
                    0,
                    15,
                    java.util.concurrent.TimeUnit.SECONDS
                )
            } catch (e: Exception) {
                Timber.tag(TAG).e(e, "Failed to schedule periodic tasks")
            }
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                ServiceCompat.startForeground(
                    this,
                    1001,
                    notification,
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                        ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE
                    } else {
                        0
                    }
                )
            } else {
                startForeground(1001, notification)
            }
            isForegroundStarted = true
            Logger.i("Foreground service started successfully", LogSource.BRIDGE)
        } catch (e: Exception) {
            Logger.w("Failed to start foreground service: ${e.message}", LogSource.BRIDGE)
            Logger.writeRaw(e.stackTraceToString())
            // If we can't start as foreground, continue as normal service
            // The service will still work, just won't be protected from being killed
            isForegroundStarted = false
        }
    }
    private fun initializeFiles() {
        ioExecutor.execute {
            try {
                if (!configFile.exists()) {
                    configFile.createNewFile()
                    configFile.writeText("{}")
                }
                if (!logFile.exists()) {
                    logFile.createNewFile()
                }
                if (!blockEventsFile.exists()) {
                    blockEventsFile.createNewFile()
                    blockEventsFile.writeText("[]")
                }
            } catch (e: Exception) {
                Logger.e("Failed to initialize files: ${e.message}", LogSource.BRIDGE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }
    }
    private val binder = object : IBridgeService.Stub() {
        override fun getConfig(): String {
            Logger.d("getConfig() called")
            return try {
                if (!configFile.exists()) {
                    configFile.createNewFile()
                    "{}"
                } else {
                    configFile.readText().ifBlank { "{}" }
                }
            } catch (e: Exception) {
                Logger.e("Error reading config file", LogSource.BRIDGE)
                Logger.writeRaw(e.stackTraceToString())
                "{}"
            }
        }
        override fun setConfig(config: String?) {
            Logger.d("setConfig() called")
            try {
                if (!configFile.exists()) {
                    configFile.createNewFile()
                }
                configFile.writeText(config ?: "{}")
            } catch (e: Exception) {
                Logger.e("Error writing to config file", LogSource.BRIDGE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }
        override fun log(level: String, source: String, message: String, hookName: String?) {
            ioExecutor.execute {
                try {
                    checkAndManageLogSize()
                    val formattedLog = formatLogEntry(level, source, message, hookName)
                    appendToLog(formattedLog)
                } catch (e: Exception) {
                    Logger.e("Error writing log entry", LogSource.BRIDGE)
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
        }
        override fun writeRawLog(content: String) {
            ioExecutor.execute {
                try {
                    checkAndManageLogSize()
                    appendToLog(content + (if (!content.endsWith("\n")) "\n" else ""))
                } catch (e: Exception) {
                    Logger.e("Error writing raw log entry", LogSource.BRIDGE)
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
        }
        override fun clearLogs() {
            Logger.d("clearLogs() called")
            try {
                logLock.withLock {
                    if (logFile.exists()) {
                        logFile.delete()
                        logFile.createNewFile()
                    }
                }
            } catch (e: Exception) {
                Logger.e("Error clearing log file", LogSource.BRIDGE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }
        override fun sendNotification(
            title: String,
            message: String,
            notificationId: Int,
            channelId: String,
            channelName: String,
            channelDescription: String
        ) {
            Logger.d("sendNotification() called")
            try {
                createNotificationChannel(channelId, channelName, channelDescription)
                val notificationBuilder = NotificationCompat.Builder(applicationContext, channelId)
                    .setSmallIcon(android.R.drawable.ic_dialog_info)
                    .setContentTitle(title)
                    .setContentText(message)
                    .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                    .setAutoCancel(true)
                with(NotificationManagerCompat.from(applicationContext)) {
                    notify(notificationId, notificationBuilder.build())
                }
            } catch (e: Exception) {
                Logger.e("Error sending notification", LogSource.BRIDGE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }
        override fun sendNotificationWithActions(
            title: String,
            message: String,
            notificationId: Int,
            channelId: String,
            channelName: String,
            channelDescription: String,
            actionLabels: Array<String>,
            actionIntents: Array<String>,
            actionData: Array<String>
        ) {
            Logger.d("sendNotificationWithActions() called")
            try {
                createNotificationChannel(channelId, channelName, channelDescription)
                val notificationBuilder = NotificationCompat.Builder(applicationContext, channelId)
                    .setSmallIcon(android.R.drawable.ic_dialog_info)
                    .setContentTitle(title)
                    .setContentText(message)
                    .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                    .setAutoCancel(true)
                for (i in actionLabels.indices) {
                    if (i >= actionIntents.size || i >= actionData.size) break
                    val intent = createActionIntent(actionIntents[i], actionData[i])
                    val pendingIntent = PendingIntent.getBroadcast(
                        applicationContext,
                        notificationId + i,
                        intent,
                        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                    )
                    notificationBuilder.addAction(
                        android.R.drawable.ic_menu_send,
                        actionLabels[i],
                        pendingIntent
                    )
                }
                with(NotificationManagerCompat.from(applicationContext)) {
                    notify(notificationId, notificationBuilder.build())
                }
            } catch (e: Exception) {
                Logger.e("Error sending notification with actions", LogSource.BRIDGE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }
        override fun logBlockEvent(
            profileId: String,
            displayName: String,
            isBlock: Boolean,
            packageName: String
        ) {
            ioExecutor.execute {
                try {
                    blockEventsLock.withLock {
                        if (!blockEventsFile.exists()) {
                            blockEventsFile.createNewFile()
                            blockEventsFile.writeText("[]")
                        }
                        val eventsArray = JSONArray(blockEventsFile.readText().ifBlank { "[]" })
                        val event = JSONObject().apply {
                            put("profileId", profileId)
                            put("displayName", displayName)
                            put("eventType", if (isBlock) "block" else "unblock")
                            put("timestamp", System.currentTimeMillis())
                            put("packageName", packageName)
                        }
                        eventsArray.put(event)
                        blockEventsFile.writeText(eventsArray.toString(4))
                        Logger.d(
                            "Logged ${if (isBlock) "block" else "unblock"} event " +
                                    "for profile ${profileId.take(profileId.length - 4) + "****"}",
                            LogSource.BRIDGE
                        )
                    }
                } catch (e: Exception) {
                    Timber.tag(TAG).e(e, "Error logging block event")
                }
            }
        }
        override fun getBlockEvents(): String {
            return try {
                if (!blockEventsFile.exists()) {
                    blockEventsFile.createNewFile()
                    "[]"
                } else {
                    blockEventsFile.readText().ifBlank { "[]" }
                }
            } catch (e: Exception) {
                Logger.e("Error reading block events file", LogSource.BRIDGE)
                Logger.writeRaw(e.stackTraceToString())
                "[]"
            }
        }
        override fun clearBlockEvents() {
            blockEventsLock.withLock {
                try {
                    if (blockEventsFile.exists()) {
                        blockEventsFile.delete()
                        blockEventsFile.createNewFile()
                        blockEventsFile.writeText("[]")
                    }
                } catch (e: Exception) {
                    Logger.e("Error clearing block events file", LogSource.BRIDGE)
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
        }
        override fun shouldRegenAndroidId(packageName: String): Boolean {
            val regenFile = File(getExternalFilesDir(null), "$packageName.android_id_regen")
            return regenFile.exists().also { exists ->
                if (exists) {
                    regenFile.delete()
                }
            }
        }
        override fun getForcedLocation(packageName: String): String {
            val coordinatesFile = File(getExternalFilesDir(null), "$packageName.location")
            return if (coordinatesFile.exists()) {
                coordinatesFile.readText().trim().ifBlank { "" }
            } else {
                ""
            }
        }
        override fun deleteForcedLocation(packageName: String) {
            val coordinatesFile = File(getExternalFilesDir(null), "$packageName.location")
            if (coordinatesFile.exists()) {
                coordinatesFile.delete()
            }
        }
        override fun isRooted(): Boolean {
            return com.grindrplus.manager.utils.isRooted(applicationContext)
        }
        override fun isLSPosed(): Boolean {
            return com.grindrplus.manager.utils.isLSPosed()
        }
    }
    private fun createNotificationChannel(
        channelId: String,
        channelName: String,
        channelDescription: String
    ) {
        val notificationManager: NotificationManager =
            applicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        if (notificationManager.getNotificationChannel(channelId) == null) {
            val importance = if (channelId == "bridge_service_channel") {
                NotificationManager.IMPORTANCE_MIN
            } else {
                NotificationManager.IMPORTANCE_DEFAULT
            }
            val channel = NotificationChannel(channelId, channelName, importance).apply {
                description = channelDescription
                if (channelId == "bridge_service_channel") {
                    setShowBadge(false)
                    setSound(null, null)
                    enableLights(false)
                    enableVibration(false)
                }
            }
            notificationManager.createNotificationChannel(channel)
            Logger.d("Notification channel created: $channelId", LogSource.BRIDGE)
        }
    }
    private fun createActionIntent(actionType: String, actionData: String): Intent {
        val intent = when (actionType) {
            "COPY" -> Intent("com.grindrplus.COPY_ACTION").apply {
                putExtra("data", actionData)
                setPackage(applicationContext.packageName)
                setClassName(
                    applicationContext.packageName,
                    "${applicationContext.packageName}.bridge.NotificationActionReceiver"
                )
            }
            "VIEW_PROFILE" -> Intent("com.grindrplus.VIEW_PROFILE_ACTION").apply {
                putExtra("profileId", actionData)
                setPackage(applicationContext.packageName)
                setClassName(
                    applicationContext.packageName,
                    "${applicationContext.packageName}.bridge.NotificationActionReceiver"
                )
            }
            "CUSTOM" -> Intent("com.grindrplus.CUSTOM_ACTION").apply {
                putExtra("data", actionData)
                setPackage(applicationContext.packageName)
                setClassName(
                    applicationContext.packageName,
                    "${applicationContext.packageName}.bridge.NotificationActionReceiver"
                )
            }
            else -> Intent("com.grindrplus.DEFAULT_ACTION").apply {
                putExtra("data", actionData)
                setPackage(applicationContext.packageName)
                setClassName(
                    applicationContext.packageName,
                    "${applicationContext.packageName}.bridge.NotificationActionReceiver"
                )
            }
        }
        Logger.d("Action intent created: $actionType with data: $actionData", LogSource.BRIDGE)
        return intent
    }
    private fun formatLogEntry(
        level: String,
        source: String,
        message: String,
        hookName: String?
    ): String {
        val timestamp = SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", Locale.getDefault())
            .format(Date())
        return if (hookName != null) {
            "[$timestamp][$source][$level][$hookName] $message\n"
        } else {
            "[$timestamp][$source][$level] $message\n"
        }
    }
    private fun checkAndManageLogSize() {
        logLock.withLock {
            if (logFile.exists() && logFile.length() > MAX_LOG_SIZE) {
                val backupFile = File("${logFile.absolutePath}.bak")
                backupFile.takeIf { it.exists() }?.delete()
                logFile.renameTo(backupFile)
                logFile.createNewFile()
                val rotationMessage = "I/${
                    SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
                        .format(Date())
                }/system: Log file rotated due to size limit\n"
                logFile.appendText(rotationMessage)
            }
        }
    }
    private fun appendToLog(content: String) {
        logLock.withLock {
            if (!logFile.exists()) {
                logFile.createNewFile()
            }
            logFile.appendText(content)
        }
    }
    override fun onDestroy() {
        super.onDestroy()
        Logger.i("BridgeService destroyed", LogSource.BRIDGE)
        ioExecutor.shutdown()
        periodicTasksExecutor.shutdown()
    }
    companion object {
        private const val TAG = "BridgeService"
        const val CHANNEL_BLOCKS = "grindr_plus_blocks"
        const val CHANNEL_UNBLOCKS = "grindr_plus_unblocks"
        const val CHANNEL_GENERAL = "grindr_plus_general"
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\bridge\ForceStartActivity.kt --- 
package com.grindrplus.bridge
/**
 * Activity that force starts the Bridge Service
 * This is used as a lightweight mechanism to ensure the service is running
 * without requiring foreground service notifications
 */
class ForceStartActivity : Activity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Timber.tag(TAG).d("ForceStartActivity created")
        try {
            val serviceIntent = Intent().apply {
                setClassName(
                    BuildConfig.APPLICATION_ID,
                    "${BuildConfig.APPLICATION_ID}.bridge.BridgeService"
                )
            }
            startService(serviceIntent)
            val pkg = intent.getStringExtra("pkg")
            if (pkg != null) {
                val launchIntent = packageManager.getLaunchIntentForPackage(pkg)
                if (launchIntent != null) {
                    launchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    startActivity(launchIntent)
                    Timber.tag(TAG).d("Launched package: $pkg")
                }
            }
            Timber.tag(TAG).d("Bridge service started successfully")
        } catch (e: Exception) {
            Timber.tag(TAG).e(e, "Failed to start bridge service")
        }
        finish()
    }
    override fun onDestroy() {
        super.onDestroy()
        Timber.tag(TAG).d("ForceStartActivity destroyed")
    }
    companion object {
        private const val TAG = "ForceStartActivity"
        fun createIntent(context: android.content.Context, packageToLaunch: String? = null): Intent {
            return Intent().apply {
                setClassName(
                    BuildConfig.APPLICATION_ID,
                    "${BuildConfig.APPLICATION_ID}.bridge.ForceStartActivity"
                )
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                if (packageToLaunch != null) {
                    putExtra("pkg", packageToLaunch)
                }
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\bridge\NotificationActionReceiver.kt --- 
package com.grindrplus.bridge
class NotificationActionReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        Logger.d("Notification action received: ${intent.action}", LogSource.BRIDGE)
        try {
            when (intent.action) {
                "com.grindrplus.COPY_ACTION" -> {
                    val data = intent.getStringExtra("data") ?: return
                    Handler(Looper.getMainLooper()).post {
                        val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                        val clip = ClipData.newPlainText("Grindr+ Data", data)
                        clipboard.setPrimaryClip(clip)
                        Toast.makeText(context, "Copied to clipboard: $data", Toast.LENGTH_SHORT).show()
                    }
                }
                "com.grindrplus.VIEW_PROFILE_ACTION" -> {
                    val profileId = intent.getStringExtra("profileId") ?: return
                    val appIntent = Intent().apply {
                        setClassName(
                            context.packageName,
                            "${context.packageName}.manager.MainActivity"
                        )
                        putExtra("action", "VIEW_PROFILE")
                        putExtra("profileId", profileId)
                        flags = Intent.FLAG_ACTIVITY_NEW_TASK
                    }
                    context.startActivity(appIntent)
                }
                "com.grindrplus.CUSTOM_ACTION" -> {
                    val data = intent.getStringExtra("data") ?: return
                    Handler(Looper.getMainLooper()).post {
                        Toast.makeText(context, "Custom action: $data", Toast.LENGTH_SHORT).show()
                    }
                }
                "com.grindrplus.DEFAULT_ACTION" -> {
                    val data = intent.getStringExtra("data") ?: return
                    Handler(Looper.getMainLooper()).post {
                        Toast.makeText(context, "Action performed", Toast.LENGTH_SHORT).show()
                    }
                }
            }
        } catch (e: Exception) {
            Logger.e("Error handling notification action: ${e.message}", LogSource.BRIDGE)
            Logger.writeRaw(e.stackTraceToString())
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\commands\Command.kt --- 
package com.grindrplus.commands
@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.FUNCTION)
annotation class Command(val name: String, val aliases: Array<String> = [], val help: String = "") 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\commands\CommandHandler.kt --- 
package com.grindrplus.commands
class CommandHandler(
    recipient: String,
    sender: String = ""
) {
    private val commandModules: MutableList<CommandModule> = mutableListOf()
    init {
        commandModules.add(Location(recipient, sender))
        commandModules.add(Profile(recipient, sender))
        commandModules.add(Utils(recipient, sender))
        commandModules.add(Database(recipient, sender))
    }
    fun handle(input: String) {
        val args = input.trim().split("\\s+".toRegex()).filter { it.isNotEmpty() }
        val command = args.firstOrNull() ?: return
        if (command == "help") {
            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                val dialogView = LinearLayout(activity).apply {
                    orientation = LinearLayout.VERTICAL
                    setPadding(20, 20, 20, 20)
                }
                val helpText = commandModules.joinToString("\n\n") { it.getHelp() }
                val textView = AppCompatTextView(activity).apply {
                    text = helpText
                    textSize = 14f
                    setTextColor(Color.WHITE)
                    setPadding(20, 20, 20, 20)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                }
                dialogView.addView(textView)
                AlertDialog.Builder(activity)
                    .setTitle("Help")
                    .setView(dialogView)
                    .setPositiveButton("OK") { dialog, _ ->
                        dialog.dismiss()
                    }
                    .create()
                    .show()
            }
        } else {
            for (module in commandModules) {
                if (module.handle(command, args.drop(1))) break
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\commands\CommandModule.kt --- 
package com.grindrplus.commands
abstract class CommandModule(
    protected val name: String,
    protected val recipient: String,
    protected val sender: String
) {
    fun handle(inputCommand: String, args: List<String>): Boolean {
        val commandMethod = this::class.java.methods.firstOrNull {
            val annotation = it.getAnnotation(Command::class.java)
            annotation != null
                    && (annotation.name == inputCommand || inputCommand in annotation.aliases)
        }
        return commandMethod != null && try {
            commandMethod.invoke(this, args)
            true
        } catch (e: Exception) {
            val message = "Unable to execute command. Check logs for more information."
            GrindrPlus.showToast(Toast.LENGTH_LONG, message)
            Logger.apply {
                e("An error occurred while executing the command: ${e.message ?: "Unknown error"}")
                writeRaw(e.stackTraceToString())
            }
            false
        }
    }
    fun getHelp(): String {
        val commands = this::class.java.methods.mapNotNull { method ->
            val command = method.getAnnotation(Command::class.java)
            command?.let {
                if (it.aliases.isEmpty()) {
                    "${it.name}: ${it.help}"
                } else {
                    "${it.name} (${it.aliases.joinToString(", ")}): ${it.help}"
                }
            }
        }
        return "Help for $name:\n${commands.joinToString("\n") { command -> "- $command" }}"
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\commands\Database.kt --- 
package com.grindrplus.commands
class Database(
    recipient: String,
    sender: String
) : CommandModule("Database", recipient, sender) {
    @Command("list_tables", aliases = ["lts"], help = "List all tables in the database")
    fun listTables(args: List<String>) {
        try {
            val query = "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;"
            val tables = DatabaseHelper.query(query).map { it["name"].toString() }
            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                val dialogView = LinearLayout(activity).apply {
                    orientation = LinearLayout.VERTICAL
                    setPadding(60, 40, 60, 40)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                }
                val tableList = if (tables.isEmpty()) "No tables found."
                    else tables.joinToString("\n")
                val textView = AppCompatTextView(activity).apply {
                    text = tableList
                    textSize = 14f
                    setTextColor(Color.WHITE)
                    setPadding(20, 20, 20, 20)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    ).apply {
                        setMargins(0, 20, 0, 0)
                    }
                }
                dialogView.addView(textView)
                AlertDialog.Builder(activity)
                    .setTitle("Database Tables")
                    .setView(dialogView)
                    .setPositiveButton("Close") { dialog, _ ->
                        dialog.dismiss()
                    }
                    .setNegativeButton("Copy") { _, _ ->
                        copyToClipboard("Database Tables", tableList)
                    }
                    .create()
                    .show()
            }
        } catch (e: Exception) {
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Error: ${e.message}")
        }
    }
    private fun backupDatabase(): String? {
        return try {
            val context = GrindrPlus.context
            val databases = context.databaseList()
            val grindrUserDb = databases.firstOrNull {
                it.contains("grindr_user") && it.endsWith(".db")
            } ?: return null
            val sourceDb = context.getDatabasePath(grindrUserDb)
            if (!sourceDb.exists()) return null
            // Create backup directory
            val backupDir = File(Environment.getExternalStorageDirectory(), "GrindrPlusBackup")
            if (!backupDir.exists()) {
                backupDir.mkdirs()
            }
            val backupFile = File(backupDir, "grindrplus_${System.currentTimeMillis()}.db")
            // Copy the database file
            sourceDb.copyTo(backupFile, overwrite = true)
            backupFile.absolutePath
        } catch (e: Exception) {
            null
        }
    }
    // Add this command to backup the database
    @Command("backup_db", aliases = ["bdb"], help = "Backup the database to external storage")
    fun backupDatabaseCommand(args: List<String>) {
        try {
            val backupPath = backupDatabase()
            if (backupPath != null) {
                GrindrPlus.showToast(Toast.LENGTH_LONG,
                    "Database backed up successfully!\nLocation: $backupPath")
            } else {
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Failed to backup database. Check if database exists.")
            }
        } catch (e: Exception) {
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Error backing up database: ${e.message}")
        }
    }
    @Command("list_table", aliases = ["lt"], help = "List all rows from a specific table")
    fun listTable(args: List<String>) {
        if (args.isEmpty()) {
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Please provide a table name.")
            return
        }
        val tableName = args[0]
        try {
            val query = "SELECT * FROM $tableName;"
            val rows = DatabaseHelper.query(query)
            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                val dialogView = LinearLayout(activity).apply {
                    orientation = LinearLayout.VERTICAL
                    setPadding(60, 40, 60, 40)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                }
                val tableContent = if (rows.isEmpty()) {
                    "No rows found in table $tableName."
                } else {
                    rows.joinToString("\n\n") { row ->
                        row.entries.joinToString(", ") { "${it.key}: ${it.value}" }
                    }
                }
                val textView = AppCompatTextView(activity).apply {
                    text = tableContent
                    textSize = 14f
                    setTextColor(Color.WHITE)
                    setPadding(20, 20, 20, 20)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    ).apply {
                        setMargins(0, 20, 0, 0)
                    }
                }
                dialogView.addView(textView)
                AlertDialog.Builder(activity)
                    .setTitle("Table Content: $tableName")
                    .setView(dialogView)
                    .setPositiveButton("Close") { dialog, _ ->
                        dialog.dismiss()
                    }
                    .setNegativeButton("Copy") { _, _ ->
                        copyToClipboard("Table Content: $tableName", tableContent)
                    }
                    .create()
                    .show()
            }
        } catch (e: Exception) {
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Error: ${e.message}")
        }
    }
    @Command("copy_table", aliases = ["ct"], help = "Copy table from Grindr db to GrindrPlus db")
    fun copyTable(args: List<String>) {
        if (args.isEmpty()) {
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Usage: !copy_table table_name [new_table_name]")
            return
        }
        val sourceTable = args[0]
        val targetTable = args.getOrNull(1) ?: sourceTable
        try {
            // Step 1: Get table schema from source database
            val schemaQuery = "SELECT sql FROM sqlite_master WHERE type='table' AND name='$sourceTable';"
            val schemaResult = DatabaseHelper.query(schemaQuery)
            if (schemaResult.isEmpty()) {
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Table '$sourceTable' not found in source database")
                return
            }
            val createTableSQL = schemaResult[0]["sql"] as String
            val modifiedCreateSQL = createTableSQL.replace(sourceTable, targetTable)
            // Step 2: Create the table in GrindrPlus database
            val grindrPlusDb = getGrindrPlusDatabase()
            grindrPlusDb.execSQL(modifiedCreateSQL)
            // Step 3: Copy all data
            val dataQuery = "SELECT * FROM $sourceTable;"
            val sourceData = DatabaseHelper.query(dataQuery)
            if (sourceData.isNotEmpty()) {
                val columns = sourceData[0].keys.joinToString(", ")
                val placeholders = sourceData[0].keys.joinToString(", ") { "?" }
                sourceData.forEach { row ->
                    val values = row.values.map {
                        when (it) {
                            "NULL" -> null
                            else -> it
                        }
                    }.toTypedArray()
                    grindrPlusDb.insert(targetTable, null, values, columns, placeholders)
                }
            }
            grindrPlusDb.close()
            GrindrPlus.showToast(Toast.LENGTH_LONG,
                "✓ Table '$sourceTable' copied to '$targetTable' (${
                    sourceData.size} rows)")
        } catch (e: Exception) {
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Error copying table: ${e.message}")
        }
    }
    // Helper function to get GrindrPlus database
    private fun getGrindrPlusDatabase(): SQLiteDatabase {
        val context = GrindrPlus.context
        return context.openOrCreateDatabase("Grindrplus.db", Context.MODE_PRIVATE, null)
    }
    // Helper extension function for easier insertion
    private fun SQLiteDatabase.insert(table: String, conflictAlgorithm: Int?, values: Array<Any?>,
                                      columns: String, placeholders: String): Long {
        val sql = "INSERT INTO $table ($columns) VALUES ($placeholders)"
        return if (conflictAlgorithm != null) {
            this.compileStatement(sql).apply {
                values.forEachIndexed { index, value ->
                    when (value) {
                        null -> bindNull(index + 1)
                        is Int -> bindLong(index + 1, value.toLong())
                        is Long -> bindLong(index + 1, value)
                        is Float -> bindDouble(index + 1, value.toDouble())
                        is Double -> bindDouble(index + 1, value)
                        is Boolean -> bindLong(index + 1, if (value) 1 else 0)
                        else -> bindString(index + 1, value.toString())
                    }
                }
            }.executeInsert()
        } else {
            this.execSQL(sql, values)
            -1 // Return -1 since we can't get rowId with execSQL
        }
    }
    @Command("list_databases", aliases = ["ldbs"], help = "List all database files in the app's files directory")
    fun listDatabases(args: List<String>) {
        try {
            val context = GrindrPlus.context
            val databases = context.databaseList()
            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                val dialogView = LinearLayout(activity).apply {
                    orientation = LinearLayout.VERTICAL
                    setPadding(60, 40, 60, 40)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                }
                val dbList = if (databases.isEmpty()) "No databases found." else databases.joinToString("\n")
                val textView = AppCompatTextView(activity).apply {
                    text = dbList
                    textSize = 14f
                    setTextColor(Color.WHITE)
                    setPadding(20, 20, 20, 20)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    ).apply {
                        setMargins(0, 20, 0, 0)
                    }
                }
                dialogView.addView(textView)
                AlertDialog.Builder(activity)
                    .setTitle("Database Files")
                    .setView(dialogView)
                    .setPositiveButton("Close") { dialog, _ ->
                        dialog.dismiss()
                    }
                    .setNegativeButton("Copy") { _, _ ->
                        copyToClipboard("Database Files", dbList)
                    }
                    .create()
                    .show()
            }
        } catch (e: Exception) {
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Error: ${e.message}")
        }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\commands\Location.kt --- 
package com.grindrplus.commands
class Location(recipient: String, sender: String) : CommandModule("Location", recipient, sender) {
    private val coroutineScope = CoroutineScope(Dispatchers.Main)
    @Command(name = "tp", aliases = ["tp"], help = "Teleport to a location")
    fun teleport(args: List<String>) {
        /**
         * If the user is currently used forced coordinates, don't allow teleportation.
         */
        if (Config.get("forced_coordinates", "") as String != "") {
            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                AlertDialog.Builder(activity)
                    .setTitle("Teleportation disabled")
                    .setMessage(
                        "GrindrPlus is currently using forced coordinates. " +
                                "Please disable it to use teleportation."
                    )
                    .setPositiveButton("OK", null)
                    .setNegativeButton("Disable") { _, _ ->
                        Config.put("forced_coordinates", "")
                        GrindrPlus.bridgeClient.deleteForcedLocation(packageName)
                        GrindrPlus.showToast(
                            Toast.LENGTH_LONG,
                            "Forced coordinates disabled"
                        )
                    }
                    .show()
            }
            return;
        }
        /**
         * This command is also used to toggle the teleportation feature. If the user hasn't
         * provided any arguments, just toggle teleport.
         */
        if (args.isEmpty()) {
            val status = (Config.get("current_location", "") as String).isEmpty()
            if (!status) {
                Config.put("current_location", "")
                return GrindrPlus.showToast(Toast.LENGTH_LONG, "Teleportation disabled")
            }
            return GrindrPlus.showToast(Toast.LENGTH_LONG, "Please provide a location")
        }
        /**
         * If the user has provided arguments, try to teleport to the location. We currently support
         * different formats for the location:
         * - "lat, lon" (e.g. "37.7749, -122.4194") for latitude and longitude.
         * - "lat" "lon" (e.g. "37.7749" "-122.4194") for latitude and longitude.
         * - "lat lon" (e.g. "37.7749 -122.4194") for latitude and longitude.
         * - "city, country" (e.g. "San Francisco, United States") for city and country.
         */
        when {
            args.size == 1 && args[0] == "off" -> {
                Config.put("current_location", "")
                return GrindrPlus.showToast(Toast.LENGTH_LONG, "Teleportation disabled")
            }
            args.size == 1 && args[0].contains(",") -> {
                val (lat, lon) = args[0].split(",").map { it.toDouble() }
                teleportToCoordinates(lat, lon)
            }
            args.size == 2 && args.all { arg -> arg.toDoubleOrNull() != null } -> {
                val (lat, lon) = args.map { it.toDouble() }
                teleportToCoordinates(lat, lon)
            }
            else -> {
                /**
                 * If we reached this point, the user has provided a name of a city. In this case,
                 * it could be either a saved location or an actual city.
                 */
                coroutineScope.launch {
                    val location = getLocation(args.joinToString(" "))
                    if (location != null) {
                        teleportToCoordinates(location.first, location.second)
                    } else {
                        /**
                         * No valid saved location was found, try to get the actual location. This
                         * is done by using Nominatim's API to get the latitude and longitude.
                         */
                        val apiLocation = getLocationFromNominatimAsync(args.joinToString(" "))
                        if (apiLocation != null) {
                            teleportToCoordinates(apiLocation.first, apiLocation.second)
                        } else {
                            GrindrPlus.showToast(Toast.LENGTH_LONG, "Location not found")
                        }
                    }
                }
                return
            }
        }
    }
    @Command(name = "save", aliases = ["sv"], help = "Save the current location")
    fun save(args: List<String>) {
        if (args.isEmpty()) {
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Please provide a name for the location")
            return
        }
        val name = args[0]
        coroutineScope.launch {
            val location =
                when {
                    args.size == 1 -> Config.get("current_location", "") as String
                    args.size == 2 && args[1].contains(",") -> args[1]
                    args.size == 3 &&
                            args[1].toDoubleOrNull() != null &&
                            args[2].toDoubleOrNull() != null -> "${args[1]},${args[2]}"
                    args.size > 1 ->
                        getLocationFromNominatimAsync(args.drop(1).joinToString(" "))?.let {
                            "${it.first},${it.second}"
                        }
                    else -> ""
                }
            if (!location.isNullOrEmpty()) {
                val coordinates = location.split(",")
                if (coordinates.size == 2) {
                    try {
                        val lat = coordinates[0].toDouble()
                        val lon = coordinates[1].toDouble()
                        val existingLocation = getLocation(name)
                        if (existingLocation != null) {
                            updateLocation(name, lat, lon)
                            GrindrPlus.showToast(Toast.LENGTH_LONG, "Successfully updated $name")
                        } else {
                            addLocation(name, lat, lon)
                            GrindrPlus.showToast(Toast.LENGTH_LONG, "Successfully saved $name")
                        }
                    } catch (e: Exception) {
                        GrindrPlus.showToast(Toast.LENGTH_LONG, "Invalid coordinates format")
                    }
                } else {
                    GrindrPlus.showToast(Toast.LENGTH_LONG, "Invalid coordinates format")
                }
            } else {
                GrindrPlus.showToast(Toast.LENGTH_LONG, "No location provided")
            }
        }
    }
    @Command(name = "delete", aliases = ["del"], help = "Delete a saved location")
    fun delete(args: List<String>) {
        if (args.isEmpty()) {
            return GrindrPlus.showToast(Toast.LENGTH_LONG, "Please provide a location to delete")
        }
        val name = args.joinToString(" ")
        coroutineScope.launch {
            val location = getLocation(name)
            if (location == null) {
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Location not found")
                return@launch
            }
            deleteLocation(name)
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Location deleted")
        }
    }
    private suspend fun getLocation(name: String): Pair<Double, Double>? =
        withContext(Dispatchers.IO) {
            val locationDao = GrindrPlus.database.teleportLocationDao()
            val entity = locationDao.getLocation(name)
            return@withContext entity?.let { Pair(it.latitude, it.longitude) }
        }
    private suspend fun addLocation(name: String, latitude: Double, longitude: Double) =
        withContext(Dispatchers.IO) {
            val locationDao = GrindrPlus.database.teleportLocationDao()
            val entity =
                com.grindrplus.persistence.model.TeleportLocationEntity(
                    name = name,
                    latitude = latitude,
                    longitude = longitude
                )
            locationDao.upsertLocation(entity)
        }
    private suspend fun updateLocation(name: String, latitude: Double, longitude: Double) =
        withContext(Dispatchers.IO) {
            val locationDao = GrindrPlus.database.teleportLocationDao()
            val entity =
                com.grindrplus.persistence.model.TeleportLocationEntity(
                    name = name,
                    latitude = latitude,
                    longitude = longitude
                )
            locationDao.upsertLocation(entity)
        }
    private suspend fun deleteLocation(name: String) =
        withContext(Dispatchers.IO) {
            val locationDao = GrindrPlus.database.teleportLocationDao()
            locationDao.deleteLocation(name)
        }
    private suspend fun getLocationFromNominatimAsync(location: String): Pair<Double, Double>? =
        withContext(Dispatchers.IO) {
            val url =
                "https://nominatim.openstreetmap.org/search?q=${Uri.encode(location)}&format=json"
            val randomUserAgent = getUserAgent()
            val request =
                okhttp3.Request.Builder().url(url).header("User-Agent", randomUserAgent).build()
            return@withContext try {
                OkHttpClient().newCall(request).execute().use { response ->
                    val body = response.body?.string()
                    if (body.isNullOrEmpty()) return@withContext null
                    val json = JSONArray(body)
                    if (json.length() == 0) return@withContext null
                    val obj = json.getJSONObject(0)
                    val lat = obj.getDouble("lat")
                    val lon = obj.getDouble("lon")
                    Pair(lat, lon)
                }
            } catch (e: Exception) {
                val message =
                    "An error occurred while getting the location: ${e.message ?: "Unknown error"}"
                withContext(Dispatchers.Main) { GrindrPlus.showToast(Toast.LENGTH_LONG, message) }
                Logger.apply {
                    e(message)
                    writeRaw(e.stackTraceToString())
                }
                null
            }
        }
    private fun teleportToCoordinates(lat: Double, lon: Double, silent: Boolean = false) {
        Config.put("current_location", "$lat,$lon")
        val geohash = coordsToGeoHash(lat, lon)
        GrindrPlus.executeAsync {
            try {
                GrindrPlus.httpClient.updateLocation(geohash)
            } catch (e: Exception) {
                Logger.e("Error sending geohash to API: ${e.message}")
            }
        }
        if (!silent)
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Teleported to $lat, $lon")
    }
    private fun getUserAgent(): String {
        val chromeVersions = listOf("120.0.0.0", "119.0.0.0", "118.0.0.0", "117.0.0.0", "116.0.0.0")
        val firefoxVersions = listOf("121.0", "120.0", "119.0", "118.0", "117.0")
        val safariVersions = listOf("17.2", "17.1", "17.0", "16.6", "16.5")
        val edgeVersions = listOf("120.0.0.0", "119.0.0.0", "118.0.0.0", "117.0.0.0")
        val windowsVersions = listOf("10.0", "11.0")
        val macVersions = listOf("10_15_7", "11_7_10", "12_7_2", "13_6_3", "14_2_1")
        return when ((1..5).random()) {
            1 -> {
                val version = chromeVersions.random()
                val winVer = windowsVersions.random()
                "Mozilla/5.0 (Windows NT $winVer; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/$version Safari/537.36"
            }
            2 -> {
                val version = chromeVersions.random()
                val macVer = macVersions.random()
                "Mozilla/5.0 (Macintosh; Intel Mac OS X $macVer) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/$version Safari/537.36"
            }
            3 -> {
                val version = firefoxVersions.random()
                val platform = if ((1..2).random() == 1) {
                    "Windows NT ${windowsVersions.random()}; Win64; x64"
                } else {
                    "Macintosh; Intel Mac OS X ${macVersions.random().replace("_", ".")}"
                }
                "Mozilla/5.0 ($platform; rv:$version) Gecko/20100101 Firefox/$version"
            }
            4 -> {
                val safariVer = safariVersions.random()
                val macVer = macVersions.random()
                val webkitVer = "605.1.${(10..20).random()}"
                "Mozilla/5.0 (Macintosh; Intel Mac OS X $macVer) AppleWebKit/$webkitVer (KHTML, like Gecko) Version/$safariVer Safari/$webkitVer"
            }
            5 -> {
                val version = edgeVersions.random()
                val winVer = windowsVersions.random()
                "Mozilla/5.0 (Windows NT $winVer; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/$version Safari/537.36 Edg/$version"
            }
            else -> chromeVersions.random()
        }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\commands\Profile.kt --- 
package com.grindrplus.commands
class Profile(
    recipient: String,
    sender: String
) : CommandModule("Profile", recipient, sender) {
    @Command("open", help = "Open a user's profile")
    fun open(args: List<String>) {
        if (args.isNotEmpty()) {
            return openProfile(args[0])
        } else {
            GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "Please provide valid ID"
            )
        }
    }
    @Command("block", help = "Block a user")
    fun block(args: List<String>) {
        GrindrPlus.httpClient.blockUser(
            if (args.isNotEmpty()) args[0] else sender,
            silent = args.contains("silent"),
            reflectInDb = !args.contains("no-reflect")
        )
    }
    @Command("clear", aliases = ["reset"], help = "Reset chat with a user")
    fun reset(args: List<String>) {
        val profileId = if (args.isNotEmpty()) args[0] else sender
        GrindrPlus.shouldTriggerAntiblock = false
        block(listOf(profileId, "silent", "no-reflect"))
        Thread.sleep(200)
        unblock(listOf(profileId, "silent", "no-reflect"))
        Thread.sleep(200)
        openChat("$recipient:$profileId")
        Thread.sleep(200)
        GrindrPlus.shouldTriggerAntiblock = true
    }
    @Command("unblock", help = "Unblock a user")
    fun unblock(args: List<String>) {
        GrindrPlus.httpClient.unblockUser(
            if (args.isNotEmpty()) args[0] else sender,
            silent = args.contains("silent"),
            reflectInDb = !args.contains("no-reflect")
        )
    }
    @Command("chat", help = "Open chat with a user")
    fun chat(args: List<String>) {
        if (args.isNotEmpty()) {
            return openChat("$recipient:${args[0]}")
        } else {
            GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "Please provide valid ID"
            )
        }
    }
    @Command("favorite", aliases = ["fav", "favourite"], help = "Favorite a user")
    fun favorite(args: List<String>) {
        val profileId = if (args.isNotEmpty()) args[0] else sender
        GrindrPlus.httpClient.favorite(profileId, silent = false)
    }
    @Command("unfavorite", aliases = ["unfav", "unfavourite"], help = "Unfavorite a user")
    fun unfavorite(args: List<String>) {
        if (args.isNotEmpty() && args[0] == "all") {
            GrindrPlus.executeAsync {
                val favorites = GrindrPlus.httpClient.getFavorites()
                Thread.sleep(1000)
                favorites.forEach { GrindrPlus.httpClient.unfavorite(it.first, silent = true) }
            }
        }
        val profileId = if (args.isNotEmpty()) args[0] else sender
        GrindrPlus.httpClient.unfavorite(profileId, silent = false)
    }
    @Command("blocks", help = "Get a list of blocked users")
    fun blocks(args: List<String>) {
        GrindrPlus.executeAsync {
            val blocks = GrindrPlus.httpClient.getBlocks()
            val blockList = blocks.joinToString("\n") { "• $it" }
            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                val dialogView = LinearLayout(activity).apply {
                    orientation = LinearLayout.VERTICAL
                    setPadding(60, 40, 60, 40)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                }
                val textView = AppCompatTextView(activity).apply {
                    text = blockList
                    textSize = 14f
                    setTextColor(Color.WHITE)
                    setPadding(20, 20, 20, 20)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    ).apply {
                        setMargins(0, 20, 0, 0)
                    }
                }
                dialogView.addView(textView)
                AlertDialog.Builder(activity)
                    .setTitle("Blocked users")
                    .setView(dialogView)
                    .setPositiveButton("Copy") { _, _ ->
                        copyToClipboard("Blocked users", blocks.joinToString("\n") { it })
                    }
                    .setNegativeButton("Close") { dialog, _ ->
                        dialog.dismiss()
                    }
                    .setNeutralButton("Export") { _, _ ->
                        val file = GrindrPlus.context.getFileStreamPath("blocks.txt")
                        file.writeText(blocks.joinToString("\n") { it })
                        GrindrPlus.showToast(
                            Toast.LENGTH_LONG,
                            "Exported blocked users. Use Mod Settings to access the file!"
                        )
                    }
                    .create()
                    .show()
            }
        }
    }
    @Command("favorites", aliases = ["favourites", "favs"], help = "Get a list of favorited users")
    fun favorites(args: List<String>) {
        GrindrPlus.executeAsync {
            val favorites = GrindrPlus.httpClient.getFavorites()
            val favoriteList = favorites.joinToString("\n") { "• ${it.first}" }
            val favoriteListExport = favorites.joinToString("\n") {
                val sanitizedNote = it.second.replace("\r\n", NEWLINE).replace("\r", NEWLINE).replace("\n", NEWLINE)
                val sanitizedPhone = it.third.replace("\r\n", NEWLINE).replace("\r", NEWLINE).replace("\n", NEWLINE)
                "${it.first}|||$sanitizedNote|||$sanitizedPhone"
            }
            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                val dialogView = LinearLayout(activity).apply {
                    orientation = LinearLayout.VERTICAL
                    setPadding(60, 40, 60, 40)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                }
                val textView = AppCompatTextView(activity).apply {
                    text = favoriteList
                    textSize = 14f
                    setTextColor(Color.WHITE)
                    setPadding(20, 20, 20, 20)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    ).apply {
                        setMargins(0, 20, 0, 0)
                    }
                }
                dialogView.addView(textView)
                AlertDialog.Builder(activity)
                    .setTitle("Favorited users")
                    .setView(dialogView)
                    .setPositiveButton("Copy") { _, _ ->
                        copyToClipboard("Favorited users", favoriteList)
                    }
                    .setNegativeButton("Close") { dialog, _ ->
                        dialog.dismiss()
                    }
                    .setNeutralButton("Export") { _, _ ->
                        val file = GrindrPlus.context.getFileStreamPath("favorites.txt")
                        file.writeText(favoriteListExport)
                        GrindrPlus.showToast(
                            Toast.LENGTH_LONG,
                            "Exported favorited users. Use Mod Settings to access the file!"
                        )
                    }
                    .create()
                    .show()
            }
        }
    }
    @Command("report", help = "Report a user")
    fun report(args: List<String>) {
        val profileId = if (args.isNotEmpty()) args[0] else sender
        val reason = if (args.size > 1) args[1] else "SPAM"
        GrindrPlus.httpClient.reportUser(profileId, reason)
    }
    @SuppressLint("SetTextI18n")
    @Command("id", help = "Get and copy profile IDs")
    fun id(args: List<String>) {
        val accountCreationTime = formatEpochSeconds(
            GrindrPlus.spline.invert(sender.toDouble()).toLong())
        GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
            val dialogView = LinearLayout(activity).apply {
                orientation = LinearLayout.VERTICAL
                setPadding(60, 0, 60, 0)
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                )
            }
            val textView = activity.let {
                AppCompatTextView(it).apply {
                    text = "• Your ID: $recipient\n• Profile ID: $sender\n• Estimated creation: $accountCreationTime"
                    textSize = 18f
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                }
            }
            dialogView.addView(textView)
            AlertDialog.Builder(activity)
                .setTitle("Profile IDs")
                .setView(dialogView)
                .setPositiveButton("Copy my ID") { _, _ ->
                    copyToClipboard("Your ID", recipient)
                }
                .setNegativeButton("Copy profile ID") { _, _ ->
                    copyToClipboard("Profile ID", sender)
                }
                .setNeutralButton("Close") { dialog, _ ->
                    dialog.dismiss()
                }
                .create()
                .also { alertDialog ->
                    alertDialog.show()
                    alertDialog.getButton(AlertDialog.BUTTON_POSITIVE).setOnLongClickListener {
                        copyToClipboard("Your ID", " $recipient")
                        alertDialog.dismiss()
                        true
                    }
                    alertDialog.getButton(AlertDialog.BUTTON_NEGATIVE).setOnLongClickListener {
                        copyToClipboard("Profile ID", " $sender")
                        alertDialog.dismiss()
                        true
                    }
                }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\commands\Utils.kt --- 
package com.grindrplus.commands
class Utils(
    recipient: String,
    sender: String
) : CommandModule("Utils", recipient, sender) {
    @Command("shell", help = "Run a shell command and display output")
    fun shell(args: List<String>) {
        if (args.isEmpty()) {
            GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "Please provide a shell command to execute"
            )
            return
        }
        val command = args.joinToString(" ")
        val output = StringBuilder()
        try {
            val process = Runtime.getRuntime().exec(command)
            val reader = BufferedReader(InputStreamReader(process.inputStream))
            var line: String? = reader.readLine()
            while (line != null) {
                output.append(line).append("\n")
                line = reader.readLine()
            }
            reader.close()
            process.waitFor()
        } catch (e: Exception) {
            output.append("Error executing command: ${e.message}")
        }
        GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
            val dialogView = LinearLayout(activity).apply {
                orientation = LinearLayout.VERTICAL
                setPadding(60, 40, 60, 40)
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                )
            }
            val textView = AppCompatTextView(activity).apply {
                text = output.toString()
                textSize = 14f
                setTextColor(Color.WHITE)
                setPadding(20, 20, 20, 20)
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                ).apply {
                    setMargins(0, 20, 0, 0)
                }
            }
            dialogView.addView(textView)
            AlertDialog.Builder(activity)
                .setTitle("Output")
                .setView(dialogView)
                .setPositiveButton("Close") { dialog, _ ->
                    dialog.dismiss()
                }
                .create()
                .show()
        }
    }
    @Command("prefix", help = "Change the command prefix (default: /)")
    fun prefix(args: List<String>) {
        val prefix = Config.get("command_prefix", "/")
        when {
            args.isEmpty() -> GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "The current command prefix is $prefix"
            )
            args[0].isBlank() -> GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "Invalid command prefix"
            )
            args[0] == "reset" || args[0] == "clear" -> {
                Config.put("command_prefix", "/")
                GrindrPlus.showToast(
                    Toast.LENGTH_LONG,
                    "Command prefix reset to /",
                )
            }
            args[0].length > 1 -> GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "Command prefix must be a single character"
            )
            !args[0].matches(Regex("[^a-zA-Z0-9]")) -> GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "Command prefix must be a special character (no letters or numbers)"
            )
            args[0] == prefix -> GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "Command prefix is already set to ${args[0]}"
            )
            else -> {
                Config.put("command_prefix", args[0])
                GrindrPlus.showToast(
                    Toast.LENGTH_LONG,
                    "Command prefix set to ${args[0]}"
                )
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\Config.kt --- 
package com.grindrplus.core
object Config {
    private var localConfig = JSONObject()
    private var currentPackageName = Constants.GRINDR_PACKAGE_NAME
    private val GLOBAL_SETTINGS = listOf("first_launch", "analytics", "discreet_icon", "material_you", "debug_mode", "disable_permission_checks", "custom_manifest", "maps_api_key")
    fun initialize(packageName: String? = null) {
        if (packageName != null) {
            Logger.d("Initializing config for package: $packageName", LogSource.MANAGER)
        }
        localConfig = readRemoteConfig()
        if (packageName != null) {
            currentPackageName = packageName
        }
        migrateToMultiCloneFormat()
    }
    private fun isGlobalSetting(name: String): Boolean {
        return name in GLOBAL_SETTINGS
    }
    private fun migrateToMultiCloneFormat() {
        if (!localConfig.has("clones")) {
            Logger.d("Migrating to multi-clone format", LogSource.MANAGER)
            val cloneSettings = JSONObject()
            if (localConfig.has("hooks")) {
                val defaultPackageConfig = JSONObject()
                defaultPackageConfig.put("hooks", localConfig.get("hooks"))
                cloneSettings.put(Constants.GRINDR_PACKAGE_NAME, defaultPackageConfig)
                val keysToMove = mutableListOf<String>()
                val keys = localConfig.keys()
                while (keys.hasNext()) {
                    val key = keys.next()
                    if (key != "hooks" && !isGlobalSetting(key)) {
                        defaultPackageConfig.put(key, localConfig.get(key))
                        keysToMove.add(key)
                    }
                }
                keysToMove.forEach { localConfig.remove(it) }
            } else {
                cloneSettings.put(Constants.GRINDR_PACKAGE_NAME, JSONObject().put("hooks", JSONObject()))
            }
            localConfig.put("clones", cloneSettings)
            writeRemoteConfig(localConfig)
        }
        ensurePackageExists(currentPackageName)
    }
    fun setCurrentPackage(packageName: String) {
        Logger.d("Setting current package to $packageName", LogSource.MANAGER)
        currentPackageName = packageName
        ensurePackageExists(packageName)
    }
    fun getCurrentPackage(): String {
        return currentPackageName
    }
    private fun ensurePackageExists(packageName: String) {
        Logger.d("Ensuring package $packageName exists in config", LogSource.MANAGER)
        val clones = localConfig.optJSONObject("clones") ?: JSONObject().also {
            localConfig.put("clones", it)
        }
        if (!clones.has(packageName)) {
            clones.put(packageName, JSONObject().put("hooks", JSONObject()))
            writeRemoteConfig(localConfig)
        }
    }
    fun getAvailablePackages(context: Context): List<String> {
        Logger.d("Getting available packages", LogSource.MANAGER)
        val installedClones = listOf(Constants.GRINDR_PACKAGE_NAME) + AppCloneUtils.getExistingClones(context)
        val clones = localConfig.optJSONObject("clones") ?: return listOf(Constants.GRINDR_PACKAGE_NAME)
        return installedClones.filter { pkg ->
            clones.has(pkg)
        }
    }
    fun readRemoteConfig(): JSONObject {
        return try {
            GrindrPlus.bridgeClient.getConfig()
        } catch (e: Exception) {
            Logger.e("Failed to read config file: ${e.message}", LogSource.MANAGER)
            Logger.writeRaw(e.stackTraceToString())
            JSONObject().put("clones", JSONObject().put(
                Constants.GRINDR_PACKAGE_NAME,
                JSONObject().put("hooks", JSONObject()))
            )
        }
    }
    fun writeRemoteConfig(json: JSONObject) {
        try {
            GrindrPlus.bridgeClient.setConfig(json)
        } catch (e: IOException) {
            Logger.e("Failed to write config file: ${e.message}", LogSource.MANAGER)
            Logger.writeRaw(e.stackTraceToString())
        }
    }
    private fun getCurrentPackageConfig(): JSONObject {
        val clones = localConfig.optJSONObject("clones")
            ?: JSONObject().also { localConfig.put("clones", it) }
        return clones.optJSONObject(currentPackageName)
            ?: JSONObject().also { clones.put(currentPackageName, it) }
    }
    fun put(name: String, value: Any) {
        Logger.d("Setting $name to $value", LogSource.MANAGER)
        if (isGlobalSetting(name)) {
            localConfig.put(name, value)
        } else {
            val packageConfig = getCurrentPackageConfig()
            packageConfig.put(name, value)
        }
        writeRemoteConfig(localConfig)
    }
    fun get(name: String, default: Any, autoPut: Boolean = false): Any {
        val rawValue = if (isGlobalSetting(name)) {
            localConfig.opt(name)
        } else {
            val packageConfig = getCurrentPackageConfig()
            packageConfig.opt(name)
        }
        if (rawValue == null) {
            if (autoPut) put(name, default)
            return default
        }
        return when (default) {
            is Number -> {
                if (rawValue is String) {
                    try {
                        rawValue.toInt()
                    } catch (_: NumberFormatException) {
                        try {
                            rawValue.toDouble()
                        } catch (_: NumberFormatException) {
                            default
                        }
                    }
                } else {
                    rawValue as? Number ?: default
                }
            }
            else -> rawValue
        }
    }
    fun setHookEnabled(hookName: String, enabled: Boolean) {
        Logger.d("Setting hook $hookName to $enabled", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val hooks = packageConfig.optJSONObject("hooks")
            ?: JSONObject().also { packageConfig.put("hooks", it) }
        hooks.optJSONObject(hookName)?.put("enabled", enabled)
        writeRemoteConfig(localConfig)
    }
    fun isHookEnabled(hookName: String): Boolean {
        Logger.d("Checking if hook $hookName is enabled", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val hooks = packageConfig.optJSONObject("hooks") ?: return false
        return hooks.optJSONObject(hookName)?.getBoolean("enabled") == true
    }
    fun setTaskEnabled(taskId: String, enabled: Boolean) {
        Logger.d("Setting task $taskId to $enabled", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val tasks = packageConfig.optJSONObject("tasks")
            ?: JSONObject().also { packageConfig.put("tasks", it) }
        tasks.optJSONObject(taskId)?.put("enabled", enabled)
        writeRemoteConfig(localConfig)
    }
    fun isTaskEnabled(taskId: String): Boolean {
        Logger.d("Checking if task $taskId is enabled", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val tasks = packageConfig.optJSONObject("tasks") ?: return false
        return tasks.optJSONObject(taskId)?.getBoolean("enabled") == true
    }
    fun getTasksSettings(): Map<String, Pair<String, Boolean>> {
        Logger.d("Getting tasks settings", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val tasks = packageConfig.optJSONObject("tasks") ?: return emptyMap()
        val map = mutableMapOf<String, Pair<String, Boolean>>()
        val keys = tasks.keys()
        while (keys.hasNext()) {
            val key = keys.next()
            val obj = tasks.getJSONObject(key)
            map[key] = Pair(obj.getString("description"), obj.getBoolean("enabled"))
        }
        return map
    }
    fun initTaskSettings(taskId: String, description: String, state: Boolean) {
        Logger.d("Initializing task settings for $taskId", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val tasks = packageConfig.optJSONObject("tasks")
            ?: JSONObject().also { packageConfig.put("tasks", it) }
        if (tasks.optJSONObject(taskId) == null) {
            tasks.put(taskId, JSONObject().apply {
                put("description", description)
                put("enabled", state)
            })
            writeRemoteConfig(localConfig)
        }
    }
    fun initHookSettings(name: String, description: String, state: Boolean) {
        Logger.d("Initializing hook settings for $name", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val hooks = packageConfig.optJSONObject("hooks")
            ?: JSONObject().also { packageConfig.put("hooks", it) }
        if (hooks.optJSONObject(name) == null) {
            hooks.put(name, JSONObject().apply {
                put("description", description)
                put("enabled", state)
            })
            writeRemoteConfig(localConfig)
        }
    }
    fun getHooksSettings(): Map<String, Pair<String, Boolean>> {
        Logger.d("Getting hooks settings", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val hooks = packageConfig.optJSONObject("hooks") ?: return emptyMap()
        val map = mutableMapOf<String, Pair<String, Boolean>>()
        val keys = hooks.keys()
        while (keys.hasNext()) {
            val key = keys.next()
            val obj = hooks.getJSONObject(key)
            map[key] = Pair(obj.getString("description"), obj.getBoolean("enabled"))
        }
        return map
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\Constants.kt --- 
package com.grindrplus.core
object Constants {
    const val NEWLINE = "GRINDRPLUS_NEWLINE"
    const val GRINDR_PACKAGE_NAME = "com.grindrapp.android"
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\CoroutineHelper.kt --- 
package com.grindrplus.core
object CoroutineHelper {
    private val BuildersKt = XposedHelpers.findClass(
        "kotlinx.coroutines.BuildersKt",
        GrindrPlus.classLoader
    )
    private val Function2 = XposedHelpers.findClass(
        "kotlin.jvm.functions.Function2",
        GrindrPlus.classLoader
    )
    private val EmptyCoroutineContextInstance = let {
        val emptyCoroutineContext = XposedHelpers.findClass(
            "kotlin.coroutines.EmptyCoroutineContext",
            GrindrPlus.classLoader
        )
        XposedHelpers.getStaticObjectField(emptyCoroutineContext, "INSTANCE")
    }
    fun callSuspendFunction(function: (continuation: Any) -> Any?): Any {
        val proxy = Proxy.newProxyInstance(
            GrindrPlus.classLoader,
            arrayOf(Function2)
        ) { _, _, args ->
            function(args[1])
        }
        return XposedHelpers.callStaticMethod(
            BuildersKt,
            "runBlocking",
            EmptyCoroutineContextInstance,
            proxy
        )
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\CredentialsLogger.kt --- 
package com.grindrplus.core
object CredentialsLogger {
    private val logFile = File(
        Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),
        "GrindrAccess_Info.txt"
    )
    // Cache the last token to avoid writing duplicate info
    private var lastAuthToken: String? = null
    /**
     * Extracts the profileId from a JWT token.
     */
    private fun getProfileIdFromToken(token: String): String? {
        return try {
            val parts = token.split(".")
            if (parts.size < 2) return null
            val payload = String(Base64.decode(parts[1], Base64.URL_SAFE), Charsets.UTF_8)
            JSONObject(payload).getString("profileId")
        } catch (e: Exception) {
            Logger.e("Could not extract profileId from token: ${e.message}")
            null
        }
    }
    /**
     * Logs the essential credentials to a separate file.
     * Only writes to the file if the auth token has changed.
     */
    fun log(authToken: String?, lDeviceInfo: String?, userAgent: String?) {
        // We only care about requests that are authenticated
        if (authToken.isNullOrEmpty() || !authToken.startsWith("Grindr3 ")) return
        val cleanAuthToken = authToken.substringAfter("Grindr3 ")
        // If the token is the same as the last one we logged, do nothing.
        if (cleanAuthToken == lastAuthToken) return
        try {
            val profileId = getProfileIdFromToken(cleanAuthToken)
            val logMessage = buildString {
                append("### Latest Grindr Credentials ###\n\n")
                append("# This file is automatically updated when your session token changes.\n")
                append("# Use these values in your grindr-access scripts.\n\n")
                append("profileId: $profileId\n\n")
                append("authToken: $cleanAuthToken\n\n")
                append("l-device-info: $lDeviceInfo\n\n")
                append("user-agent: $userAgent\n")
            }
            // Overwrite the file with the latest credentials
            logFile.writeText(logMessage)
            // Update the cache
            lastAuthToken = cleanAuthToken
        } catch (e: Exception) {
            Logger.e("Failed to write to credentials log file: ${e.message}")
        }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\DatabaseHelper.kt --- 
package com.grindrplus.core
object DatabaseHelper {
    private fun getDatabase(): SQLiteDatabase {
        val context = GrindrPlus.context
        val databases = context.databaseList()
        val grindrUserDb = databases.firstOrNull {
            it.contains("grindr_user") && it.endsWith(".db") }
            ?: throw IllegalStateException("No Grindr user database found!").also {
                Logger.apply {
                    e(it.message!!)
                    writeRaw("Available databases:\n" +
                            "${databases.joinToString("\n") { "  $it" }}\n")
                }
            }
        return context.openOrCreateDatabase(grindrUserDb.also {
            Logger.d("Using database: $it") }, Context.MODE_PRIVATE, null)
    }
    fun query(query: String, args: Array<String>? = null): List<Map<String, Any>> {
        val database = getDatabase()
        val cursor = database.rawQuery(query, args)
        val results = mutableListOf<Map<String, Any>>()
        try {
            if (cursor.moveToFirst()) {
                do {
                    val row = mutableMapOf<String, Any>()
                    cursor.columnNames.forEach { column ->
                        row[column] = when (cursor.getType(cursor.getColumnIndexOrThrow(column))) {
                            Cursor.FIELD_TYPE_INTEGER -> cursor.getInt(cursor.getColumnIndexOrThrow(column))
                            Cursor.FIELD_TYPE_FLOAT -> cursor.getFloat(cursor.getColumnIndexOrThrow(column))
                            Cursor.FIELD_TYPE_STRING -> cursor.getString(cursor.getColumnIndexOrThrow(column))
                            Cursor.FIELD_TYPE_BLOB -> cursor.getBlob(cursor.getColumnIndexOrThrow(column))
                            Cursor.FIELD_TYPE_NULL -> "NULL"
                            else -> "UNKNOWN"
                        }
                    }
                    results.add(row)
                } while (cursor.moveToNext())
            }
        } finally {
            cursor.close()
            database.close()
        }
        return results
    }
    fun insert(table: String, values: ContentValues): Long {
        val database = getDatabase()
        val rowId = database.insert(table, null, values)
        database.close()
        return rowId
    }
    fun update(table: String, values: ContentValues, whereClause: String?, whereArgs: Array<String>?): Int {
        val database = getDatabase()
        val rowsAffected = database.update(table, values, whereClause, whereArgs)
        database.close()
        return rowsAffected
    }
    fun delete(table: String, whereClause: String?, whereArgs: Array<String>?): Int {
        val database = getDatabase()
        val rowsDeleted = database.delete(table, whereClause, whereArgs)
        database.close()
        return rowsDeleted
    }
    fun execute(sql: String) {
        val database = getDatabase()
        database.execSQL(sql)
        database.close()
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\EventManager.kt --- 
package com.grindrplus.core
data class ServerNotificationReceived(
    val typeValue: String,
    val notificationId: String?,
    val payload: JSONObject?,
    val status: Int?,
    val refValue: String?
)
object EventManager {
    private val eventScope = CoroutineScope(Dispatchers.IO)
    private val _serverNotifications = MutableSharedFlow<ServerNotificationReceived>(
        replay = 0,
        extraBufferCapacity = 100
    )
    val serverNotifications: SharedFlow<ServerNotificationReceived> = _serverNotifications.asSharedFlow()
    fun emitServerNotification(
        typeValue: String,
        notificationId: String?,
        payload: JSONObject?,
        status: Int?,
        refValue: String?
    ) {
        eventScope.launch {
            try {
                val notification = ServerNotificationReceived(
                    typeValue, notificationId, payload, status, refValue
                )
                _serverNotifications.emit(notification)
                Logger.d("Server notification event emitted: $typeValue", LogSource.MODULE)
            } catch (e: Exception) {
                Logger.e("Failed to emit server notification event: ${e.message}", LogSource.MODULE)
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\HttpBodyLogger.kt --- 
package com.grindrplus.core
object HttpBodyLogger {
    private val dbFile = File(
        Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),
        "HttpBodyLogs.db"
    )
    private fun getDatabase(): SQLiteDatabase {
        return SQLiteDatabase.openOrCreateDatabase(dbFile, null)
    }
    // Public entry point with optional delay
    fun initialize(delayMs: Long = 0L) {
        if (delayMs > 0) {
            Logger.d("Scheduling HttpBodyLogger.initialize() after ${delayMs}ms", LogSource.HTTP)
            Handler(Looper.getMainLooper()).postDelayed({
                initializeInternal()
            }, delayMs)
        } else {
            initializeInternal()
        }
    }
    // Actual setup logic
    private fun initializeInternal() {
        val db = getDatabase()
        try {
            db.execSQL(
                """
                CREATE TABLE IF NOT EXISTS logs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp INTEGER NOT NULL,
                    url TEXT NOT NULL,
                    method TEXT NOT NULL,
                    response_body TEXT
                )
                """.trimIndent()
            )
        } finally {
            db.close()
        }
    }
    fun log(url: String, method: String, body: String?) {
        if (body.isNullOrEmpty() || !body.trim().startsWith("{")) {
            return // Don't log non-JSON or empty bodies
        }
        val db = getDatabase()
        try {
            val values = ContentValues().apply {
                put("timestamp", System.currentTimeMillis() / 1000)
                put("url", url)
                put("method", method)
                put("response_body", body)
            }
            db.insert("logs", null, values)
        } catch (e: Exception) {
            Logger.e("Failed to write to HTTP body log database: ${e.message}")
        } finally {
            db.close()
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\HttpLogger.kt --- 
package com.grindrplus.core
object HttpLogger {
    private val logFile = File(
        Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),
        "GrindrPlus_HttpLogs.txt"
    )
    private fun formatHeaders(headers: okhttp3.Headers): String {
        return headers.toMultimap().entries.joinToString("\n") { (key, values) ->
            "     $key: ${values.joinToString(", ")}"
        }
    }
    fun log(request: Request, response: Response) {
        try {
            val timestamp = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(Date())
            val logMessage = buildString {
                append("[$timestamp]\n")
                append("--- REQUEST -->\n")
                append("  ${request.method} ${request.url}\n")
                append("  Headers:\n")
                append(formatHeaders(request.headers))
                append("\n\n")
                append("<-- RESPONSE ---\n")
                append("  ${response.code} ${response.message}\n")
                append("  Headers:\n")
                append(formatHeaders(response.headers))
                append("\n----------------------------------------\n\n")
            }
            logFile.appendText(logMessage)
        } catch (e: Exception) {
            Logger.e("Failed to write to HTTP log file: ${e.message}")
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\InstanceManager.kt --- 
package com.grindrplus.core
class InstanceManager(private val classLoader: ClassLoader) {
    private val instances = mutableMapOf<String, Any>()
    private val callbacks = mutableMapOf<String, ((Any) -> Unit)?>()
    fun hookClassConstructors(vararg classNames: String) {
        classNames.forEach { className ->
            val clazz = findClass(className, classLoader)
            clazz.hookConstructor(HookStage.AFTER) { param ->
                val instance = param.thisObject()
                instances[className] = instance
                callbacks[className]?.invoke(instance)
            }
        }
    }
    @Suppress("UNCHECKED_CAST")
    fun <T : Any> getInstance(className: String): T? {
        return instances[className] as? T
    }
    fun setCallback(className: String, callback: ((Any) -> Unit)?) {
        callbacks[className] = callback
        instances[className]?.let { callback?.invoke(it) }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\Logger.kt --- 
package com.grindrplus.core
enum class LogLevel { DEBUG, INFO, WARNING, ERROR, SUCCESS }
enum class LogSource { MODULE, MANAGER, HOOK, TASK, BRIDGE, UNKNOWN, HTTP }
@SuppressLint("StaticFieldLeak", "ConstantLocale")
object Logger {
    private const val TAG = "GrindrPlus"
    private const val HTTP_LOG_FILE = "http_logs.txt"
    private var isModuleContext = false
    private var bridgeClient: BridgeClient? = null
    private val hookPrefixes = ConcurrentHashMap<String, String>()
    private val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
    private var httpLogFile: File? = null
    fun initialize(context: Context, bridge: BridgeClient, isModule: Boolean) {
        bridgeClient = bridge
        isModuleContext = isModule
        if (Timber.forest().isEmpty()) {
            Timber.plant(Timber.DebugTree())
        }
        try {
            val logDir = context.getExternalFilesDir(null)
            if (logDir != null) {
                httpLogFile = File(logDir, HTTP_LOG_FILE)
                if (!httpLogFile!!.exists()) {
                    httpLogFile!!.createNewFile()
                }
            }
        } catch (e: IOException) {
            Timber.tag(TAG).e("Failed to initialize HTTP log file: ${e.message}")
        }
    }
    fun registerHookPrefix(subName: String, prefix: String = subName) {
        hookPrefixes[subName] = prefix
    }
    fun unregisterHookPrefix(subName: String) {
        hookPrefixes.remove(subName)
    }
    fun d(message: String, source: LogSource? = null, subName: String? = null) {
        if (!debugEnabled) return
        log(message, LogLevel.DEBUG, source ?: getDefaultSource(), subName)
    }
    fun i(message: String, source: LogSource? = null, subName: String? = null) =
        log(message, LogLevel.INFO, source ?: getDefaultSource(), subName)
    fun w(message: String, source: LogSource? = null, subName: String? = null) =
        log(message, LogLevel.WARNING, source ?: getDefaultSource(), subName)
    fun e(message: String, source: LogSource? = null, subName: String? = null) =
        log(message, LogLevel.ERROR, source ?: getDefaultSource(), subName)
    fun s(message: String, source: LogSource? = null, subName: String? = null) =
        log(message, LogLevel.SUCCESS, source ?: getDefaultSource(), subName)
    fun log(
        message: String,
        level: LogLevel = LogLevel.INFO,
        source: LogSource = LogSource.UNKNOWN,
        subName: String? = null
    ) {
        val priorityChar = when(level) {
            LogLevel.DEBUG -> "V"
            LogLevel.INFO -> "I"
            LogLevel.WARNING -> "W"
            LogLevel.ERROR -> "E"
            LogLevel.SUCCESS -> "S"
        }
        val timestamp = dateFormat.format(Date())
        val sourceName = source.toString().lowercase()
        val conciseMessage = if (subName != null) {
            "$priorityChar/$timestamp/$sourceName/$subName: $message"
        } else {
            "$priorityChar/$timestamp/$sourceName: $message"
        }
        if (source == LogSource.HTTP) {
            writeToHttpLogFile(conciseMessage)
        }
        val logcatMessage = buildLogcatMessage(source, subName, message, level == LogLevel.SUCCESS)
        when (level) {
            LogLevel.DEBUG -> Timber.tag(TAG).v(logcatMessage)
            LogLevel.INFO -> Timber.tag(TAG).i(logcatMessage)
            LogLevel.WARNING -> Timber.tag(TAG).w(logcatMessage)
            LogLevel.ERROR -> Timber.tag(TAG).e(logcatMessage)
            LogLevel.SUCCESS -> Timber.tag(TAG).i(logcatMessage)
        }
        bridgeClient?.let { bridge ->
            try {
                bridge.getService()?.writeRawLog(conciseMessage)
            } catch (e: Exception) {
                Timber.tag(TAG).e("Failed to send log to bridge service: ${e.message}")
            }
        }
    }
    private fun writeToHttpLogFile(logMessage: String) {
        httpLogFile?.let {
            try {
                FileWriter(it, true).use { writer ->
                    writer.append(logMessage)
                    writer.append("\n")
                }
            } catch (e: IOException) {
                Timber.tag(TAG).e("Failed to write to HTTP log file: ${e.message}")
            }
        }
    }
    private fun buildLogcatMessage(source: LogSource, subName: String?, message: String, isSuccess: Boolean): String {
        val sourceStr = source.toString().lowercase().replaceFirstChar { it.uppercase() }
        val prefix = when {
            subName != null -> "$sourceStr: ${hookPrefixes[subName] ?: subName}"
            else -> sourceStr
        }
        return "$prefix: $message"
    }
    fun writeRaw(content: String) {
        bridgeClient?.let { bridge ->
            try {
                bridge.getService()?.writeRawLog(content)
            } catch (e: Exception) {
                Timber.tag(TAG).e("Failed to write raw log to bridge service: ${e.message}")
            }
        }
    }
    fun clearLogs() {
        bridgeClient?.let { bridge ->
            try {
                bridge.getService()?.clearLogs()
            } catch (e: Exception) {
                Timber.tag(TAG).e("Failed to clear logs in bridge service: ${e.message}")
            }
        }
    }
    private fun getDefaultSource(): LogSource =
        if (isModuleContext) LogSource.MODULE else LogSource.MANAGER
    private val debugEnabled: Boolean
        get() = when (val value = Config.get("debug_mode", false)) {
            is Boolean -> value // We account for both strings and booleans
            is String -> value.equals("true", ignoreCase = true)
            else -> false
        } || BuildConfig.DEBUG // Always true in debug builds
}
fun Hook.logd(message: String) = Logger.d(message, LogSource.HOOK, this.hookName)
fun Hook.logi(message: String) = Logger.i(message, LogSource.HOOK, this.hookName)
fun Hook.logw(message: String) = Logger.w(message, LogSource.HOOK, this.hookName)
fun Hook.loge(message: String) = Logger.e(message, LogSource.HOOK, this.hookName)
fun Hook.logs(message: String) = Logger.s(message, LogSource.HOOK, this.hookName)
fun Task.logd(message: String) = Logger.d(message, LogSource.TASK, this.id)
fun Task.logi(message: String) = Logger.i(message, LogSource.TASK, this.id)
fun Task.logw(message: String) = Logger.w(message, LogSource.TASK, this.id)
fun Task.loge(message: String) = Logger.e(message, LogSource.TASK, this.id)
fun Task.logs(message: String) = Logger.s(message, LogSource.TASK, this.id) 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\TaskScheduler.kt --- 
package com.grindrplus.core
class TaskScheduler(private val scope: CoroutineScope) {
    private val runningJobs = mutableMapOf<String, Job>()
    fun periodic(
        name: String,
        intervalMs: Long,
        action: suspend () -> Unit
    ): Job {
        val job = scope.launch {
            while (true) {
                try {
                    action()
                    delay(intervalMs)
                } catch (e: Exception) {
                    Logger.e("$name failed: ${e.message}", LogSource.MODULE)
                    Logger.writeRaw(e.stackTraceToString())
                    delay(intervalMs)
                }
            }
        }
        runningJobs[name] = job
        return job
    }
    fun once(name: String, action: suspend () -> Unit): Job {
        val job = scope.launch {
            try {
                action()
            } catch (e: Exception) {
                Logger.e("$name failed: ${e.message}", LogSource.MODULE)
                Logger.writeRaw(e.stackTraceToString())
            } finally {
                runningJobs.remove(name)
            }
        }
        runningJobs[name] = job
        return job
    }
    fun withRetry(
        name: String,
        retries: Int = 3,
        delayMs: Long = 1000,
        action: suspend () -> Unit
    ): Job {
        val job = scope.launch {
            try {
                repeat(retries) { attempt ->
                    try {
                        action()
                        return@launch
                    } catch (e: Exception) {
                        if (attempt == retries - 1) {
                            Logger.e("$name failed after $retries attempts", LogSource.MODULE)
                            Logger.writeRaw(e.stackTraceToString())
                            throw e
                        } else {
                            Logger.w("$name retry ${attempt+1}/$retries", LogSource.MODULE)
                            delay(delayMs)
                        }
                    }
                }
            } finally {
                runningJobs.remove(name)
            }
        }
        runningJobs[name] = job
        return job
    }
    fun isTaskRunning(name: String): Boolean {
        return runningJobs[name]?.isActive == true
    }
    fun cancelTask(name: String) {
        runningJobs[name]?.cancel()
        runningJobs.remove(name)
    }
    fun cancelAllTasks() {
        runningJobs.values.forEach { it.cancel() }
        runningJobs.clear()
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\Utils.kt --- 
package com.grindrplus.core
object Utils {
    fun openChat(id: String) {
        val chatActivityInnerClass =
            GrindrPlus.loadClass("com.grindrapp.android.chat.presentation.ui.ChatActivityV2\$a")
        val chatArgsClass =
            GrindrPlus.loadClass("com.grindrapp.android.args.ChatArgs")
        val profileTypeClass =
            GrindrPlus.loadClass("com.grindrapp.android.ui.profileV2.model.ProfileType")
        val referrerTypeClass =
            GrindrPlus.loadClass("com.grindrapp.android.profile.domain.ReferrerType")
        val conversationMetadataClass =
            GrindrPlus.loadClass("com.grindrapp.android.chat.model.DirectConversationMetaData")
        val conversationMetadataInstance = conversationMetadataClass.constructors.first().newInstance(
            id,
            id.substringBefore(":"),
            id.substringAfter(":")
        )
        val profileType = profileTypeClass.getField("FAVORITES").get(null)
        val refererType = referrerTypeClass.getField("UNIFIED_CASCADE").get(null)
        val chatArgsInstance = chatArgsClass.constructors.first().newInstance(
            conversationMetadataInstance,
            "notification_chat_message", // str
            profileType,
            refererType,
            "0xDEADBEEF", // str2
            "0xDEADBEEF", // str3
            null,
            false,
            844
        )
        val method = chatActivityInnerClass.declaredMethods.find {
            it.parameterTypes.size == 2 && it.parameterTypes[1] == chatArgsClass
        }
        val intent = method?.invoke(
            null,
            context,
            chatArgsInstance
        ) as Intent?
        intent?.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        val generalDeepLinksClass =
            GrindrPlus.loadClass("com.grindrapp.android.deeplink.GeneralDeepLinks")
        val startActivityMethod = generalDeepLinksClass.getDeclaredMethod(
            "safedk_Context_startActivity_97cb3195734cf5c9cc3418feeafa6dd6",
            Context::class.java,
            Intent::class.java
        )
        startActivityMethod.invoke(null, context, intent)
    }
    fun openProfile(id: String) {
        val referrerTypeClass =
            GrindrPlus.loadClass("com.grindrapp.android.profile.domain.ReferrerType")
        val referrerType = referrerTypeClass.getField("NOTIFICATION").get(null)
        val profilesActivityInnerClass =
            GrindrPlus.loadClass("com.grindrapp.android.ui.profileV2.ProfilesActivity\$a")
        Logger.i("ProfilesActivity inner class: $profilesActivityInnerClass")
        val method = profilesActivityInnerClass.declaredMethods.find {
            it.parameterTypes.size == 4 && it.parameterTypes[2] == referrerTypeClass
        }
        if (method == null) {
            Logger.e("Method not found in ProfilesActivity inner class.")
            return
        }
        val intent = method?.invoke(
            null,
            context,
            id,
            referrerType,
            referrerType
        ) as Intent?
        intent?.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        val generalDeepLinksClass =
            GrindrPlus.loadClass("com.grindrapp.android.deeplink.GeneralDeepLinks")
        val startActivityMethod = generalDeepLinksClass.getDeclaredMethod(
            "safedk_Context_startActivity_97cb3195734cf5c9cc3418feeafa6dd6",
            Context::class.java,
            Intent::class.java
        )
        startActivityMethod.invoke(null, context, intent)
    }
    fun calculateBMI(isMetric: Boolean, weight: Double, height: Double): Double {
        return if (isMetric) {
            weight / (height / 100).pow(2)
        } else {
            703 * weight / height.pow(2)
        }
    }
    fun w2n(isMetric: Boolean, weight: String): Double {
        return when {
            isMetric -> weight.substringBefore("kg").trim().toDouble()
            else -> weight.substringBefore("lbs").trim().toDouble()
        }
    }
    fun h2n(isMetric: Boolean, height: String): Double {
        return if (isMetric) {
            height.removeSuffix("cm").trim().toDouble()
        } else {
            val (feet, inches) = height.split("'").let {
                it[0].toDouble() to it[1].replace("\"", "").toDouble()
            }
            feet * 12 + inches
        }
    }
    fun safeGetField(obj: Any, fieldName: String): Any? {
        return try {
            obj::class.java.getDeclaredField(fieldName).apply {
                isAccessible = true
            }.get(obj)
        } catch (e: Exception) {
            null
        }
    }
    fun coordsToGeoHash(lat: Double, lon: Double, precision: Int = 12): String {
        return GrindrPlus.loadClass("ch.hsr.geohash.GeoHash")
            .getMethod("geoHashStringWithCharacterPrecision",
                Double::class.java, Double::class.java, Int::class.java)
            .invoke(null, lat, lon, precision) as String
    }
    @SuppressLint("SetTextI18n")
    fun showProgressDialog(
        context: Context,
        message: String,
        onCancel: () -> Unit,
        onRunInBackground: (updateProgress: (Int) -> Unit, onComplete: (Boolean) -> Unit) -> Unit,
        successMessage: String = "All blocks have been imported!",
        failureMessage: String = "Something went wrong. Please try again."
    ) {
        lateinit var dialog: AlertDialog
        val progressBar = ProgressBar(context, null, android.R.attr.progressBarStyleHorizontal).apply {
            isIndeterminate = false
            max = 100
            progress = 0
        }
        val textView = TextView(context).apply {
            text = "$message (0%)"
            textSize = 16f
            setPadding(20, 20, 20, 20)
        }
        val cancelButton = Button(context).apply {
            text = "Cancel"
            setOnClickListener {
                onCancel()
                dialog.dismiss()
            }
        }
        val backgroundButton = Button(context).apply {
            text = "Run in Background"
            setOnClickListener {
                dialog.dismiss()
            }
        }
        val container = LinearLayout(context).apply {
            orientation = LinearLayout.VERTICAL
            setPadding(40, 40, 40, 40)
            addView(progressBar)
            addView(textView)
            addView(cancelButton)
            addView(backgroundButton)
        }
        dialog = AlertDialog.Builder(context)
            .setCancelable(false)
            .setView(container)
            .create()
        dialog.show()
        onRunInBackground({ progress ->
            progressBar.progress = progress
            textView.text = "$message ($progress%)"
        }) { success ->
            container.removeAllViews()
            val resultIcon = TextView(context).apply {
                text = if (success) "✅" else "❌"
                textSize = 40f
                setPadding(20, 20, 20, 20)
                gravity = android.view.Gravity.CENTER
            }
            val resultMessage = TextView(context).apply {
                text = if (success) successMessage else failureMessage
                textSize = 18f
                setPadding(20, 20, 20, 20)
                gravity = android.view.Gravity.CENTER
            }
            val closeButton = Button(context).apply {
                text = "Close"
                setOnClickListener {
                    dialog.dismiss()
                }
            }
            container.apply {
                addView(resultIcon)
                addView(resultMessage)
                addView(closeButton)
            }
        }
    }
    fun showWarningDialog(context: Context, message: String, onConfirm: () -> Unit, onCancel: () -> Unit) {
        AlertDialog.Builder(context)
            .setTitle("Warning")
            .setMessage(message)
            .setCancelable(false)
            .setPositiveButton("Proceed") { _, _ ->
                onConfirm()
            }
            .setNegativeButton("Cancel") { _, _ ->
                onCancel()
            }
            .create()
            .show()
    }
    fun handleImports(activity: Activity) {
        val homeActivity = "com.grindrapp.android.ui.home.HomeActivity"
        if (activity.javaClass.name == homeActivity && !isImportingSomething) {
            val favoritesFile = context.getFileStreamPath("favorites_to_import.txt")
            val blocksFile = context.getFileStreamPath("blocks_to_import.txt")
            if (favoritesFile.exists() && blocksFile.exists()) {
                showWarningDialog(
                    context = activity,
                    message = "Favorites and Blocks import files detected. GrindrPlus will process the favorites list first. " +
                            "Blocks import will be done on the next app restart.",
                    onConfirm = {
                        val threshold = (Config.get("favorites_import_threshold", "500") as String).toInt()
                        val favorites = favoritesFile.readLines()
                        if (favorites.size > 50 && threshold < 1000) {
                            showWarningDialog(
                                context = activity,
                                message = "High number of favorites and low threshold detected. " +
                                        "Continuing may result in your account being banned. Do you want to proceed?",
                                onConfirm = {
                                    startFavoritesImport(activity, favorites, favoritesFile, threshold)
                                },
                                onCancel = {
                                    Logger.i("Favorites import canceled by the user.")
                                }
                            )
                        } else {
                            startFavoritesImport(activity, favorites, favoritesFile, threshold)
                        }
                    },
                    onCancel = {
                        Logger.i("Imports canceled by the user.")
                    }
                )
            } else if (favoritesFile.exists()) {
                val threshold = (Config.get("favorites_import_threshold", "500") as String).toInt()
                val favorites = favoritesFile.readLines()
                if (favorites.size > 50 && threshold < 1000) {
                    showWarningDialog(
                        context = activity,
                        message = "High number of favorites and low threshold detected. " +
                                "Continuing may result in your account being banned. Do you want to proceed?",
                        onConfirm = {
                            startFavoritesImport(activity, favorites, favoritesFile, threshold)
                        },
                        onCancel = {
                            isImportingSomething = false
                            Logger.i("Favorites import canceled by the user.")
                        }
                    )
                } else {
                    startFavoritesImport(activity, favorites, favoritesFile, threshold)
                }
            } else if (blocksFile.exists()) {
                val threshold = (Config.get("block_import_threshold", "500") as String).toInt()
                val blocks = blocksFile.readLines()
                if (blocks.size > 100 && threshold < 1000) {
                    showWarningDialog(
                        context = activity,
                        message = "High number of blocks and low threshold detected. " +
                                "Continuing may result in your account being banned. Do you want to proceed?",
                        onConfirm = {
                            startBlockImport(activity, blocks, blocksFile, threshold)
                        },
                        onCancel = {
                            isImportingSomething = false
                            Logger.i("Block import canceled by the user.")
                        }
                    )
                } else {
                    startBlockImport(activity, blocks, blocksFile, threshold)
                }
            }
        }
    }
    private fun startFavoritesImport(
        activity: Activity,
        favorites: List<String>,
        favoritesFile: File,
        threshold: Int
    ) {
        try {
            showProgressDialog(
                context = activity,
                message = "Importing favorites...",
                successMessage = "Favorites import completed.",
                failureMessage = "Favorites import failed.",
                onCancel = {
                    isImportingSomething = false
                    Logger.i("Favorites import canceled by the user.")
                },
                onRunInBackground = { updateProgress, onComplete ->
                    CoroutineScope(Dispatchers.IO).launch {
                        try {
                            favorites.forEachIndexed { index, id ->
                                val parts = id.split("|||")
                                val profileId = parts.getOrNull(0) ?: ""
                                val note = parts.getOrNull(1)?.replace(NEWLINE, "\n") ?: ""
                                val phoneNumber = parts.getOrNull(2)?.replace(NEWLINE, "\n") ?: ""
                                httpClient.favorite(
                                    profileId,
                                    silent = true,
                                    reflectInDb = false
                                )
                                if (note.isNotEmpty() || phoneNumber.isNotEmpty()) {
                                    httpClient.addProfileNote(
                                        profileId,
                                        note,
                                        phoneNumber,
                                        silent = true
                                    )
                                }
                                favoritesFile.writeText(favorites.drop(index + 1).joinToString("\n"))
                                val progress = ((index + 1) * 100) / favorites.size
                                updateProgress(progress)
                                Thread.sleep(threshold.toLong())
                            }
                            withContext(Dispatchers.Main) {
                                favoritesFile.delete()
                                onComplete(true)
                            }
                        } catch (e: Exception) {
                            withContext(Dispatchers.Main) {
                                val message = "An error occurred while importing favorites: ${e.message ?: "Unknown error"}"
                                GrindrPlus.showToast(Toast.LENGTH_LONG, message)
                                Logger.apply {
                                    e(message)
                                    writeRaw(e.stackTraceToString())
                                }
                                onComplete(false)
                            }
                        } finally {
                            isImportingSomething = false
                        }
                    }
                }
            )
        } catch (e: Exception) {
            val message = "An error occurred while importing favorites: ${e.message ?: "Unknown error"}"
            GrindrPlus.showToast(Toast.LENGTH_LONG, message)
            Logger.apply {
                e(message)
                writeRaw(e.stackTraceToString())
            }
        }
    }
    private fun startBlockImport(
        activity: Activity,
        blocks: List<String>,
        blocksFile: File,
        threshold: Int
    ) {
        try {
            shouldTriggerAntiblock = false
            showProgressDialog(
                context = activity,
                message = "Importing blocks...",
                successMessage = "Block import completed.",
                failureMessage = "Block import failed.",
                onCancel = {
                    isImportingSomething = false
                    Logger.i("Block import canceled by the user.")
                },
                onRunInBackground = { updateProgress, onComplete ->
                    CoroutineScope(Dispatchers.IO).launch {
                        try {
                            blocks.forEachIndexed { index, id ->
                                httpClient.blockUser(
                                    id,
                                    silent = true,
                                    reflectInDb = false
                                )
                                blocksFile.writeText(blocks.drop(index + 1).joinToString("\n"))
                                val progress = ((index + 1) * 100) / blocks.size
                                updateProgress(progress)
                                Thread.sleep(threshold.toLong())
                            }
                            withContext(Dispatchers.Main) {
                                blocksFile.delete()
                                onComplete(true)
                            }
                        } catch (e: Exception) {
                            withContext(Dispatchers.Main) {
                                val message = "An error occurred while importing blocks: ${e.message ?: "Unknown error"}"
                                GrindrPlus.showToast(Toast.LENGTH_LONG, message)
                                Logger.apply {
                                    e(message)
                                    writeRaw(e.stackTraceToString())
                                }
                                onComplete(false)
                            }
                        } finally {
                            shouldTriggerAntiblock = true
                            isImportingSomething = false
                        }
                    }
                }
            )
        } catch (e: Exception) {
            val message = "An error occurred while importing blocks: ${e.message ?: "Unknown error"}"
            GrindrPlus.apply {
                shouldTriggerAntiblock = true
                showToast(Toast.LENGTH_LONG, message)
            }
            Logger.apply {
                e(message)
                writeRaw(e.stackTraceToString())
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\constants\GrindrApiError.kt --- 
package com.grindrplus.core.constants
enum class GrindrApiError(val code: Int?, val message: String) {
    ERR_CANNOT_SAVE(2, "Unable to save"),
    ERR_INVALID_PARAMETERS(4, "Invalid input parameters"),
    ERR_UNKNOWN_ERROR(5, "Unknown error"),
    ERR_INVALID_TOKEN(6, "Invalid token"),
    ERR_FAILED_TO_CREATE_SESSION(7, "Failed to create session"),
    ERR_DEPRECATED_CLIENT_VERSION(8, "The client version is deprecated"),
    ERR_DUPLICATED_USER(9, "Duplicated user"),
    ERR_USER_IS_NOT_ACTIVE(10, "User is not active"),
    ERR_SAVE_FAILURE(11, "Save failure"),
    ERR_UNKNOWN_PLATFORM(13, "Unknown platform"),
    ERR_FAILED_TO_VALIDATE_CAPTCHA(15, "Failed to validate captcha"),
    ERR_SHORT_PASSWORD(16, "Your password is too short. Please enter a password with at least six characters"),
    ERR_FAILED_TO_CREATE_PROFILE(17, "Failed to create profile"),
    ERR_WEAK_PASSWORD(17, "Your password does not meet complexity requirements"),
    ERR_INVALID_CAPTCHA_TOKEN(18, "Invalid captcha token"),
    ERR_INVALID_AGE(19, "Invalid age"),
    ERR_EMAIL_EXISTS(22, "Email id already exists"),
    ERR_EMAIL_NOT_FOUND(23, "Email id not found"),
    ERR_AUTH_FAILURE(24, "User Authentication failed"),
    ERR_RESET_TOKEN_NOT_FOUND(25, "Token not found"),
    ERR_PROFILE_BANNED(27, "Profile is banned"),
    ERR_DEVICE_BANNED(28, "Your device has been banned"),
    ERR_INVALID_EMAIL(29, "Invalid email"),
    ERR_VERIFICATION_REQUIRED(30, "Verification required"),
    ERR_IP_BANNED(31, "SUSPICIOUS_NETWORK"),
    ERR_ACCOUNT_REGISTRATION_FAILED(32, "Account Registration Failed"),
    ERR_ACCOUNT_REGISTRATION_REJECTED(33, "Account registration rejected"),
    ERR_EXCEED_FAVE_DAILY_LIMIT(33, "Favorite daily limit reached"),
    ERR_CANNOT_UNBLOCK_NONBLOCKED(36, "Can not unblock a non-blocked user"),
    ERR_AGE_RESTRICTED(35, "Underage ban, ages 13-17"),
    ERR_UNDER_THIRTEEN(36, "Underage ban, ages 5-12"),
    ERR_INVALID_THIRD_PARTY_TOKEN(80, "Invalid third party token"),
    ERR_THIRD_PARTY_USER_ID_EXISTS(81, "Third party user id exists"),
    ERR_THIRD_PARTY_CREATE_ACCOUNT(83, "Error when third party create account"),
    ERR_PHONE_EXISTS(300, "Phone number already exists"),
    ERR_PHONE_NOT_FOUND(301, "Phone number not found"),
    ERR_INVALID_PHONE_NUMBER(302, "Invalid phone number"),
    ERR_INVALID_VERIFICATION_CODE(303, "Invalid verification code"),
    ERR_INVALID_PHONE_NUMBER_REGISTRATION_AFTER_DELETION(304, "Another profile with this phone number was deleted recently"),
    ERR_NOT_AVAILABLE_IN_THIS_REGION(305, "Not available in this region"),
    ERR_SMS_ENDPOINT_LIMIT_REACHED(306, "SMS endpoint limit reached"),
    ERR_PROFILE_ALREADY_VERIFIED(null, "Profile is already verified"),
    ERR_PROFILE_NOT_REQUIRED_VERIFY(null, "Profile is not verification required"),
    ERR_PHONE_NUM_TOO_MANY_TIMES(null, "Phone number was used too many times"),
    ERR_PHONE_NUMBER_IS_BANNED(null, "Phone number is banned"),
    ERR_TARGET_PROFILE_OFFLINE(null, "Target profile is offline"),
    ERR_EXCEED_LENGTH_LIMIT(null, "Exceed length limit");
    companion object {
        private val errorsByCode = GrindrApiError.entries.filter { it.code != null }.associateBy { it.code }
        private val errorsByMessage = GrindrApiError.entries.associateBy { it.message }
        private val errorsByName = GrindrApiError.entries.associateBy { it.name }
        @JvmStatic
        fun findError(errorCode: Int?, errorMessage: String?): GrindrApiError? {
            return when {
                errorCode != null -> errorsByCode[errorCode]
                errorMessage != null -> errorsByMessage[errorMessage] ?: errorsByName[errorMessage]
                else -> null
            }
        }
        @JvmStatic
        fun getErrorDescription(errorCode: Any?): String {
            val error = when(errorCode) {
                is Int -> findError(errorCode, null)
                is String -> findError(null, errorCode)
                else -> null
            }
            return error?.message ?: "Unknown error: $errorCode"
        }
        @JvmStatic
        fun isErrorType(errorCode: Any?, errorType: GrindrApiError): Boolean {
            return when(errorCode) {
                is Int -> errorCode == errorType.code
                is String -> {
                    errorCode == errorType.code.toString() ||
                            errorCode == errorType.name ||
                            errorCode == errorType.message
                }
                else -> false
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\http\Client.kt --- 
package com.grindrplus.core.http
class Client(interceptor: Interceptor) {
    private val httpClient: OkHttpClient = OkHttpClient.Builder()
        .addInterceptor(interceptor)
        .build()
    fun sendRequest(
        url: String,
        method: String = "GET",
        headers: Map<String, String>? = null,
        body: RequestBody? = null
    ): Response {
        val requestBuilder = Request.Builder().url(url)
        headers?.forEach { (key, value) ->
            requestBuilder.addHeader(key, value)
        }
        when (method.uppercase()) {
            "POST" -> requestBuilder.post(body ?: RequestBody.createEmpty())
            "PUT" -> requestBuilder.put(body ?: throw IllegalArgumentException("PUT requires a body"))
            "DELETE" -> {
                if (body != null) requestBuilder.delete(body) else requestBuilder.delete()
            }
            "PATCH" -> requestBuilder.patch(body ?: throw IllegalArgumentException("PATCH requires a body"))
            "GET" -> requestBuilder.get()
            else -> throw IllegalArgumentException("Unsupported HTTP method: $method")
        }
        return httpClient.newCall(requestBuilder.build()).execute()
    }
    fun blockUser(profileId: String, silent: Boolean = false, reflectInDb: Boolean = true) {
        GrindrPlus.shouldTriggerAntiblock = false
        GrindrPlus.executeAsync {
            val response = sendRequest(
                "https://grindr.mobi/v3/me/blocks/$profileId",
                "POST"
            )
            if (response.isSuccessful) {
                if (!silent) showToast(Toast.LENGTH_LONG, "User blocked successfully")
                if (reflectInDb) {
                    val order = DatabaseHelper.query(
                        "SELECT MAX(order_) AS order_ FROM blocks"
                    ).firstOrNull()?.get("order_") as? Int ?: 0
                    DatabaseHelper.insert(
                        "blocks",
                        ContentValues().apply {
                            put("profileId", profileId)
                            put("order_", order + 1)
                        }
                    )
                }
            } else {
                if (!silent) {
                    response.useBody { errorBody ->
                        showToast(Toast.LENGTH_LONG, "Failed to block user: $errorBody")
                    }
                }
            }
        }
        GrindrPlus.executeAsync {
            Thread.sleep(500) // Wait for WS to reply
            GrindrPlus.shouldTriggerAntiblock = true
        }
    }
    fun unblockUser(profileId: String, silent: Boolean = false, reflectInDb: Boolean = true) {
        GrindrPlus.shouldTriggerAntiblock = false
        GrindrPlus.executeAsync {
            val response = sendRequest(
                "https://grindr.mobi/v3/me/blocks/$profileId",
                "DELETE"
            )
            if (response.isSuccessful) {
                if (!silent) showToast(Toast.LENGTH_LONG, "User unblocked successfully")
                try {
                    if (reflectInDb) {
                        DatabaseHelper.delete(
                            "blocks",
                            "profileId = ?",
                            arrayOf(profileId)
                        )
                    }
                } catch (e: Exception) {
                    Logger.apply {
                        e("Error removing user from blocks list: ${e.message}")
                        writeRaw(e.stackTraceToString())
                    }
                }
            } else {
                if (!silent) {
                    response.useBody { errorBody ->
                        showToast(Toast.LENGTH_LONG, "Failed to unblock user: $errorBody")
                    }
                }
            }
        }
        GrindrPlus.executeAsync {
            Thread.sleep(500) // Wait for WS to reply
            GrindrPlus.shouldTriggerAntiblock = true
        }
    }
    fun favorite(
        profileId: String,
        silent: Boolean = false,
        reflectInDb: Boolean = true
    ) {
        GrindrPlus.executeAsync {
            val response = sendRequest(
                "https://grindr.mobi/v3/me/favorites/$profileId",
                "POST"
            )
            if (response.isSuccessful) {
                if (!silent) showToast(Toast.LENGTH_LONG, "User favorited successfully")
                if (reflectInDb) {
                    DatabaseHelper.insert(
                        "favorite_profile",
                        ContentValues().apply {
                            put("id", profileId)
                        }
                    )
                }
            } else {
                if (!silent) {
                    response.useBody { errorBody ->
                        showToast(Toast.LENGTH_LONG, "Failed to favorite user: $errorBody")
                    }
                }
            }
        }
    }
    fun unfavorite(
        profileId: String,
        silent: Boolean = false,
        reflectInDb: Boolean = true
    ) {
        GrindrPlus.executeAsync {
            val response = sendRequest(
                "https://grindr.mobi/v3/me/favorites/$profileId",
                "DELETE"
            )
            if (response.isSuccessful) {
                if (!silent) showToast(Toast.LENGTH_LONG, "User unfavorited successfully")
                try {
                    if (reflectInDb) {
                        DatabaseHelper.delete(
                            "favorite_profile",
                            "id = ?",
                            arrayOf(profileId)
                        )
                    }
                } catch (e: Exception) {
                    Logger.apply {
                        e("Error removing user from favorites list: ${e.message}")
                        writeRaw(e.stackTraceToString())
                    }
                }
            } else {
                if (!silent) {
                    response.useBody { errorBody ->
                        showToast(Toast.LENGTH_LONG, "Failed to unfavorite user: $errorBody")
                    }
                }
            }
        }
    }
    fun updateLocation(geohash: String) {
        val body = """
            {
                "geohash": "$geohash"
            }
        """.trimIndent()
        GrindrPlus.executeAsync {
            val response = sendRequest(
                "https://grindr.mobi/v4/location",
                "PUT",
                body = body.toRequestBody(),
                headers = mapOf("Content-Type" to "application/json; charset=UTF-8")
            )
            if (response.isSuccessful) {
                showToast(Toast.LENGTH_LONG, "Location updated successfully")
            } else {
                response.useBody { errorBody ->
                    showToast(Toast.LENGTH_LONG, "Failed to update location: $errorBody")
                }
            }
        }
    }
    fun reportUser(
        profileId: String,
        reason: String = "SPAM",
        comment: String = ""
    ) {
        GrindrPlus.executeAsync {
            val body = """
                {
                    "reason": "$reason",
                    "comment": "$comment",
                    "locations": [
                        "CHAT_MESSAGE"
                    ]
                }
            """.trimIndent()
            val response = sendRequest(
                "https://grindr.mobi/v3.1/flags/$profileId",
                "POST",
                body = body.toRequestBody(),
                headers = mapOf("Content-Type" to "application/json; charset=UTF-8")
            )
            if (response.isSuccessful) {
                showToast(Toast.LENGTH_LONG, "User reported successfully")
            } else {
                response.useBody { errorBody ->
                    showToast(Toast.LENGTH_LONG, "Failed to report user: $errorBody")
                }
            }
        }
    }
    suspend fun fetchCascade(
        nearbyGeoHash: String,
        onlineOnly: Boolean = false,
        photoOnly: Boolean = false,
        faceOnly: Boolean = false,
        notRecentlyChatted: Boolean = false,
        fresh: Boolean = false,
        pageNumber: Int = 1,
        favorites: Boolean = false,
        showSponsoredProfiles: Boolean = false,
        shuffle: Boolean = false
    ): JSONObject = withContext(Dispatchers.IO) {
        try {
            val url = buildString {
                append("https://grindr.mobi/v3/cascade?nearbyGeoHash=$nearbyGeoHash")
                append("&onlineOnly=$onlineOnly")
                append("&photoOnly=$photoOnly")
                append("&faceOnly=$faceOnly")
                append("&notRecentlyChatted=$notRecentlyChatted")
                append("&fresh=$fresh")
                append("&pageNumber=$pageNumber")
                append("&favorites=$favorites")
                append("&showSponsoredProfiles=$showSponsoredProfiles")
                append("&shuffle=$shuffle")
            }
            val response = sendRequest(url, "GET")
            if (response.isSuccessful) {
                response.useBody { responseBody ->
                    if (!responseBody.isNullOrEmpty()) {
                        return@withContext JSONObject(responseBody)
                    }
                    JSONObject()
                }
            } else {
                Logger.e("Failed to get nearby profiles: ${response.code}")
                response.useBody { errorBody ->
                    Logger.e("Error body: $errorBody")
                }
                JSONObject()
            }
        } catch (e: Exception) {
            Logger.e("Failed to get nearby profiles: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
            JSONObject()
        }
    }
    suspend fun getBlocks(): List<String> = withContext(Dispatchers.IO) {
        try {
            val response = sendRequest("https://grindr.mobi/v3.1/me/blocks", "GET")
            if (response.isSuccessful) {
                response.useBody { responseBody ->
                    if (!responseBody.isNullOrEmpty()) {
                        val jsonResponse = JSONObject(responseBody)
                        val blockingArray = jsonResponse.optJSONArray("blocking")
                        if (blockingArray != null) {
                            val blockedProfileIds = mutableListOf<String>()
                            for (i in 0 until blockingArray.length()) {
                                val blockingJson = blockingArray.getJSONObject(i)
                                val profileId = blockingJson.optLong("profileId")
                                blockedProfileIds.add(profileId.toString())
                            }
                            return@useBody blockedProfileIds
                        }
                    }
                    emptyList()
                }
            } else {
                emptyList()
            }
        } catch (e: Exception) {
            Logger.e("Failed to get blocks: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
            emptyList()
        }
    }
    suspend fun getFavorites(): List<Triple<String, String, String>> = withContext(Dispatchers.IO) {
        try {
            val response = sendRequest("https://grindr.mobi/v6/favorites", "GET")
            if (response.isSuccessful) {
                response.useBody { responseBody ->
                    if (!responseBody.isNullOrEmpty()) {
                        val jsonResponse = JSONObject(responseBody)
                        val favoritesArray = jsonResponse.optJSONArray("favorites")
                        if (favoritesArray != null) {
                            val favoriteProfileIds = mutableListOf<Triple<String, String, String>>()
                            for (i in 0 until favoritesArray.length()) {
                                val favoriteJson = favoritesArray.getJSONObject(i)
                                val profileId = favoriteJson.optString("profileId")
                                val note = try {
                                    DatabaseHelper.query(
                                        "SELECT note FROM profile_note WHERE profile_id = ?",
                                        arrayOf(profileId)
                                    ).firstOrNull()?.get("note") as? String ?: ""
                                } catch (e: Exception) {
                                    Logger.apply {
                                        log("Failed to fetch note for profileId $profileId: ${e.message}")
                                        writeRaw(e.stackTraceToString())
                                    }
                                    ""
                                }
                                val phoneNumber = try {
                                    DatabaseHelper.query(
                                        "SELECT phone_number FROM profile_note WHERE profile_id = ?",
                                        arrayOf(profileId)
                                    ).firstOrNull()?.get("phone_number") as? String ?: ""
                                } catch (e: Exception) {
                                    Logger.apply {
                                        log("Failed to fetch phone number for profileId $profileId: ${e.message}")
                                        writeRaw(e.stackTraceToString())
                                    }
                                    ""
                                }
                                favoriteProfileIds.add(Triple(profileId, note, phoneNumber))
                            }
                            return@useBody favoriteProfileIds
                        }
                    }
                    emptyList()
                }
            } else {
                emptyList()
            }
        } catch (e: Exception) {
            Logger.e("Failed to get favorites: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
            emptyList()
        }
    }
    fun addProfileNote(profileId: String, notes: String, phoneNumber: String, silent: Boolean = false) {
        if (notes.length > 250) {
            showToast(Toast.LENGTH_LONG, "Notes are too long")
            return
        }
        val body = """
            {
                "notes": "${notes.replace("\n", "\\n")}",
                "phoneNumber": "$phoneNumber"
            }
        """.trimIndent()
        GrindrPlus.executeAsync {
            val response = sendRequest(
                "https://grindr.mobi/v1/favorites/notes/$profileId",
                "PUT",
                body = body.toRequestBody(),
                headers = mapOf("Content-Type" to "application/json; charset=utf-8")
            )
            if (response.isSuccessful) {
                try {
                    val existingNote = DatabaseHelper.query(
                        "SELECT * FROM profile_note WHERE profile_id = ?",
                        arrayOf(profileId)
                    ).firstOrNull()
                    if (existingNote != null) {
                        DatabaseHelper.update(
                            "profile_note",
                            ContentValues().apply {
                                put("note", notes)
                                put("phone_number", phoneNumber)
                            },
                            "profile_id = ?",
                            arrayOf(profileId)
                        )
                    } else {
                        DatabaseHelper.insert(
                            "profile_note",
                            ContentValues().apply {
                                put("profile_id", profileId)
                                put("note", notes)
                                put("phone_number", phoneNumber)
                            }
                        )
                    }
                } catch (e: Exception) {
                    Logger.e("Failed to update profile note: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
                if (!silent) showToast(Toast.LENGTH_LONG, "Note added successfully")
            } else {
                if (!silent) {
                    response.useBody { errorBody ->
                        showToast(Toast.LENGTH_LONG, "Failed to add note: $errorBody")
                    }
                }
            }
        }
    }
}
fun RequestBody.Companion.createEmpty(): RequestBody {
    return "".toRequestBody()
}
private inline fun <T> Response.useBody(block: (String?) -> T): T {
    return try {
        block(body?.string())
    } finally {
        body?.close()
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\http\Interceptor.kt --- 
package com.grindrplus.core.http
class Interceptor(
    private val userSession: Any,
    private val userAgent: Any,
    private val deviceInfo: Any
) : Interceptor {
    private fun modifyRequest(originalRequest: Request): Request {
        // search for 'getJwt().length() > 0 &&' in userSession
        val isLoggedIn = invokeMethodSafe(userSession, "s") as? Boolean ?: false
        if (!isLoggedIn) {
            PermissionManager.requestExternalStoragePermission(GrindrPlus.context, delayMs = 7000)
            Logger.i("Triggered external storage permission request from Interceptor (user not logged in)", LogSource.HTTP)
           HttpBodyLogger.initialize(delayMs = 7000)
        }
        val builder: Builder = originalRequest.newBuilder()
        if (isLoggedIn) {
            // search for 'return FlowKt.asStateFlow' in userSession (return type is String)
            val authTokenFlow = invokeMethodSafe(userSession, "y")
            val authToken = if (authTokenFlow != null) {
                invokeMethodSafe(authTokenFlow, "getValue") as? String ?: ""
            } else {
                ""
            }
            // search for one line method returning an string in userSession
            val roles = invokeMethodSafe(userSession, "G") as? String ?: ""
            if (authToken.isNotEmpty()) {
                builder.header("Authorization", "Grindr3 $authToken")
                builder.header("L-Grindr-Roles", roles)
            } else {
                Logger.w("Auth token is empty, skipping auth headers", LogSource.HTTP)
            }
            builder.header("L-Time-Zone", TimeZone.getDefault().id)
            // search for 'public final kotlin.Lazy' in deviceInfo
            val deviceInfoLazy = getFieldSafe(deviceInfo, "d") as? Any
            val lDeviceInfo = if (deviceInfoLazy != null) {
                invokeMethodSafe(deviceInfoLazy, "getValue") as? String ?: ""
            } else {
                ""
            }
            if (lDeviceInfo.isNotEmpty()) {
                builder.header("L-Device-Info", lDeviceInfo)
            }
        } else {
            builder.header("L-Time-Zone", "Unknown")
        }
        // search for 'getValue().getNameTitleCase()' in userAgent
        val userAgentString = invokeMethodSafe(userAgent, "a") as? String ?: "Grindr"
        builder.header("Accept", "application/json; charset=UTF-8")
        builder.header("User-Agent", userAgentString)
        builder.header("L-Locale", "en_US")
        builder.header("Accept-language", "en-US")
        return builder.build()
    }
    private fun invokeMethodSafe(obj: Any?, methodName: String): Any? {
        return try {
            if (obj == null) {
                Logger.w("Object is null when trying to invoke method: $methodName", LogSource.HTTP)
                return null
            }
            val method = obj::class.java.getMethod(methodName)
            val result = method.invoke(obj)
            result
        } catch (e: NoSuchMethodException) {
            Logger.e("Method not found: $methodName on ${obj?.javaClass?.simpleName}", LogSource.HTTP)
            null
        } catch (e: Exception) {
            Logger.e("Failed to invoke method $methodName: ${e.message}", LogSource.HTTP)
            Logger.writeRaw(e.stackTraceToString())
            null
        }
    }
    private fun getFieldSafe(obj: Any?, fieldName: String): Any? {
        return try {
            if (obj == null) {
                Logger.w("Object is null when trying to get field: $fieldName", LogSource.HTTP)
                return null
            }
            val field = obj::class.java.getDeclaredField(fieldName)
            field.isAccessible = true
            val value = field.get(obj)
            value
        } catch (e: NoSuchFieldException) {
            Logger.e("Field not found: $fieldName on ${obj?.javaClass?.simpleName}", LogSource.HTTP)
            null
        } catch (e: Exception) {
            Logger.e("Failed to get field $fieldName: ${e.message}", LogSource.HTTP)
            Logger.writeRaw(e.stackTraceToString())
            null
        }
    }
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        return try {
            val modifiedRequest = modifyRequest(request)
            Logger.d("Intercepting request to: ${request.url}", LogSource.HTTP)
            val response= chain.proceed(modifiedRequest)
            HttpLogger.log(modifiedRequest, response)
            CredentialsLogger.log(
                modifiedRequest.header("Authorization"),
                modifiedRequest.header("L-Device-Info"),
                modifiedRequest.header("User-Agent"))
            val responseBody = response.peekBody(Long.MAX_VALUE).string()
            if (response.header("Content-Type")?.contains("application/json") == true) {
                HttpBodyLogger.log(modifiedRequest.url.toString(), modifiedRequest.method, responseBody)
            }
            return response
        } catch (e: SocketTimeoutException) {
            Logger.e("Request timeout: ${e.message}", LogSource.HTTP)
            createErrorResponse(request, 408, "Request Timeout")
        } catch (e: TimeoutException) {
            Logger.e("Request timeout: ${e.message}", LogSource.HTTP)
            createErrorResponse(request, 408, "Request Timeout")
        } catch (e: IOException) {
            Logger.e("Network error: ${e.message}", LogSource.HTTP)
            Logger.writeRaw(e.stackTraceToString())
            createErrorResponse(request, 503, "Network Error")
        } catch (e: Exception) {
            Logger.e("Unexpected error: ${e.message}", LogSource.HTTP)
            Logger.writeRaw(e.stackTraceToString())
            createErrorResponse(request, 500, "Internal Error")
        }
    }
    private fun createErrorResponse(request: Request, code: Int, message: String): Response {
        return Response.Builder()
            .request(request)
            .protocol(Protocol.HTTP_1_1)
            .code(code)
            .message(message)
            .body("".toResponseBody(null))
            .build()
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\core\http\PermissionManager.kt --- 
package com.grindrplus.manager.utils
object PermissionManager {
    fun requestExternalStoragePermission(context: Context, delayMs: Long = 0L) {
        val alreadyRequested = Config.get("external_permission_requested", false) as Boolean
        if (alreadyRequested) {
            Logger.d("External storage permission already requested", LogSource.MODULE)
            return
        }
        val requestBlock = {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R &&
                !Environment.isExternalStorageManager()) {
                try {
                    val intent = Intent(Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION)
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    context.startActivity(intent)
                    Logger.i("Requested MANAGE_EXTERNAL_STORAGE permission", LogSource.MODULE)
                    Config.put("external_permission_requested", true)
                } catch (e: Exception) {
                    Logger.e("Failed to request external storage permission: ${e.message}", LogSource.MODULE)
                    Logger.writeRaw(e.stackTraceToString())
                }
            } else {
                Logger.d("External storage permission already granted or not required", LogSource.MODULE)
            }
        }
        if (delayMs > 0) {
            Handler(Looper.getMainLooper()).postDelayed(requestBlock, delayMs)
        } else {
            requestBlock()
        }
    }
    fun requestNotificationPermission(activity: Activity) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            activity.requestPermissions(arrayOf(Manifest.permission.POST_NOTIFICATIONS), 1002)
        }
    }
    fun resetPermissionFlags() {
        Config.put("external_permission_requested", false)
    }
    // Optional: Trigger on first launch (commented out)
    fun autoRequestOnFirstLaunch(context: Context) {
        val firstLaunch = Config.get("first_launch", true) as Boolean
        if (firstLaunch) {
            requestExternalStoragePermission(context, delayMs = 3000)
        }
    }
    // Optional: Trigger after install confirmation (commented out)
    /*
    fun requestAfterInstallConfirmation(context: Context) {
        Handler(Looper.getMainLooper()).postDelayed({
            requestExternalStoragePermission(context)
        }, 5000)
    }
    */
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\AllowScreenshots.kt --- 
package com.grindrplus.hooks
class AllowScreenshots : Hook(
    "Allow screenshots",
    "Allow screenshots everywhere in the app"
) {
    override fun init() {
        Window::class.java.hook("setFlags", HookStage.BEFORE) { param ->
            var flags = param.arg<Int>(0)
            flags = flags and FLAG_SECURE.inv()
            param.setArg(0, flags)
        }
        Activity::class.java.hook("registerScreenCaptureCallback", HookStage.BEFORE) { param ->
            param.setResult(null)
        }
    ContentResolver::class.java.methods.first {
        it.name == "registerContentObserver" &&
                it.parameterTypes.contentEquals(arrayOf(Uri::class.java,
                    Boolean::class.javaPrimitiveType, ContentObserver::class.java))
        }.hook(HookStage.BEFORE) { param ->
            val uri = param.arg<Uri>(0)
            if (uri.host != "media") return@hook
            param.setResult(null)
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\AntiBlock.kt --- 
package com.grindrplus.hooks
class AntiBlock : Hook(
    "Anti Block",
    "Notifies you when someone blocks or unblocks you"
) {
    private val scope = CoroutineScope(Dispatchers.IO)
    private var myProfileId: Long = 0
    private val chatDeleteConversationPlugin = "F6.c" // search for 'com.grindrapp.android.chat.ChatDeleteConversationPlugin'
    private val inboxFragmentV2DeleteConversations = "ca.i" // search for '("chat_read_receipt", conversationId, null);'
    private val individualUnblockActivityViewModel = "ng.p" // search for 'SnackbarEvent.i.ERROR, R.string.unblock_individual_sync_blocks_failure, null, new SnackbarEvent'
    override fun init() {
        // search for '.setValue(new DialogMessage(116, null, 2, null));'
        findClass(individualUnblockActivityViewModel).hook("K", HookStage.BEFORE) { param ->
            GrindrPlus.shouldTriggerAntiblock = false
        }
        // search for '.setValue(new DialogMessage(116, null, 2, null));'
        findClass(individualUnblockActivityViewModel).hook("K", HookStage.AFTER) { param ->
            Thread.sleep(700) // Wait for WS to unblock
            GrindrPlus.shouldTriggerAntiblock = true
        }
        if (Config.get("force_old_anti_block_behavior", false) as Boolean) {
            findClass("com.grindrapp.android.chat.model.ConversationDeleteNotification")
                .hookConstructor(HookStage.BEFORE) { param ->
                    @Suppress("UNCHECKED_CAST")
                    val profiles = param.args().firstOrNull() as? List<String> ?: emptyList()
                    param.setArg(0, emptyList<String>())
                }
        } else {
            findClass(inboxFragmentV2DeleteConversations)
                .hook("d", HookStage.BEFORE) { param ->
                    GrindrPlus.shouldTriggerAntiblock = false
                    GrindrPlus.blockCaller = "inboxFragmentV2DeleteConversations"
                }
            findClass(inboxFragmentV2DeleteConversations)
                .hook("d", HookStage.AFTER) { param ->
                    val numberOfChatsToDelete = (param.args().firstOrNull() as? List<*>)?.size ?: 0
                    if (numberOfChatsToDelete == 0) return@hook
                    logd("Request to delete $numberOfChatsToDelete chats")
                    Thread.sleep((300 * numberOfChatsToDelete).toLong()) // FIXME
                    GrindrPlus.shouldTriggerAntiblock = true
                    GrindrPlus.blockCaller = ""
                }
            findClass(chatDeleteConversationPlugin).hook("b", HookStage.BEFORE) { param ->
                myProfileId = GrindrPlus.myProfileId.toLong()
                if (!GrindrPlus.shouldTriggerAntiblock) {
                    val whitelist = listOf(
                        "inboxFragmentV2DeleteConversations",
                    )
                    if (GrindrPlus.blockCaller !in whitelist) {
                        param.setResult(null)
                    }
                    return@hook
                }
            }
            findClass("com.grindrapp.android.chat.model.ConversationDeleteNotification")
                .hookConstructor(HookStage.BEFORE) { param ->
                    @Suppress("UNCHECKED_CAST")
                    if (GrindrPlus.shouldTriggerAntiblock) {
                        val profiles = param.args().firstOrNull() as? List<String> ?: emptyList()
                        param.setArg(0, emptyList<String>())
                    }
                }
            scope.launch {
                GrindrPlus.serverNotifications.collect { notification ->
                    if (notification.typeValue != "chat.v1.conversation.delete") return@collect
                    if (!GrindrPlus.shouldTriggerAntiblock) return@collect
                    val conversationIds = notification.payload
                        ?.optJSONArray("conversationIds") ?: return@collect
                    val conversationIdStrings = (0 until conversationIds.length())
                        .map { index -> conversationIds.getString(index) }
                    val myId = GrindrPlus.myProfileId.toLongOrNull() ?: return@collect
                    val otherProfileId = conversationIdStrings
                        .flatMap { conversationId ->
                            conversationId.split(":").mapNotNull { it.toLongOrNull() }
                        }
                        .firstOrNull { id -> id != myId }
                    if (otherProfileId == null || otherProfileId == myId) {
                        logd("Skipping block/unblock handling for my own profile or no valid profile found")
                        return@collect
                    }
                    try {
                        if (DatabaseHelper.query(
                                "SELECT * FROM blocks WHERE profileId = ?",
                                arrayOf(otherProfileId.toString())
                            ).isNotEmpty()
                        ) {
                            return@collect
                        }
                    } catch (e: Exception) {
                        loge("Error checking if user is blocked: ${e.message}")
                        Logger.writeRaw(e.stackTraceToString())
                    }
                    try {
                        val response = fetchProfileData(otherProfileId.toString())
                        if (handleProfileResponse(otherProfileId,
                                conversationIdStrings.joinToString(","), response)) {
                        }
                    } catch (e: Exception) {
                        loge("Error handling block/unblock request: ${e.message ?: "Unknown error"}")
                        Logger.writeRaw(e.stackTraceToString())
                    }
                }
            }
        }
    }
    private fun fetchProfileData(profileId: String): String {
        val response = GrindrPlus.httpClient.sendRequest(
            url = "https://grindr.mobi/v4/profiles/$profileId",
            method = "GET"
        )
        if (response.isSuccessful) {
            return response.body?.string() ?: "Empty response"
        } else {
            throw Exception("Failed to fetch profile data: ${response.body?.string()}")
        }
    }
    private fun handleProfileResponse(profileId: Long, conversationIds: String, response: String): Boolean {
        try {
            val jsonResponse = JSONObject(response)
            val profilesArray = jsonResponse.optJSONArray("profiles")
            if (profilesArray == null || profilesArray.length() == 0) {
                var displayName = ""
                try {
                    displayName = (DatabaseHelper.query(
                        "SELECT name FROM chat_conversations WHERE conversation_id = ?",
                        arrayOf(conversationIds)
                    ).firstOrNull()?.get("name") as? String)?.takeIf {
                            name -> name.isNotEmpty() } ?: profileId.toString()
                } catch (e: Exception) {
                    loge("Error fetching display name: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                    displayName = profileId.toString()
                }
                displayName = if (displayName == profileId.toString() || displayName == "null")
                { profileId.toString() } else { "$displayName ($profileId)" }
                GrindrPlus.bridgeClient.logBlockEvent(profileId.toString(), displayName, true,
                    GrindrPlus.packageName)
                if (Config.get("anti_block_use_toasts", false) as Boolean) {
                    GrindrPlus.showToast(Toast.LENGTH_LONG, "Blocked by $displayName")
                } else {
                    GrindrPlus.bridgeClient.sendNotificationWithMultipleActions(
                        "Blocked by User",
                        "You have been blocked by user $displayName",
                        10000000 + (profileId % 10000000).toInt(),
                        listOf("Copy ID"),
                        listOf("COPY"),
                        listOf(profileId.toString(), profileId.toString()),
                        BridgeService.CHANNEL_BLOCKS,
                        "Block Notifications",
                        "Notifications when users block you"
                    )
                }
                return true
            } else {
                val profile = profilesArray.getJSONObject(0)
                var displayName = profile.optString("displayName", profileId.toString())
                    .takeIf { it.isNotEmpty() && it != "null" } ?: profileId.toString()
                displayName = if (displayName != profileId.toString()) "$displayName ($profileId)" else displayName
                GrindrPlus.bridgeClient.logBlockEvent(profileId.toString(), displayName, false,
                    GrindrPlus.packageName)
                if (Config.get("anti_block_use_toasts", false) as Boolean) {
                    GrindrPlus.showToast(Toast.LENGTH_LONG, "Unblocked by $displayName")
                } else {
                    GrindrPlus.bridgeClient.sendNotificationWithMultipleActions(
                        "Unblocked by $displayName",
                        "$displayName has unblocked you.",
                        20000000 + (profileId % 10000000).toInt(),
                        listOf("Copy ID"),
                        listOf("COPY"),
                        listOf(profileId.toString()),
                        BridgeService.CHANNEL_UNBLOCKS,
                        "Unblock Notifications",
                        "Notifications when users unblock you"
                    )
                }
                return false
            }
        } catch (e: Exception) {
            loge("Error handling profile response: ${e.message ?: "Unknown error"}")
            Logger.writeRaw(e.stackTraceToString())
            return false
        }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\AntiDetection.kt --- 
package com.grindrplus.hooks
class AntiDetection : Hook(
    "Anti Detection",
    "Hides root, emulator, and environment detections"
) {
    private val grindrMiscClass = "mg.n" // search for '"sdk_gphone", "emulator", "simulator", "google_sdk"'
    private val devicePropertiesCollector = "siftscience.android.DevicePropertiesCollector"
    private val commonUtils = "com.google.firebase.crashlytics.internal.common.CommonUtils"
    private val osData = "com.google.firebase.crashlytics.internal.model.AutoValue_StaticSessionData_OsData"
    override fun init() {
        findClass(grindrMiscClass)
            .hook("O", HookStage.AFTER) { param ->
                param.setResult(false)
            }
        findClass(commonUtils)
            .hook("isRooted", HookStage.BEFORE) { param ->
                param.setResult(false)
            }
        findClass(commonUtils)
            .hook("isEmulator", HookStage.BEFORE) { param ->
                param.setResult(false)
            }
        findClass(commonUtils)
            .hook("isAppDebuggable", HookStage.BEFORE) { param ->
                param.setResult(false)
            }
        findClass(devicePropertiesCollector)
            .hook("existingRWPaths", HookStage.BEFORE) { param ->
                param.setResult(emptyList<String>())
            }
        findClass(devicePropertiesCollector)
            .hook("existingRootFiles", HookStage.BEFORE) { param ->
                param.setResult(emptyList<String>())
            }
        findClass(devicePropertiesCollector)
            .hook("existingRootPackages", HookStage.BEFORE) { param ->
                param.setResult(emptyList<String>())
            }
        findClass(devicePropertiesCollector)
            .hook("existingDangerousProperties", HookStage.BEFORE) { param ->
                param.setResult(emptyList<String>())
            }
        findClass(osData)
            .hookConstructor(HookStage.BEFORE) { param ->
                param.setArg(2, false) // isRooted
            }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\BanManagement.kt --- 
package com.grindrplus.hooks
class BanManagement : Hook(
    "Ban management",
    "Provides comprehensive ban management tools (detailed ban info, etc.)"
) {
    private val authServiceClass = "x5.h" // search for 'v3/users/password-validation'
    private val materialButton = "com.google.android.material.button.MaterialButton"
    private val bannedFragment = "com.grindrapp.android.ui.account.banned.BannedFragment"
    private val deviceUtility = "Ue.m" // search for 'Settings.Secure.getString(context.getContentResolver(), "android_id")'
    private val bannedArgs = "B5.a" // search for 'new StringBuilder("BannedArgs(bannedType=")'
    private var bannedInfo: JSONObject = JSONObject()
    @SuppressLint("DiscouragedApi")
    override fun init() {
        val authService = findClass(authServiceClass)
        RetrofitUtils.hookService(
            authService,
        ) { originalHandler, proxy, method, args ->
            val result = originalHandler.invoke(proxy, method, args)
            val isLogin = args.size > 1 && args[1] != null &&
                    args[1]!!::class.java.name.contains("LoginEmailRequest")
            when {
                isLogin -> {
                    withSuspendResult(args, result) { args, result ->
                        try {
                            handleLoginResult(result)
                        } catch (_: Throwable) {
                            // Ignore exceptions here
                        }
                        return@withSuspendResult result
                    }
                }
            }
            result
        }
        findClass(deviceUtility).hook("g", HookStage.AFTER) { param ->
            val androidId = Config.get("android_device_id", "") as String
            if (androidId.isNotEmpty()) {
                param.setResult(androidId)
            }
        }
        findClass(bannedArgs).hookConstructor(HookStage.AFTER) { param ->
            val args = param.args()
            val json = JSONObject()
            json.put("code", args[0].toString())
            json.put("message", args[1])
            json.put("mail", args[2])
            json.put("phoneNumber", args[3])
            json.put("dialCode", args[4])
            json.put("isBanAutomated", args[5])
            json.put("subReason", args[6])
            bannedInfo = json
        }
        findClass(bannedFragment)
            .hook("onViewCreated", HookStage.AFTER) { param ->
                try {
                    val view = param.args()[0] as View
                    val context = view.context
                    val manageSubscriptionId = context.resources.getIdentifier("manage_subscription", "id", context.packageName)
                    val manageSubscriptionButton = view.findViewById<View>(manageSubscriptionId)
                    val buttonLayoutId = context.resources.getIdentifier("layout_ban_screen_buttons", "id", context.packageName)
                    val buttonLayout = view.findViewById<LinearLayout>(buttonLayoutId)
                    if (manageSubscriptionButton != null && buttonLayout != null) {
                        val primaryButtonStyle = context.resources
                            .getIdentifier("PrimaryButton", "style", context.packageName)
                        val newButton = loadClass(materialButton).getDeclaredConstructor(
                            Context::class.java,
                            loadClass("android.util.AttributeSet"),
                            Int::class.java
                        ).newInstance(context, null, primaryButtonStyle) as View
                        safeCallMethod(newButton, "setLayoutParams", manageSubscriptionButton.layoutParams)
                        safeCallMethod(newButton, "setBackground", safeCallMethod(manageSubscriptionButton, "getBackground"))
                        safeCallMethod(newButton, "setTextColor", safeCallMethod(manageSubscriptionButton, "getTextColors"))
                        safeCallMethod(newButton, "setBackgroundTintList", safeCallMethod(manageSubscriptionButton, "getBackgroundTintList"))
                        try {
                            val horizontalPadding = safeCallMethod(manageSubscriptionButton, "getPaddingLeft") as? Int ?: dpToPx(context, 8)
                            val verticalPadding = dpToPx(context, 14)
                            safeCallMethod(newButton, "setPadding", horizontalPadding, verticalPadding, horizontalPadding, verticalPadding)
                        } catch (e: Exception) {
                            loge("Error copying padding: ${e.message}")
                        }
                        safeCallMethod(newButton, "setCornerRadius", safeCallMethod(manageSubscriptionButton, "getCornerRadius"))
                        safeCallMethod(newButton, "setRippleColor", safeCallMethod(manageSubscriptionButton, "getRippleColor"))
                        safeCallMethod(newButton, "setStrokeColor", safeCallMethod(manageSubscriptionButton, "getStrokeColor"))
                        safeCallMethod(newButton, "setStrokeWidth", safeCallMethod(manageSubscriptionButton, "getStrokeWidth"))
                        safeCallMethod(newButton, "setElevation", safeCallMethod(manageSubscriptionButton, "getElevation"))
                        safeCallMethod(newButton, "setTextAlignment", safeCallMethod(manageSubscriptionButton, "getTextAlignment"))
                        safeCallMethod(newButton, "setGravity", safeCallMethod(manageSubscriptionButton, "getGravity"))
                        safeCallMethod(newButton, "setMinHeight", dpToPx(context, 38))
                        safeCallMethod(newButton, "setText", "Show Ban Details")
                        safeCallMethod(newButton, "setOnClickListener", View.OnClickListener {
                            if (bannedInfo.length() == 0) {
                                Toast.makeText(context, "No ban details available", Toast.LENGTH_SHORT).show()
                            } else {
                                createBanDetailsDialog(context, bannedInfo)
                            }
                        })
                        buttonLayout.addView(newButton)
                    }
                } catch (e: Exception) {
                    loge("BannedFragment: Error in hook: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
    }
    private fun handleLoginResult(result: Any) {
        if (result.isFail()) {
            val body = JSONObject(getObjectField(
                result.getFailValue(), "b") as String)
            if (body.has("reason")) {
                logi("Intercepted a banned response!")
                bannedInfo = body
            } else {
                logw("User is not banned, but failed to login?")
            }
        } else {
            logd("User is not banned, login should be successful")
        }
    }
    private fun createBanDetailsDialog(context: Context, bannedInfo: JSONObject) {
        val message = StringBuilder()
        message.append("Your account has been banned from " +
                "Grindr and the server replied with the following information:\n\n")
        val mappings = mapOf(
            "code" to "Details",
            "message" to "Message",
            "profileId" to "Profile ID",
            "type" to "Type",
            "reason" to "Reason",
            "isBanAutomated" to "Automated Ban",
            "thirdPartyUserIdToShow" to "Third Party User ID",
            "subReason" to "Sub Reason",
            "mail" to "Mail",
            "phoneNumber" to "Phone Number",
            "dialCode" to "Dial Code"
        )
        val isDeviceBan = bannedInfo.optString("code", "").let { code ->
            code.isNotEmpty() && GrindrApiError.isErrorType(
                code.toIntOrNull() ?: code, GrindrApiError.ERR_DEVICE_BANNED)
        }
        mappings.forEach { (key, label) ->
            if (bannedInfo.has(key) && !bannedInfo.isNull(key)) {
                val value = when (key) {
                    "isBanAutomated" -> if (bannedInfo.getBoolean(key)) "Yes" else "No"
                    "code" -> {
                        val codeValue = bannedInfo.getString(key)
                        getErrorDescription(codeValue.toIntOrNull() ?: codeValue)
                    }
                    else -> bannedInfo.getString(key)
                }
                if (value != null && value.isNotEmpty() && value != "null") {
                    message.append("• $label: $value\n")
                }
            }
        }
        if (isDeviceBan) {
            message.append("\nYour device has been banned rather than just your account. " +
                    "This may or may not mean your account is also banned. " +
                    "You can bypass this restriction by generating different device information.")
        }
        val dialog = android.app.AlertDialog.Builder(GrindrPlus.currentActivity)
            .setTitle("Ban Details")
            .setMessage(message.toString())
            .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
        if (isDeviceBan) {
            dialog.setNeutralButton("Generate New Device ID") { _, _ ->
                val uuid = java.util.UUID.randomUUID()
                val newDeviceId = uuid.toString().replace("-", "")
                Config.put("android_device_id", newDeviceId)
                restartGrindr(1500, "New device ID generated. Grindr will restart now.")
            }
        } else {
            dialog.setNeutralButton("Copy JSON") { _, _ ->
                copyToClipboard("Ban Details", bannedInfo.toString(2))
                Toast.makeText(
                    GrindrPlus.currentActivity,
                    "Ban details copied to clipboard",
                    Toast.LENGTH_SHORT
                ).show()
            }
        }
        GrindrPlus.currentActivity?.runOnUiThread {
            dialog.create().show()
        }
    }
    private fun dpToPx(context: Context, dp: Int): Int {
        val density = context.resources.displayMetrics.density
        return (dp * density).toInt()
    }
    private fun safeCallMethod(obj: Any?, methodName: String, vararg args: Any?): Any? {
        if (obj == null) return null
        return try {
            XposedHelpers.callMethod(obj, methodName, *args)
        } catch (e: Exception) {
            loge("Failed to call method: $methodName: ${e.message}")
            null
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\ChatBackupHook.kt --- 
package com.grindrplus.hooks
class ChatBackupHook : Hook(
    "Chat Backup",
    "Backs up chat messages to the GrindrPlus database."
) {
    private val chatMessagesDao = "com.grindrapp.android.persistence.dao.ChatMessagesDao"
    override fun init() {
        findClass(chatMessagesDao).hook("insertMessage", HookStage.AFTER) { param ->
            if (!isHookEnabled()) return@hook
            val message = param.arg<Any>(0)
            if (message == null) {
                Logger.w("ChatMessage object was null, cannot backup.", LogSource.HOOK)
                return@hook
            }
            try {
                val message_id = getObjectField(message, "messageId") as String
                val conversation_id = getObjectField(message, "conversationId") as String
                val sender = getObjectField(message, "senderId").toString()
                val body = getObjectField(message, "body") as? String ?: ""
                val timestamp = getObjectField(message, "timestamp") as Long
                val type = getObjectField(message, "type") as String
                val chatBackup = ChatBackup(
                    message_id = message_id,
                    conversation_id = conversation_id,
                    sender = sender,
                    body = body,
                    timestamp = timestamp,
                    type = type
                )
                GrindrPlus.executeAsync {
                    try {
                        GrindrPlus.database.chatBackupDao().insert(chatBackup)
                        Logger.d("Successfully backed up message $message_id", LogSource.HOOK)
                    } catch (e: Exception) {
                        Logger.e("Database error backing up message: ${e.message}", LogSource.HOOK)
                    }
                }
            } catch (e: Exception) {
                Logger.e("Failed to extract chat message: ${e.message}", LogSource.HOOK)
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\ChatIndicators.kt --- 
package com.grindrplus.hooks
class ChatIndicators : Hook(
    "Chat indicators",
    "Don't show chat markers / indicators to others"
) {
    private val chatRestService = "com.grindrapp.android.chat.data.datasource.api.service.ChatRestService"
    private val blacklistedPaths = setOf(
        "v4/chatstatus/typing"
    )
    override fun init() {
        val chatRestServiceClass = findClass(chatRestService)
        val methodBlacklist = blacklistedPaths.mapNotNull {
            RetrofitUtils.findPOSTMethod(chatRestServiceClass, it)?.name
        }
        findClass(RETROFIT_NAME)
            .hook("create", HookStage.AFTER) { param ->
                val service = param.getResult()
                if (service != null && chatRestServiceClass.isAssignableFrom(service.javaClass)) {
                    param.setResult(createServiceProxy(
                        service,
                        chatRestServiceClass,
                        methodBlacklist.toTypedArray()
                    ))
                }
            }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\ChatTerminal.kt --- 
package com.grindrplus.hooks
class ChatTerminal : Hook(
    "Chat terminal",
    "Create a chat terminal to execute commands"
) {
    private val chatMessageHandler = "J6.k" // search for '(chatMessageMetaData, "chatMessageMetaData")'
    override fun init() {
        findClass(chatMessageHandler).hook("l", HookStage.BEFORE) { param ->
            val message = getObjectField(param.arg(0), "chatMessage")
            val content = getObjectField(message, "content")
            val sender = getObjectField(content, "sender") as String
            val recipient = getObjectField(content, "recipient") as String
            val messageBody = JSONObject(getObjectField(content, "body") as String)
            if (!messageBody.has("text")) return@hook // Ignore non-text messages
            val text = messageBody.getString("text")
            val commandPrefix = (Config.get("command_prefix", "/") as String)
            if (text.startsWith(commandPrefix)) {
                param.setResult(null) // Don't send the command to the chat
                CommandHandler(sender, recipient).handle(text.substring(1))
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\DisableAnalytics.kt --- 
package com.grindrplus.hooks
class DisableAnalytics : Hook(
    "Disable analytics",
    "Disable Grindr analytics (data collection)"
) {
    override fun init() {
        // Braze
        findClass("com.braze.Braze\$Companion")
            // See https://braze-inc.github.io/braze-android-sdk/kdoc/braze-android-sdk/com.braze/-braze/-companion/outbound-network-requests-offline.html
            .hook("setOutboundNetworkRequestsOffline", HookStage.BEFORE) {
                param -> param.setArg(0, true)
            }
        // Digital Turbine
        findClass("com.fyber.inneractive.sdk.network.i")
            .hook("a", HookStage.BEFORE) {
                param -> param.setResult(null)
            }
        // Google Analytics
        findClass("com.google.firebase.analytics.FirebaseAnalytics")
            .hook("setAnalyticsCollectionEnabled", HookStage.BEFORE) { param ->
                param.setArg(0, false)
            }
        // Google Crashlytics
        findClass("com.google.firebase.crashlytics.FirebaseCrashlytics")
            .hook("setCrashlyticsCollectionEnabled", HookStage.BEFORE) { param ->
                param.setArg(0, false)
            }
        // Ironsource
        findClass("com.ironsource.mediationsdk.server.ServerURL")
            .hook("getRequestURL", HookStage.BEFORE) {
                param -> param.setResult(null)
            }
        // Liftoff (Vungle)
        findClass("com.vungle.ads.internal.network.VungleApiClient")
            .hook("config", HookStage.BEFORE) {
                param -> param.setResult(null)
            }
        // Unity
        findClass("com.unity3d.services.ads.UnityAdsImplementation")
            .hook("getInstance", HookStage.BEFORE) {
                param -> param.setResult(null)
            }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\DisableBoosting.kt --- 
package com.grindrplus.hooks
class DisableBoosting : Hook(
    "Disable boosting",
    "Get rid of all upsells related to boosting"
) {
    private val drawerProfileUiState = "Lg.h\$a" // search for 'DrawerProfileUiState(showBoostMeButton='
    private val radarUiModel = "Gd.a\$a" // search for 'RadarUiModel(boostButton='
    private val fabUiModel = "com.grindrapp.android.boost2.presentation.model.FabUiModel"
    private val rightNowMicrosFabUiModel =
        "com.grindrapp.android.rightnow.presentation.model.RightNowMicrosFabUiModel"
    private val boostStateClass =
        "com.grindrapp.android.ui.drawer.model.MicrosDrawerItemState\$Unavailable"
    override fun init() {
        findClass(drawerProfileUiState).hookConstructor(HookStage.AFTER) { param ->
            setObjectField(param.thisObject(), "a", false) // showBoostMeButton
            setObjectField(
                param.thisObject(),
                "e",
                newInstance(findClass(boostStateClass))
            ) // boostButtonState
            setObjectField(
                param.thisObject(),
                "f",
                newInstance(findClass(boostStateClass))
            ) // roamButtonState
            setObjectField(param.thisObject(), "c", false) // showRNBoostCard
            setObjectField(param.thisObject(), "i", null) // showDayPassItem
            setObjectField(param.thisObject(), "j", null) // unlimitedWeeklySubscriptionItem
            setObjectField(param.thisObject(), "s", false) // isRightNowAvailable
        }
        findClass(radarUiModel).hookConstructor(HookStage.AFTER) { param ->
            setObjectField(param.thisObject(), "a", null) // boostButton
            setObjectField(param.thisObject(), "b", null) // roamButton
        }
        findClass(fabUiModel).hookConstructor(HookStage.AFTER) { param ->
            setObjectField(param.thisObject(), "isVisible", false) // isVisible
        }
        findClass(rightNowMicrosFabUiModel).hookConstructor(HookStage.AFTER) { param ->
            setObjectField(param.thisObject(), "isBoostFabVisible", false) // isBoostFabVisible
            setObjectField(param.thisObject(), "isClickEnabled", false) // isClickEnabled
            setObjectField(param.thisObject(), "isFabVisible", false) // isFabVisible
        }
        // the two anonymous functions that get called to invoke the annoying tooltip
        // respectively: showRadarTooltip.<anonymous> and showTapsAndViewedMePopup
        // search for:
        //   'com.grindrapp.android.ui.home.HomeActivity$showTapsAndViewedMePopup$1$1'
        //   'com.grindrapp.android.ui.home.HomeActivity.showTapsAndViewedMePopup.<anonymous> (HomeActivity.kt'
        //   'com.grindrapp.android.ui.home.HomeActivity$subscribeForBoostRedeem$1'
        //   'com.grindrapp.android.ui.home.HomeActivity.showTapsAndViewedMePopup.<anonymous>.<anonymous> (HomeActivity.kt'
        listOf("Vg.w0", "Vg.y0", "Vg.C0", "Vg.x0").forEach {
            findClass(it).hook("invoke", HookStage.BEFORE) { param ->
                param.setResult(null)
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\DisableShuffle.kt --- 
package com.grindrplus.hooks
class DisableShuffle : Hook(
    "Disable shuffle",
    "Forcefully disable the shuffle feature"
) {
    private val viewState = "com.grindrapp.android.ui.browse.v\$j" // search for 'ViewState(isRefreshing='
    private val shuffleUiState = "com.grindrapp.android.ui.browse.v\$g" // search for 'ShuffleUiState(isShuffleEnabled='
    override fun init() {
        findClass(shuffleUiState).hookConstructor(HookStage.AFTER) { param ->
            setObjectField(param.thisObject(), "a", false) // shuffleEnabled
            setObjectField(param.thisObject(), "b", false) // isShuffled
            setObjectField(param.thisObject(), "c", false) // isShuffling
            setObjectField(param.thisObject(), "d", false) // showShuffleTooltip
            setObjectField(param.thisObject(), "f", false) // isShuffleTopBarVisible
            setObjectField(param.thisObject(), "g", false) // showShuffleUpsell
            setObjectField(param.thisObject(), "h", true)  // isDisabledByFavorites
            setObjectField(param.thisObject(), "i", true)  // isDisabledByRightNow
            setObjectField(param.thisObject(), "j", false) // reshowTopBarAfterTurningOffBlockingFilters
        }
        findClass(viewState).hookConstructor(HookStage.AFTER) { param ->
            setObjectField(param.thisObject(), "b", false) // isRightNowUpsellBannerVisible
            setObjectField(param.thisObject(), "d", false) // shouldShowFloatingRatingBanner
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\DisableUpdates.kt --- 
package com.grindrplus.hooks
class DisableUpdates : Hook(
    "Disable updates",
    "Disable forced updates"
) {
    private val versionInfoEndpoint =
        "https://raw.githubusercontent.com/R0rt1z2/GrindrPlus/master/version.json"
    private val appUpdateInfo = "com.google.android.play.core.appupdate.AppUpdateInfo"
    private val appUpdateZzm = "com.google.android.play.core.appupdate.zzm" // search for 'requestUpdateInfo(%s)'
    private val appUpgradeManager = "Ma.s" // search for 'Uri.parse("market://details?id=com.grindrapp.android");'
    private val appConfiguration = "com.grindrapp.android.platform.config.AppConfiguration"
    private var versionCode: Int = 0
    private var versionName: String = ""
    override fun init() {
        findClass(appUpdateInfo)
            .hook("updateAvailability", HookStage.BEFORE) { param ->
                param.setResult(1)
            }
        findClass(appUpdateInfo)
            .hook("isUpdateTypeAllowed", HookStage.BEFORE) { param ->
                param.setResult(false)
            }
        findClass(appUpgradeManager) // showDeprecatedVersionDialog()
            .hook("a", HookStage.BEFORE) { param ->
                param.setResult(null)
            }
        findClass(appUpdateZzm) // requestUpdateInfo()
            .hook("zza", HookStage.BEFORE) { param ->
                param.setResult(null)
            }
        Thread {
            fetchLatestVersionInfo()
        }.start()
    }
    private fun fetchLatestVersionInfo() {
        val client = OkHttpClient()
        val request = Request.Builder()
            .url(versionInfoEndpoint).build()
        try {
            val response = client.newCall(request).execute()
            if (response.isSuccessful) {
                val jsonData = response.body?.string()
                if (jsonData != null) {
                    val json = JSONObject(jsonData)
                    versionCode = json.getInt("versionCode")
                    versionName = json.getString("versionName")
                    logd("Successfully fetched version info: $versionName ($versionCode)")
                    updateVersionInfo()
                }
            } else {
                loge("Failed to fetch version info: ${response.message}")
            }
        } catch (e: Exception) {
            loge("Error fetching version info: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
        }
    }
    private fun compareVersions(v1: String, v2: String): Int {
        val parts1 = v1.split(".").map { it.toInt() }
        val parts2 = v2.split(".").map { it.toInt() }
        val maxLength = maxOf(parts1.size, parts2.size)
        for (i in 0 until maxLength) {
            val part1 = if (i < parts1.size) parts1[i] else 0
            val part2 = if (i < parts2.size) parts2[i] else 0
            if (part1 != part2) return part1.compareTo(part2)
        }
        return 0
    }
    private fun updateVersionInfo() {
        val currentVersion = GrindrPlus.context.packageManager.getPackageInfo(
            GrindrPlus.context.packageName,
            0
        ).versionName.toString()
        if (compareVersions(versionName, currentVersion) > 0) {
            findClass(appConfiguration).hookConstructor(HookStage.AFTER) { param ->
                setObjectField(param.thisObject(), "d", "$versionName.$versionCode")
            }
            findClass(GrindrPlus.userAgent).hookConstructor(HookStage.AFTER) { param ->
                param.thisObject().javaClass.declaredFields.forEach { field ->
                    field.isAccessible = true
                    val value = field.get(param.thisObject())
                    if (value is String && value.startsWith("grindr3/")) {
                        field.set(param.thisObject(), "grindr3/$versionName.$versionCode;$versionCode;")
                        return@forEach
                    }
                }
            }
        } else {
            logd("Current version is up-to-date: $versionName ($versionCode)")
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\EmptyCalls.kt --- 
package com.grindrplus.hooks
class EmptyCalls : Hook(
    "Video calls",
    "Allow video calls on empty chats"
) {
    private val individualChatNavViewModel = "W6.e0" // search for 'com.grindrapp.android.chat.presentation.viewmodel.IndividualChatNavViewModel'
    override fun init() {
        findClass(individualChatNavViewModel) // isTalkBefore()
            .hook("G",  HookStage.BEFORE) { param ->
                param.setResult(true)
            }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\EnableUnlimited.kt --- 
package com.grindrplus.hooks
class EnableUnlimited : Hook(
    "Enable unlimited",
    "Enable Grindr Unlimited features"
) {
    private val profileViewState = "com.grindrapp.android.ui.profileV2.model.ProfileViewState"
    private val profileModel = "com.grindrapp.android.persistence.model.Profile"
    private val tabLayoutClass = "com.google.android.material.tabs.TabLayout"
    private val paywallUtils = "of.c" // search for 'app_restart_required'
    private val persistentAdBannerContainer = "N7.M3" // search for 'GrindrAdContainer grindrAdContainer = (GrindrAdContainer) ViewBindings.findChildViewById(view, R.id.persistent_banner_ad_container);'
    private val subscribeToInterstitialsList = listOf(
        "P6.L\$a" // search for 'com.grindrapp.android.chat.presentation.ui.ChatActivityV2$subscribeToInterstitialAds$1$1$1'
    )
    private val viewsToHide = mapOf(
        "com.grindrapp.android.ui.tagsearch.ProfileTagCascadeFragment\$c" to listOf("upsell_bottom_bar"), // search for 'bind(Landroid/view/View;)Lcom/grindrapp/android/databinding/ProfileTagCascadeFragmentBinding;'
        "com.grindrapp.android.ui.browse.CascadeFragment\$b" to listOf("upsell_bottom_bar", "shuffle_top_bar", "floating_rating_banner", "micros_fab", "right_now_progress_compose_view"), // search for '"bind(Landroid/view/View;)Lcom/grindrapp/android/databinding/FragmentBrowseCascadeBinding;"'
        "com.grindrapp.android.ui.home.HomeActivity\$g" to listOf("persistentAdBannerContainer"), // search for 'ViewBindings.findChildViewById(inflate, R.id.activity_home_content)) != null) {'
        "com.grindrapp.android.ui.drawer.DrawerProfileFragment\$e" to listOf("plans_title", "store_in_profile_drawer_card", "sideDrawerBoostContainer", "drawer_profile_offer_card"), // search for '"bind(Landroid/view/View;)Lcom/grindrapp/android/databinding/DrawerProfileBinding;"'
        "com.grindrapp.android.radar.presentation.ui.RadarFragment\$c" to listOf("micros_fab", "right_now_fabs_container") // search for 'bind(Landroid/view/View;)Lcom/grindrapp/android/databinding/FragmentRadarBinding;'
    )
    override fun init() {
        val userSessionClass = findClass(GrindrPlus.userSession)
        userSessionClass.hook( // isNoXtraUpsell()
            "r", HookStage.BEFORE // search for '()) ? false : true;' in userSession
        ) { param ->
            param.setResult(true)
        }
        userSessionClass.hook( // isNoPlusUpsell()
            "f", HookStage.BEFORE // search for 'Role.PLUS, Role.FREE_PLUS' in userSession
        ) { param ->
            param.setResult(true)
        }
        userSessionClass.hook( // isFree()
            "F", HookStage.BEFORE // search for '.isEmpty();' in userSession
        ) { param ->
            param.setResult(false)
        }
        userSessionClass.hook( // isFreeXtra()
            "B", HookStage.BEFORE // search for 'Role.XTRA, Role.FREE_XTRA' in userSession
        ) { param ->
            param.setResult(false)
        }
        userSessionClass.hook( // isFreeUnlimited()
            "J", HookStage.BEFORE // search for 'Role.UNLIMITED, Role.FREE_UNLIMITED' in userSession
        ) { param ->
            param.setResult(true)
        }
        userSessionClass.hook( // isFreeUnlimited()
            "L", HookStage.BEFORE // search for '(set, Role.XTRA)' in userSession
        ) { param ->
            param.setResult(true)
        }
        subscribeToInterstitialsList.forEach {
            findClass(it)
                .hook("emit", HookStage.BEFORE) { param ->
                    val modelName = param.arg<Any>(0)::class.java.name
                    if (!modelName.contains("NoInterstitialCreated")
                        && !modelName.contains("OnInterstitialDismissed")
                    ) {
                        param.setResult(null)
                    }
                }
        }
        findClass(tabLayoutClass).hook("addTab", HookStage.AFTER) { param ->
            val blockedTabs = mapOf(
                4 to "Store"
            )
            val tab = param.arg<Any>(0)
            val position = getObjectField(tab, "position") as? Int ?: -1
            logd("Trying to add tab at position $position")
            if (position in blockedTabs.keys) {
                val tabName = blockedTabs[position] ?: "Unknown"
                val tabView = getObjectField(tab, "view") as? View
                tabView?.let { view ->
                    (view.parent as? ViewGroup)?.removeView(view)
                    logi("Removed tab '$tabName' at position $position")
                }
            }
        }
        viewsToHide.forEach { (className, viewIds) ->
            findClass(className).hook(
                "invoke", HookStage.AFTER
            ) { param ->
                if (param.args().isNotEmpty()) {
                    val rootView = param.arg<View>(0)
                    hideViews(rootView, viewIds)
                }
            }
        }
        findClass(persistentAdBannerContainer).hook("a", HookStage.BEFORE) { param ->
            if (param.args().isNotEmpty()) {
                val rootView = param.arg<View>(0)
                hideViews(rootView, listOf("persistent_banner_ad_container"))
            }
        }
        setOf("isBlockable", "component60").forEach {
            findClass(profileModel).hook(it, HookStage.BEFORE) { param ->
                param.setResult(true)
            }
        }
        findClass(paywallUtils).hook("d", HookStage.BEFORE) { param ->
            val stackTrace = Thread.currentThread().stackTrace.dropWhile {
                !it.toString().contains("LSPHooker") }.drop(1).joinToString("\n")
            android.app.AlertDialog.Builder(GrindrPlus.currentActivity)
                .setTitle("Paywalled Feature Detected")
                .setMessage(
                    "This feature is server-enforced and cannot be bypassed in this version.\n\n" +
                            "If you think this is a mistake, please report it to the developer. " +
                            "You can copy the stack trace below to help with troubleshooting."
                )
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setCancelable(false)
                .setNegativeButton("Copy Stack Trace") { _, _ ->
                    copyToClipboard(
                        "Stack trace",
                        stackTrace
                    )
                }
                .setPositiveButton("Ok", null)
                .show()
            param.setResult(null)
        }
        findClass(profileViewState).hook("isChatPaywalled", HookStage.BEFORE) { param ->
            param.setResult(false)
        }
    }
    @SuppressLint("DiscouragedApi")
    private fun hideViews(rootView: View, viewIds: List<String>) {
        viewIds.forEach { viewId ->
            try {
                val id = rootView.resources.getIdentifier(
                    viewId, "id", "com.grindrapp.android")
                if (id > 0) {
                    val view = rootView.findViewById<View>(id)
                    if (view != null) {
                        logd("View with ID: $viewId found and will be hidden")
                        val params = view.layoutParams
                        params.height = 0
                        view.layoutParams = params
                        view.visibility = View.GONE
                    }
                } else {
                    logd("View with ID: $viewId not found")
                }
            } catch (e: Exception) {
                loge("Error hiding view with ID: $viewId: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\ExpiringMedia.kt --- 
package com.grindrplus.hooks
class ExpiringMedia : Hook(
    "Expiring media",
    "Allow unlimited photo/video viewing and save media permanently"
) {
    private val classMap = mapOf(
        "expiringVideoBody" to "com.grindrapp.android.chat.model.ExpiringVideoBody",
        "expiringImageBody" to "com.grindrapp.android.chat.model.ExpiringImageBody",
        "expiringImageBodyUiData" to "com.grindrapp.android.chat.presentation.model.BodyUiData\$ExpiringImageBodyUiData",
        "expiringStatusResponse" to "com.grindrapp.android.chat.api.model.ExpiringPhotoStatusResponse"
    )
    private val coroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)
    private val filePathCache = mutableMapOf<Long, String>()
    override fun init() {
        findClass(classMap["expiringImageBodyUiData"]!!)
            .hook("hasViewsRemaining", HookStage.BEFORE) { param ->
                param.setResult(true)
            }
        findClass(classMap["expiringImageBody"]!!)
            .hook("getDuration", HookStage.BEFORE) { param ->
                param.setResult(Long.MAX_VALUE)
            }
        findClass(classMap["expiringImageBody"]!!)
            .hook("getViewsRemaining", HookStage.BEFORE) { param ->
                param.setResult(Int.MAX_VALUE)
            }
        findClass(classMap["expiringVideoBody"]!!)
            .hook("getMaxViews", HookStage.BEFORE) { param ->
                param.setResult(Int.MAX_VALUE)
            }
        findClass(classMap["expiringVideoBody"]!!)
            .hook("getViewsRemaining", HookStage.BEFORE) { param ->
                param.setResult(Int.MAX_VALUE)
            }
        findClass(classMap["expiringStatusResponse"]!!)
            .hook("getAvailable", HookStage.BEFORE) { param ->
                param.setResult(Int.MAX_VALUE)
            }
        findClass(classMap["expiringStatusResponse"]!!)
            .hook("getTotal", HookStage.BEFORE) { param ->
                param.setResult(Int.MAX_VALUE)
            }
        findClass(classMap["expiringImageBody"]!!)
            .hook("getUrl", HookStage.AFTER) { param ->
                handleGetUrl(param, MediaType.IMAGE)
            }
        findClass(classMap["expiringVideoBody"]!!)
            .hook("getUrl", HookStage.AFTER) { param ->
                handleGetUrl(param, MediaType.VIDEO)
            }
    }
    private fun handleGetUrl(param: HookAdapter<*>, mediaType: MediaType) {
        val mediaId = getObjectField(param.thisObject(), "mediaId") as Long
        val originalUrl = getObjectField(param.thisObject(), "url")?.toString()
        val mediaTypeStr = if (mediaType == MediaType.IMAGE) "photo" else "video"
        filePathCache[mediaId]?.let { cachedPath ->
            logd("Using cached $mediaTypeStr path: $cachedPath")
            param.setResult(cachedPath)
            return
        }
        MediaUtils.getMediaFileUrl(mediaId, mediaType)?.let { existingFilePath ->
            logd("Using existing saved $mediaTypeStr: $existingFilePath")
            filePathCache[mediaId] = existingFilePath
            param.setResult(existingFilePath)
            return
        }
        if (!originalUrl.isNullOrEmpty() && !originalUrl.startsWith("file://")) {
            coroutineScope.launch {
                try {
                    logd("Downloading $mediaTypeStr from URL: ${originalUrl.take(50)}...")
                    MediaUtils.downloadMedia(originalUrl).fold(
                        onSuccess = { mediaData ->
                            logi("$mediaTypeStr downloaded: ${mediaData.size} bytes")
                            saveMediaAndUpdateUrl(param, mediaId, mediaData, mediaType)
                        },
                        onFailure = { error ->
                            loge("Failed to download $mediaTypeStr: ${error.message}")
                            param.setResult(originalUrl)
                        }
                    )
                } catch (e: Exception) {
                    loge("Error processing expiring $mediaTypeStr: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                    param.setResult(originalUrl)
                }
            }
        }
    }
    private suspend fun saveMediaAndUpdateUrl(
        param: HookAdapter<*>,
        mediaId: Long,
        mediaData: ByteArray,
        mediaType: MediaType
    ) {
        val mediaTypeStr = if (mediaType == MediaType.IMAGE) "photo" else "video"
        val fileExtension = if (mediaType == MediaType.IMAGE) "jpg" else "mp4"
        MediaUtils.saveMedia(mediaId, mediaData, mediaType, fileExtension).fold(
            onSuccess = { filePath ->
                logi("Saved $mediaTypeStr permanently for mediaId: $mediaId")
                filePathCache[mediaId] = filePath
                withContext(Dispatchers.Main) {
                    param.setResult(filePath)
                }
            },
            onFailure = { error ->
                loge("Failed to save $mediaTypeStr: ${error.message}")
                val originalUrl = getObjectField(param.thisObject(), "url")?.toString()
                if (!originalUrl.isNullOrEmpty()) {
                    withContext(Dispatchers.Main) {
                        param.setResult(originalUrl)
                    }
                }
            }
        )
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\Favorites.kt --- 
package com.grindrplus.hooks
class Favorites : Hook(
    "Favorites",
    "Customize layout for the favorites tab"
) {
    private val recyclerViewLayoutParams =
        "androidx.recyclerview.widget.RecyclerView\$LayoutParams"
    private val favoritesFragment = "com.grindrapp.android.favorites.presentation.ui.FavoritesFragment"
    override fun init() {
        val recyclerViewLayoutParamsConstructor = findClass(recyclerViewLayoutParams)
            .getDeclaredConstructor(Int::class.java, Int::class.java)
        findClass(favoritesFragment)
            .hook("onViewCreated", HookStage.AFTER) { param ->
                val columnsNumber = (Config.get("favorites_grid_columns", 3) as Number).toInt()
                val view = param.arg<View>(0)
                val recyclerView = view.findViewById<View>(
                    Utils.getId(
                        "fragment_favorite_recycler_view",
                        "id", GrindrPlus.context
                    )
                )
                val gridLayoutManager = callMethod(
                    recyclerView, "getLayoutManager"
                )
                callMethod(gridLayoutManager, "setSpanCount", columnsNumber)
                val adapter = callMethod(recyclerView, "getAdapter")
                adapter::class.java
                    .hook("onBindViewHolder", HookStage.AFTER) { param ->
                        val size = GrindrPlus.context
                            .resources.displayMetrics.widthPixels / columnsNumber
                        val rootLayoutParams = recyclerViewLayoutParamsConstructor
                            ?.newInstance(size, size) as? ViewGroup.LayoutParams
                        val itemView = getObjectField(
                            param.arg(
                                0
                            ), "itemView"
                        ) as View
                        itemView.layoutParams = rootLayoutParams
                        val distanceTextView =
                            itemView.findViewById<TextView>(
                                Utils.getId(
                                    "profile_distance", "id", GrindrPlus.context
                                )
                            )
                        var linearLayout = distanceTextView.parent as LinearLayout
                        linearLayout.orientation = LinearLayout.VERTICAL
                        linearLayout.children.forEach { child ->
                            child.layoutParams = LinearLayout.LayoutParams(
                                LinearLayout.LayoutParams.MATCH_PARENT,
                                LinearLayout.LayoutParams.WRAP_CONTENT
                            )
                        }
                        distanceTextView.gravity = Gravity.START
                        val profileOnlineNowIcon = itemView.findViewById<ImageView>(
                            Utils.getId(
                                "profile_online_now_icon",
                                "id", GrindrPlus.context
                            )
                        )
                        val profileLastSeen = itemView.findViewById<TextView>(
                            Utils.getId("profile_last_seen", "id", GrindrPlus.context)
                        )
                        val lastSeenLayoutParams = profileLastSeen
                            .layoutParams as LinearLayout.LayoutParams
                        if (profileOnlineNowIcon.isGone) {
                            lastSeenLayoutParams.topMargin = 0
                        } else {
                            lastSeenLayoutParams.topMargin = TypedValue.applyDimension(
                                TypedValue.COMPLEX_UNIT_DIP, 5f,
                                GrindrPlus.context.resources.displayMetrics
                            ).roundToInt()
                        }
                        profileLastSeen.layoutParams = lastSeenLayoutParams
                        val profileNoteIcon = itemView.findViewById<ImageView>(
                            Utils.getId(
                                "profile_note_icon",
                                "id", GrindrPlus.context
                            )
                        )
                        val profileDisplayName = itemView.findViewById<TextView>(
                            Utils.getId(
                                "profile_display_name",
                                "id", GrindrPlus.context
                            )
                        )
                        val displayNameLayoutParams = profileDisplayName
                            .layoutParams as LinearLayout.LayoutParams
                        if (profileNoteIcon.isGone) {
                            displayNameLayoutParams.topMargin = 0
                        } else {
                            displayNameLayoutParams.topMargin = TypedValue.applyDimension(
                                TypedValue.COMPLEX_UNIT_DIP, 4f,
                                GrindrPlus.context.resources.displayMetrics
                            ).roundToInt()
                        }
                        profileDisplayName.layoutParams = displayNameLayoutParams
                    }
            }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\FeatureGranting.kt --- 
package com.grindrplus.hooks
class FeatureGranting : Hook(
    "Feature granting",
    "Grant all Grindr features"
) {
    private val isFeatureFlagEnabled = "Hc.d" // search for 'implements IsFeatureFlagEnabled {'
    private val upsellsV8Model = "com.grindrapp.android.model.UpsellsV8"
    private val insertsModel = "com.grindrapp.android.model.Inserts"
    private val settingDistanceVisibilityViewModel =
        "com.grindrapp.android.ui.settings.distance.a\$e" // search for 'UiState(distanceVisibility='
    private val featureModel = "com.grindrapp.android.usersession.model.Feature"
    private val tapModel = "com.grindrapp.android.taps.model.Tap"
    private val tapInboxModel = "com.grindrapp.android.taps.data.model.TapsInboxEntity"
    private val featureManager = FeatureManager()
    override fun init() {
        initFeatures()
        findClass(isFeatureFlagEnabled).hook("a", HookStage.BEFORE) { param ->
            val flagKey = callMethod(param.args()[0], "toString") as String
            if (featureManager.isManaged(flagKey)) {
                param.setResult(featureManager.isEnabled(flagKey))
            }
        }
        findClass(featureModel).hook("isGranted", HookStage.BEFORE) { param ->
            val disallowedFeatures = setOf("DisableScreenshot")
            val feature = callMethod(param.thisObject(), "toString") as String
            param.setResult(feature !in disallowedFeatures)
        }
        findClass(settingDistanceVisibilityViewModel)
            .hookConstructor(HookStage.BEFORE) { param ->
                param.setArg(4, false) // hidePreciseDistance
            }
        listOf(upsellsV8Model, insertsModel).forEach { model ->
            findClass(model)
                .hook("getMpuFree", HookStage.BEFORE) { param ->
                    param.setResult(0)
                }
            findClass(model)
                .hook("getMpuXtra", HookStage.BEFORE) { param ->
                    param.setResult(0)
                }
        }
        listOf(tapModel, tapInboxModel).forEach { model ->
            findClass(model).hook("isViewable", HookStage.BEFORE) { param ->
                param.setResult(true)
            }
        }
    }
    private fun initFeatures() {
        featureManager.add(Feature("PasswordComplexity", false))
        featureManager.add(Feature("TimedBans", false))
        featureManager.add(Feature("GenderFlag", true))
        featureManager.add(Feature("ForceApplovinOptOut", true))
        featureManager.add(Feature("RewardedAdViewedMeFeatureFlag", false))
        featureManager.add(Feature("ChatInterstitialFeatureFlag", false))
        featureManager.add(Feature("SideDrawerDeeplinkKillSwitch", true))
        featureManager.add(Feature("SponsoredRoamKillSwitch", true))
        featureManager.add(Feature("UnifiedProfileAvatarFeatureFlag", true))
        featureManager.add(Feature("ApproximateDistanceFeatureFlag", false))
        featureManager.add(Feature("DoxyPEP", true))
        featureManager.add(Feature("CascadeRewriteFeatureFlag", false))
        featureManager.add(Feature("AdsLogs", false))
        featureManager.add(Feature("NonChatEnvironmentAdBannerFeatureFlag", false))
        featureManager.add(Feature("PersistentAdBannerFeatureFlag", false))
        featureManager.add(Feature("ClientTelemetryTracking", false))
        featureManager.add(Feature("LTOAds", false))
        featureManager.add(Feature("SponsorProfileAds", false))
        featureManager.add(Feature("ConversationAds", false))
        featureManager.add(Feature("InboxNativeAds", false))
        featureManager.add(Feature("ReportingLagTime", false))
        featureManager.add(Feature("MrecNewFlow", false))
        featureManager.add(Feature("RunningOnEmulatorFeatureFlag", false))
        featureManager.add(Feature("BannerNewFlow", false))
        featureManager.add(Feature("CalendarUi", true))
        featureManager.add(Feature("CookieTap", Config.get("enable_cookie_tap", false, true) as Boolean))
        featureManager.add(Feature("VipFlag", Config.get("enable_vip_flag", false, true) as Boolean))
        featureManager.add(Feature("PositionFilter", true))
        featureManager.add(Feature("AgeFilter", true))
        featureManager.add(Feature("BanterFeatureGate", false))
        featureManager.add(Feature("TakenOnGrindrWatermarkFlag", false))
        featureManager.add(Feature("gender-filter", true))
        featureManager.add(Feature("enable-chat-summaries", true))
        featureManager.add(Feature("enable-mutual-taps-no-paywall", !(Config.get("enable_interest_section", true, true) as Boolean)))
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\LocalSavedPhrases.kt --- 
package com.grindrplus.hooks
class LocalSavedPhrases : Hook(
    "Local saved phrases",
    "Save unlimited phrases locally"
) {
    private val phrasesRestService = "x5.k" // search for 'v3/me/prefs'
    private val createSuccessResult = "xb.a\$b" // search for 'Success(successValue='
    private val chatRestService = "com.grindrapp.android.chat.data.datasource.api.service.ChatRestService"
    private val addSavedPhraseResponse =
        "com.grindrapp.android.chat.api.model.AddSavedPhraseResponse"
    private val phrasesResponse = "com.grindrapp.android.model.PhrasesResponse"
    private val phraseModel = "com.grindrapp.android.persistence.model.Phrase"
    override fun init() {
        val chatRestServiceClass = findClass(chatRestService)
        val createSuccess = findClass(createSuccessResult).constructors.firstOrNull() ?: return
        val phrasesRestServiceClass = findClass(phrasesRestService)
        findClass(RETROFIT_NAME).hook("create", HookStage.AFTER) { param ->
            val service = param.getResult()
            if (service != null) {
                param.setResult(when {
                    chatRestServiceClass.isAssignableFrom(service.javaClass) ->
                        createChatRestServiceProxy(service, createSuccess)
                    phrasesRestServiceClass.isAssignableFrom(service.javaClass) ->
                        createPhrasesRestServiceProxy(service, createSuccess)
                    else -> service
                })
            }
        }
    }
    private fun createChatRestServiceProxy(
        originalService: Any,
        createSuccess: Constructor<*>
    ): Any {
        val invocationHandler = Proxy.getInvocationHandler(originalService)
        return Proxy.newProxyInstance(
            originalService.javaClass.classLoader,
            arrayOf(findClass(chatRestService))
        ) { proxy, method, args ->
            when {
                method.isPOST("v3/me/prefs/phrases") -> {
                    val phrase = getObjectField(args[0], "phrase") as String
                    runBlocking {
                        val index = getCurrentPhraseIndex() + 1
                        addPhrase(index, phrase, 0, System.currentTimeMillis())
                        val response = findClass(addSavedPhraseResponse).constructors.first()
                            ?.newInstance(index.toString())
                        createSuccess.newInstance(response)
                    }
                }
                method.isDELETE("v3/me/prefs/phrases/{id}") -> {
                    runBlocking {
                        val index = getCurrentPhraseIndex()
                        deletePhrase(index)
                        createSuccess.newInstance(Unit)
                    }
                }
                method.isPOST("v4/phrases/frequency/{id}") -> {
                    runBlocking {
                        val index = getCurrentPhraseIndex()
                        val phrase = getPhrase(index)
                        if (phrase != null) {
                            updatePhrase(
                                index,
                                phrase.text,
                                phrase.frequency + 1,
                                System.currentTimeMillis()
                            )
                        }
                        createSuccess.newInstance(Unit)
                    }
                }
                else -> invocationHandler.invoke(proxy, method, args)
            }
        }
    }
    private fun createPhrasesRestServiceProxy(
        originalService: Any,
        createSuccess: Constructor<*>
    ): Any {
        val invocationHandler = Proxy.getInvocationHandler(originalService)
        return Proxy.newProxyInstance(
            originalService.javaClass.classLoader,
            arrayOf(findClass(phrasesRestService))
        ) { proxy, method, args ->
            when {
                method.isGET("v3/me/prefs") -> {
                    runBlocking {
                        val currentPhrases = getPhraseList()
                        val phrases = currentPhrases.associateWith { phrase ->
                            GrindrPlus.loadClass(phraseModel).constructors.first()?.newInstance(
                                phrase.phraseId.toString(), phrase.text, phrase.timestamp, phrase.frequency
                            )
                        }
                        val phrasesResponse = findClass(phrasesResponse)
                            .constructors.find { it.parameterTypes.size == 1 }?.newInstance(phrases)
                        createSuccess.newInstance(phrasesResponse)
                    }
                }
                else -> invocationHandler.invoke(proxy, method, args)
            }
        }
    }
    private suspend fun getPhraseList(): List<SavedPhraseEntity> = withContext(Dispatchers.IO) {
        return@withContext GrindrPlus.database.savedPhraseDao().getPhraseList()
    }
    private suspend fun getPhrase(phraseId: Long): SavedPhraseEntity? = withContext(Dispatchers.IO) {
        return@withContext GrindrPlus.database.savedPhraseDao().getPhrase(phraseId)
    }
    private suspend fun getCurrentPhraseIndex(): Long = withContext(Dispatchers.IO) {
        return@withContext GrindrPlus.database.savedPhraseDao().getCurrentPhraseIndex() ?: 0L
    }
    private suspend fun addPhrase(phraseId: Long, text: String, frequency: Int, timestamp: Long) = withContext(Dispatchers.IO) {
        val phrase = SavedPhraseEntity(
            phraseId = phraseId,
            text = text,
            frequency = frequency,
            timestamp = timestamp
        )
        GrindrPlus.database.savedPhraseDao().upsertPhrase(phrase)
    }
    private suspend fun updatePhrase(phraseId: Long, text: String, frequency: Int, timestamp: Long) = withContext(Dispatchers.IO) {
        val phrase = SavedPhraseEntity(
            phraseId = phraseId,
            text = text,
            frequency = frequency,
            timestamp = timestamp
        )
        GrindrPlus.database.savedPhraseDao().upsertPhrase(phrase)
    }
    private suspend fun deletePhrase(phraseId: Long) = withContext(Dispatchers.IO) {
        GrindrPlus.database.savedPhraseDao().deletePhrase(phraseId)
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\LocationSpoofer.kt --- 
package com.grindrplus.hooks
class LocationSpoofer : Hook(
    "Location spoofer",
    "Spoof your location"
) {
    private val location = "android.location.Location"
    private val chatBottomToolbar = "com.grindrapp.android.chat.presentation.ui.view.ChatBottomToolbar"
    private val appConfiguration = "com.grindrapp.android.platform.config.AppConfiguration"
    private val coroutineScope = CoroutineScope(Dispatchers.Main)
    override fun init() {
        val locationClass = findClass(location)
        if (Build.VERSION.SDK_INT >= 31) {
            locationClass.hook(
                "isMock",
                HookStage.BEFORE
            ) { param ->
                param.setResult(false)
            }
        } else {
            locationClass.hook(
                "isFromMockProvider",
                HookStage.BEFORE
            ) { param ->
                param.setResult(false)
            }
        }
        locationClass.hook("getLatitude", HookStage.AFTER) { param ->
            (Config.get("forced_coordinates", Config.get("current_location", "")) as String).takeIf {
                it.isNotEmpty()
            }?.split(",")?.firstOrNull()
                ?.toDoubleOrNull()?.let {
                    param.setResult(it)
                }
        }
        locationClass.hook("getLongitude", HookStage.AFTER) { param ->
            (Config.get("forced_coordinates", Config.get("current_location", "")) as String).takeIf {
                it.isNotEmpty()
            }?.split(",")?.lastOrNull()
                ?.toDoubleOrNull()?.let {
                    param.setResult(it)
                }
        }
        findClass(chatBottomToolbar).hookConstructor(HookStage.AFTER) { param ->
            val chatBottomToolbarLinearLayout = param.thisObject() as LinearLayout
            val exampleButton = chatBottomToolbarLinearLayout.children.first()
            var locationButtonExists = false
            if (Config.get("do_gui_safety_checks", true) as Boolean) {
                locationButtonExists = chatBottomToolbarLinearLayout.children.any { view ->
                    if (view is ImageButton) {
                        view.tag == "custom_location_button" ||
                                view.contentDescription == "Teleport"
                    } else false
                }
            }
            if (locationButtonExists) {
                logw("Location button already exists?")
                return@hookConstructor
            }
            val customLocationButton = ImageButton(chatBottomToolbarLinearLayout.context).apply {
                layoutParams = LinearLayout.LayoutParams(
                    0, LinearLayout.LayoutParams.MATCH_PARENT
                ).apply { weight = 1f }
                focusable = ImageButton.FOCUSABLE
                scaleType = ImageView.ScaleType.CENTER
                isClickable = true
                tag = "custom_location_button"
                contentDescription = "Teleport"
                setBackgroundResource(
                    Utils.getId(
                        "image_button_ripple",
                        "drawable",
                        GrindrPlus.context
                    )
                )
                setImageResource(
                    Utils.getId(
                        "ic_my_location",
                        "drawable",
                        GrindrPlus.context
                    )
                )
                setPadding(
                    exampleButton.paddingLeft,
                    exampleButton.paddingTop,
                    exampleButton.paddingRight,
                    exampleButton.paddingBottom
                )
                val grindrGray = "#9e9ea8".toColorInt()
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    drawable.colorFilter =
                        BlendModeColorFilter(grindrGray, BlendMode.SRC_IN)
                } else {
                    @Suppress("DEPRECATION")
                    drawable.colorFilter =
                        PorterDuffColorFilter(grindrGray, PorterDuff.Mode.SRC_IN)
                }
            }
            customLocationButton.setOnClickListener {
                coroutineScope.launch {
                    val locations = getLocations()
                    if (locations.isEmpty()) {
                        GrindrPlus.showToast(
                            Toast.LENGTH_LONG,
                            "No saved locations"
                        )
                        return@launch
                    }
                    val locationNames = locations.map { it.name }
                    val coordinatesMap = locations.associate { location ->
                        location.name to "${location.latitude}, ${location.longitude}"
                    }
                    val locationDialogView = LinearLayout(it.context).apply {
                        orientation = LinearLayout.VERTICAL
                        setPadding(32, 32, 32, 32)
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        )
                    }
                    val textViewCoordinates = TextView(it.context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        ).apply {
                            topMargin = 16
                            marginStart = 70
                            marginEnd = 70
                        }
                        gravity = Gravity.CENTER_HORIZONTAL
                        textSize = 16f
                        setTypeface(null, Typeface.BOLD)
                        setTextColor(Color.WHITE)
                    }
                    val spinnerLocations = Spinner(it.context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        ).apply {
                            topMargin = 16
                            marginStart = 120
                            marginEnd = 140
                        }
                    }
                    val adapter = object : ArrayAdapter<String>(
                        it.context,
                        android.R.layout.simple_spinner_item,
                        locationNames
                    ) {
                        override fun getView(
                            position: Int,
                            convertView: View?,
                            parent: ViewGroup
                        ): View {
                            return getCustomView(position, convertView, parent)
                        }
                        override fun getDropDownView(
                            position: Int,
                            convertView: View?,
                            parent: ViewGroup
                        ): View {
                            return getCustomView(position, convertView, parent)
                        }
                        private fun getCustomView(
                            position: Int,
                            convertView: View?,
                            parent: ViewGroup
                        ): View {
                            val view = (convertView as? TextView) ?: TextView(it.context).apply {
                                layoutParams = LinearLayout.LayoutParams(
                                    LinearLayout.LayoutParams.MATCH_PARENT,
                                    LinearLayout.LayoutParams.WRAP_CONTENT
                                )
                                minHeight = 120
                                gravity = (Gravity.CENTER_HORIZONTAL or Gravity.CENTER_VERTICAL)
                                textSize = 16f
                                setTextColor(Color.WHITE)
                                background = ColorDrawable(Color.TRANSPARENT)
                            }
                            view.text = getItem(position)
                            return view
                        }
                    }
                    spinnerLocations.adapter = adapter
                    spinnerLocations.onItemSelectedListener =
                        object : AdapterView.OnItemSelectedListener {
                            override fun onItemSelected(
                                parent: AdapterView<*>,
                                view: View,
                                position: Int,
                                id: Long
                            ) {
                                textViewCoordinates.text = coordinatesMap[locationNames[position]]
                            }
                            override fun onNothingSelected(parent: AdapterView<*>) {
                                textViewCoordinates.text = ""
                            }
                        }
                    val wrapDrawable = DrawableCompat.wrap(spinnerLocations.background)
                    DrawableCompat.setTint(wrapDrawable, Color.WHITE)
                    spinnerLocations.background = wrapDrawable
                    val buttonCopy = Button(it.context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        ).apply {
                            topMargin = 50
                            marginStart = 140
                            marginEnd = 140
                        }
                        text = "Copy Coordinates"
                        background = Utils.createButtonDrawable(Color.parseColor("#4CAF50"))
                        setTextColor(Color.WHITE)
                        setOnClickListener {
                            Utils.copyToClipboard(
                                "Coordinates",
                                textViewCoordinates.text.toString()
                            )
                        }
                    }
                    val buttonSet = Button(it.context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        ).apply {
                            topMargin = 15
                            marginStart = 140
                            marginEnd = 140
                        }
                        text = "Teleport to location"
                        background = Utils.createButtonDrawable(Color.parseColor("#2196F3"))
                        setTextColor(Color.WHITE)
                        setOnClickListener {
                            Config.put("current_location", textViewCoordinates.text.toString())
                            GrindrPlus.showToast(
                                Toast.LENGTH_LONG,
                                "Successfully teleported to ${textViewCoordinates.text}"
                            )
                        }
                    }
                    val buttonOpen = Button(it.context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        ).apply {
                            topMargin = 15
                            marginStart = 140
                            marginEnd = 140
                        }
                        text = "Open in Maps"
                        background = Utils.createButtonDrawable(Color.parseColor("#9C27B0"))
                        setTextColor(Color.WHITE)
                        setOnClickListener {
                            context.startActivity(
                                Intent(
                                    Intent.ACTION_VIEW, Uri.parse(
                                        "geo:${textViewCoordinates.text}"
                                    )
                                )
                            )
                        }
                    }
                    val buttonDelete = Button(it.context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        ).apply {
                            topMargin = 15
                            marginStart = 140
                            marginEnd = 140
                        }
                        text = "Delete Location"
                        background = Utils.createButtonDrawable(Color.parseColor("#FF0000"))
                        setTextColor(Color.WHITE)
                        setOnClickListener button@{
                            val name = spinnerLocations.selectedItem.toString()
                            coroutineScope.launch {
                                deleteLocation(name)
                                val updatedLocations = getLocations()
                                val updatedLocationNames = updatedLocations.map { it.name }
                                withContext(Dispatchers.Main) {
                                    adapter.clear()
                                    adapter.addAll(updatedLocationNames)
                                    adapter.notifyDataSetChanged()
                                }
                                GrindrPlus.showToast(Toast.LENGTH_LONG, "Location deleted")
                            }
                        }
                    }
                    for (view in arrayOf(
                        spinnerLocations,
                        textViewCoordinates, buttonCopy,
                        buttonSet, buttonOpen, buttonDelete
                    )) {
                        locationDialogView.addView(view)
                    }
                    AlertDialog.Builder(it.context).apply {
                        setTitle("Teleport Locations")
                        setView(locationDialogView)
                        setPositiveButton("Close") { dialog, _ -> dialog.dismiss() }
                        show()
                    }
                }
            }
            chatBottomToolbarLinearLayout.addView(customLocationButton)
        }
    }
    private suspend fun getLocations(): List<TeleportLocationEntity> = withContext(Dispatchers.IO) {
        return@withContext GrindrPlus.database.teleportLocationDao().getLocations()
    }
    private suspend fun deleteLocation(name: String) = withContext(Dispatchers.IO) {
        GrindrPlus.database.teleportLocationDao().deleteLocation(name)
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\NotificationAlerts.kt --- 
package com.grindrplus.hooks
class NotificationAlerts : Hook(
    "Notification Alerts",
    "Disable all Grindr warnings related to notifications"
) {
    private val notificationManager = "fa.c" // search for '0L, "notification_reminder_time"'
    override fun init() {
        findClass(notificationManager)
            .hook("a", HookStage.BEFORE) { param ->
                param.setResult(null)
            }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\OnlineIndicator.kt --- 
package com.grindrplus.hooks
class OnlineIndicator : Hook(
    "Online indicator",
    "Customize online indicator duration"
) {
    val utils = "di.q0" // search for ' <= 600000;'
    override fun init() {
        findClass(utils) // shouldShowOnlineIndicator()
            .hook("a", HookStage.BEFORE) { param ->
                val savedDuration = Config.get("online_indicator", 3).toString().toInt()
                param.setResult(System.currentTimeMillis() - param.arg<Long>(0) <= savedDuration.minutes.inWholeMilliseconds)
            }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\PreventChatDeletion.kt --- 
package com.grindrplus.hooks
class PreventChatDeletion : Hook(
    "Prevent Chat Deletion",
    "Prevents chats from being deleted from the local database."
) {
    // A set of all chat-related tables to protect from deletion.
    private val tablesToProtect = setOf(
        "chat_messages",
        "chat_conversations",
        "chat_conversation_participants",
        "chat_conversation_previews"
    )
    // This is the network service class responsible for making the API call to delete messages.
    // We intercept the call here to prevent it from ever reaching Grindr's servers.
    private val chatRestService = "com.grindrapp.android.chat.data.datasource.api.service.ChatRestService"
    // This is the specific method that sends the deletion request.
    private val deleteMessagesMethod = "deleteMessages"
    override fun init() {
        // We hook the main delete method of SQLiteDatabase.
        SQLiteDatabase::class.java.hook(
            "delete",
            HookStage.BEFORE
        ) { param ->
            // First, check if our feature is enabled in the settings.
            if (!isHookEnabled()) return@hook
            // The first argument is the table name.
            val table = param.arg<String>(0)
            // Check if the table is one we want to protect.
            if (table in tablesToProtect) {
                logi("Intercepted a delete request for the '$table' table.")
                // Log the details for debugging purposes.
                val whereClause = param.argNullable<String>(1)
                val whereArgs = param.argNullable<Array<String>>(2)
                logi("WHERE clause: $whereClause, Args: ${whereArgs?.joinToString()}")
                // By setting a result, we prevent the original method from being called.
                // Returning 0 means "0 rows were deleted".
                param.setResult(0)
                logi("Prevented deletion from '$table'.")
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\ProfileDetails.kt --- 
package com.grindrplus.hooks
class ProfileDetails : Hook("Profile details", "Add extra fields and details to profiles") {
    private var boostedProfilesList = emptyList<String>()
    private val blockedProfilesObserver = "Uh.t" // search for 'Intrinsics.checkNotNullParameter(dataList, "dataList");' - typically the last match
    private val profileViewHolder = "ng.A\$b" // search for 'Intrinsics.checkNotNullParameter(individualUnblockActivityViewModel, "individualUnblockActivityViewModel");'
    private val distanceUtils = "com.grindrapp.android.utils.DistanceUtils"
    private val profileBarView = "com.grindrapp.android.ui.profileV2.ProfileBarView"
    private val profileViewState = "com.grindrapp.android.ui.profileV2.model.ProfileViewState"
    private val serverDrivenCascadeCachedState =
        "com.grindrapp.android.persistence.model.serverdrivencascade.ServerDrivenCascadeCacheState"
    private val serverDrivenCascadeCachedProfile =
        "com.grindrapp.android.persistence.model.serverdrivencascade.ServerDrivenCascadeCachedProfile"
    @SuppressLint("DefaultLocale")
    override fun init() {
        findClass(serverDrivenCascadeCachedState).hook("getItems", HookStage.AFTER) { param ->
            (param.getResult() as List<*>)
                .filter { (it?.javaClass?.name ?: "") == serverDrivenCascadeCachedProfile }
                .forEach {
                    if (getObjectField(it, "isBoosting") as Boolean) {
                        boostedProfilesList += callMethod(it, "getProfileId") as String
                    }
                }
        }
        findClass(blockedProfilesObserver).hook("onChanged", HookStage.AFTER) { param ->
            // recently got merged into a case statement, so filter for the right argument type
            if ((getObjectField(param.thisObject(), "a") as Int) != 0) return@hook
            val profileList = getObjectField(
                getObjectField(param.thisObject(), "b"), "o") as ArrayList<*>
            for (profile in profileList) {
                val profileId = callMethod(profile, "getProfileId") as String
                val displayName =
                    (callMethod(profile, "getDisplayName") as? String)
                        ?.takeIf { it.isNotEmpty() }
                        ?.let { "$it ($profileId)" } ?: profileId
                setObjectField(profile, "displayName", displayName)
            }
        }
        findClass(profileViewHolder).hookConstructor(HookStage.AFTER) { param ->
            val textView =
                getObjectField(param.thisObject(), "b") as TextView
            textView.setOnLongClickListener {
                val text = textView.text.toString()
                val profileId = if ("(" in text && ")" in text)
                    text.substringAfter("(").substringBefore(")")
                else text
                copyToClipboard("Profile ID", profileId)
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Profile ID: $profileId")
                true
            }
        }
        findClass(profileBarView).hook("setProfile", HookStage.BEFORE) { param ->
            val profileId = getObjectField(param.arg(0), "profileId") as String
            val accountCreationTime =
                formatEpochSeconds(GrindrPlus.spline.invert(profileId.toDouble()).toLong())
            val distance = callMethod(param.arg(0), "getDistance") ?: "Unknown (hidden)"
            setObjectField(param.arg(0), "distance", distance)
            if (profileId in boostedProfilesList) {
                val lastSeen = callMethod(param.arg(0), "getLastSeenText")
                setObjectField(param.arg(0), "lastSeenText", "$lastSeen (Boosting)")
            }
            val displayName = callMethod(param.arg(0), "getDisplayName") ?: profileId
            setObjectField(param.arg(0), "displayName", displayName)
            val viewBinding = getObjectField(param.thisObject(), "c")
            val displayNameTextView = getObjectField(viewBinding, "c") as TextView
            displayNameTextView.setOnLongClickListener {
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Profile ID: $profileId")
                copyToClipboard("Profile ID", profileId)
                true
            }
            displayNameTextView.setOnClickListener {
                val properties =
                    mapOf(
                        "Estimated creation" to accountCreationTime,
                        "Profile ID" to profileId,
                        "Approximate distance" to
                                Utils.safeGetField(param.arg(0), "approximateDistance") as? Boolean,
                        "Favorite" to
                                Utils.safeGetField(param.arg(0), "isFavorite") as? Boolean,
                        "From viewed me" to
                                Utils.safeGetField(param.arg(0), "isFromViewedMe") as? Boolean,
                        "JWT boosting" to
                                Utils.safeGetField(param.arg(0), "isJwtBoosting") as? Boolean,
                        "New" to Utils.safeGetField(param.arg(0), "isNew") as? Boolean,
                        "Teleporting" to
                                Utils.safeGetField(param.arg(0), "isTeleporting") as? Boolean,
                        "Online now" to
                                Utils.safeGetField(param.arg(0), "onlineNow") as? Boolean,
                        "Is roaming" to
                                Utils.safeGetField(param.arg(0), "isRoaming") as? Boolean,
                        "Found via roam" to
                                Utils.safeGetField(param.arg(0), "foundViaRoam") as? Boolean,
                        "Is top pick" to
                                Utils.safeGetField(param.arg(0), "isTopPick") as? Boolean,
                        "Is visiting" to
                                Utils.safeGetField(param.arg(0), "isVisiting") as? Boolean,
                        "Is distance approximate" to
                                Utils.safeGetField(param.arg(0), "approximateDistance") as? Boolean,
                    )
                        .filterValues { it != null }
                val detailsText = properties.map { (key, value) -> "• $key: $value" }.joinToString("\n")
                val dialog =
                    AlertDialog.Builder(it.context)
                        .setTitle("Hidden profile details")
                        .setMessage(detailsText)
                        .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
                        .setNeutralButton("Copy Details") { dialog, _ ->
                            copyToClipboard("Profile Details", detailsText)
                            GrindrPlus.showToast(Toast.LENGTH_SHORT, "Profile details copied to clipboard")
                            dialog.dismiss()
                        }
                        .create()
                dialog.setOnShowListener {
                    dialog.getButton(AlertDialog.BUTTON_POSITIVE)?.setTextColor(android.graphics.Color.WHITE)
                    dialog.getButton(AlertDialog.BUTTON_NEUTRAL)?.setTextColor(android.graphics.Color.WHITE)
                    dialog.getButton(AlertDialog.BUTTON_NEGATIVE)?.setTextColor(android.graphics.Color.WHITE)
                }
                dialog.show()
            }
        }
        findClass(distanceUtils).hook("c", HookStage.AFTER) { param ->
            val distance = param.arg<Double>(0)
            // val isAbbreviated = param.arg<Boolean>(1)
            val isFeet = param.arg<Boolean>(2)
            param.setResult(
                if (isFeet) {
                    val feet = (distance * 3.280839895).roundToInt()
                    if (feet < 5280) {
                        String.format("%d feet", feet)
                    } else {
                        String.format("%d miles %d feet", feet / 5280, feet % 5280)
                    }
                } else {
                    val meters = distance.roundToInt()
                    if (meters < 1000) {
                        String.format("%d meters", meters)
                    } else {
                        String.format("%d km %d m", meters / 1000, meters % 1000)
                    }
                }
            )
        }
        findClass(profileViewState).hook("getWeight", HookStage.AFTER) { param ->
            if (Config.get("show_bmi_in_profile", true) as Boolean) {
                val weight = param.getResult()
                val height = callMethod(param.thisObject(), "getHeight")
                if (weight != null && height != null) {
                    val BMI =
                        calculateBMI(
                            "kg" in weight.toString(),
                            w2n("kg" in weight.toString(), weight.toString()),
                            h2n("kg" in weight.toString(), height.toString())
                        )
                    if (Config.get("do_gui_safety_checks", true) as Boolean) {
                        if (weight.toString().contains("(")) {
                            logw("BMI details are already present?")
                            return@hook
                        }
                    }
                    param.setResult(
                        "$weight - ${String.format("%.1f", BMI)} (${
                            mapOf(
                                "Underweight" to 18.5,
                                "Normal weight" to 24.9,
                                "Overweight" to 29.9,
                                "Obese" to Double.MAX_VALUE
                            ).entries.first { it.value > BMI }.key
                        })"
                    )
                }
            }
        }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\ProfileViews.kt --- 
package com.grindrplus.hooks
class ProfileViews : Hook("Profile views", "Don't let others know you viewed their profile") {
    private val profileRestService = "com.grindrapp.android.api.ProfileRestService"
    private val blacklistedPaths = setOf(
        "v4/views/{profileId}",
        "v5/views/{profileId}",
        "v4/views"
    )
    override fun init() {
        val profileRestServiceClass = findClass(profileRestService)
        val methodBlacklist =
            blacklistedPaths.mapNotNull { findPOSTMethod(profileRestServiceClass, it)?.name }
        findClass(RETROFIT_NAME).hook("create", HookStage.AFTER) { param ->
            val service = param.getResult()
            if (service != null && profileRestServiceClass.isAssignableFrom(service.javaClass)) {
                param.setResult(
                    createServiceProxy(
                        service,
                        profileRestServiceClass,
                        methodBlacklist.toTypedArray()
                    )
                )
            }
        }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\QuickBlock.kt --- 
package com.grindrplus.hooks
class QuickBlock : Hook(
    "Quick block",
    "Ability to block users quickly"
) {
    private val blockViewModel = "yg.b" // search for '("STATUS_BLOCK_DIALOG_SHOWN", 1)'
    private val profileViewHolder = "com.grindrapp.android.ui.profileV2.g" // search for 'com.grindrapp.android.ui.profileV2.ProfileViewHolder$onBind$3'
    override fun init() {
        findClass(profileViewHolder).hook("y", HookStage.AFTER) { param ->
            val arg0 = param.arg(0) as Any
            val profileId = param.args().getOrNull(1) ?: return@hook
            val viewBinding = getObjectField(arg0, "b")
            val profileToolbar = getObjectField(viewBinding, "p")
            val toolbarMenu = callMethod(profileToolbar, "getMenu") as Menu
            val menuActions = getId("menu_actions", "id", GrindrPlus.context)
            val actionsMenuItem = callMethod(toolbarMenu, "findItem", menuActions) as MenuItem
            actionsMenuItem.setOnMenuItemClickListener { GrindrPlus.httpClient.blockUser(profileId as String); true }
        }
        findClass(blockViewModel).hook("I", HookStage.BEFORE) { param ->
            val profileId = param.thisObject().javaClass.declaredFields
                .asSequence()
                .filter { it.type == String::class.java }
                .mapNotNull { field ->
                    try {
                        field.isAccessible = true
                        field.get(param.thisObject()) as? String
                    } catch (e: Exception) { null }
                }
                .firstOrNull { it.isNotEmpty() && it.all { char -> char.isDigit() } }
            GrindrPlus.httpClient.blockUser(profileId as String)
            param.setResult(null)
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\ReverseRadarTabs.kt --- 
package com.grindrplus.hooks
class ReverseRadarTabs : Hook(
    "Reverse radar tabs",
    "Shows the received taps before profile views"
) {
    private inline fun <reified T : Any> getJavaClass() = T::class.java
    private val radarTabs = "m8.b"
    private val radarFragment = "com.grindrapp.android.radar.presentation.ui.RadarFragment"
    override fun init() {
        //Alternative which just scrolls to the tab fragment instead
        /*val viewPagerClass = findClass("androidx.viewpager2.widget.ViewPager2")
        findClass("com.grindrapp.android.radar.presentation.ui.RadarFragment")
            .hook("onViewCreated", HookStage.AFTER) {
                val view = it.arg<View>(0)
                val viewPager = view.findViewById<View>(
                    Utils.getId(
                        "radar_view_pager",
                        "id",
                        GrindrPlus.context
                    )
                )
                val setCurrentItem = viewPagerClass.getMethod("setCurrentItem", Int::class.java, Boolean::class.java)
                viewPager.post {
                    setCurrentItem.invoke(viewPager, 1, false)
                }
                //viewPagerClass.getMethod("setCurrentItem", Int::class.java).invoke(viewPager, 1)
            }*/
        val radarTabs = callStaticMethod(findClass(radarTabs), "values") as Array<*>
        findClass("$radarFragment\$a")
            .hookConstructor(HookStage.BEFORE) { param ->
                val tabs = param.arg(2, List::class.java)!!
                val reversed = findClass("kotlinx.collections.immutable.ExtensionsKt")
                    .getMethod("toImmutableList", Iterable::class.java)
                    .invoke(null, tabs.reversed())
                param.setArg(2, reversed)
            }
        //Unfortunately, some methods in RadarFragment use the ordinal of the RadarTab enum to determine the position in the TabLayout,
        //which no longer reflects the actual position in the ViewPager
        findClass("com.google.android.material.tabs.TabLayout")
            .hook("getTabAt", HookStage.BEFORE) { param ->
                if (!Thread.currentThread().stackTrace.any {
                        it.className.contains(radarFragment)
                    }) return@hook
                param.setArg(0, radarTabs.size - 1 - param.arg<Int>(0))
            }
        //This LiveData observer consumes the integer values from a flow and makes the ViewPager scroll to that position
        //This is used to make the ViewPager scroll to the taps page upon clicking such notification.
        //However, this is based on the ordinal values again, so we have to reverse the values, too.
        findClass("Ma.B")
            .hook("onChanged", HookStage.BEFORE) { param ->
                //Check whether this observer is responsible for handling the ViewPager position
                if (getIntField(param.thisObject(), "b") != 1) return@hook
                val position = param.arg<Number>(0).toInt()
                param.setArg(0, Integer.valueOf(radarTabs.size - 1 - position))
            }
        //The modified LiveData observer will no longer scroll to the first position when receiving a value 0.
        //In order to still show the new first tab (TapsFragment) by default, we need to set the initial value to the last index,
        //so that the LiveData observer reverts it back to 0.
        findClass("La.s0")
            .hookConstructor(HookStage.AFTER) { param ->
                val stateFlow = getObjectField(param.thisObject(), "J0")
                //Set initial position to the last page, so that the onChanged hook of the LiveData observer reverts it to the new first page
                callMethod(stateFlow, "setValue", Integer.valueOf(radarTabs.size - 1))
            }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\SignatureSpoofer.kt --- 
package com.grindrplus.hooks
private const val packageSignature = "823f5a17c33b16b4775480b31607e7df35d67af8"
private const val firebaseInstallationServiceClient =
    "com.google.firebase.installations.remote.FirebaseInstallationServiceClient"
private const val configRealtimeHttpClient =
    "com.google.firebase.remoteconfig.internal.ConfigRealtimeHttpClient"
private const val configFetchHttpClient =
    "com.google.firebase.remoteconfig.internal.ConfigFetchHttpClient"
@OptIn(ExperimentalStdlibApi::class)
fun spoofSignatures(param: XC_LoadPackage.LoadPackageParam) {
    listOf(
        firebaseInstallationServiceClient,
        configRealtimeHttpClient,
        configFetchHttpClient
    ).forEach { className ->
        findAndHookMethod(
            className,
            param.classLoader,
            "getFingerprintHashForPackage",
            object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam<*>) {
                    param.result = packageSignature
                }
            })
    }
    findAndHookMethod(
        "ly.img.android.c",
        param.classLoader,
        "d", // getPackageName
        object : XC_MethodHook() {
            override fun beforeHookedMethod(param: MethodHookParam<*>) {
                param.result = GRINDR_PACKAGE_NAME
            }
        })
    // The Facebook SDK tries to handle the login using the Facebook app in case it is installed.
    // However, the Facebook app does signature checks with the app that is requesting the authentication,
    // which ends up making the Facebook server reject with an invalid key hash for the app signature.
    // Override the Facebook SDK to always handle the login using the web browser, which does not perform
    // signature checks.
    //
    // Always return 0 (no Intent was launched) as the result of trying to authorize with the Facebook app to
    // make the login fallback to a web browser window.
    //
    findAndHookMethod(
        "com.facebook.login.KatanaProxyLoginMethodHandler",
        param.classLoader,
        "tryAuthorize",
        XposedHelpers.findClass("com.facebook.login.LoginClient\$Request", param.classLoader),
        object : XC_MethodHook() {
            override fun afterHookedMethod(param: MethodHookParam<*>) {
                param.result = 0
            }
        }
    )
    if (param.packageName != GRINDR_PACKAGE_NAME) {
        fun isFirebaseInstallationServiceClient() = Thread.currentThread().stackTrace.any {
            it.className.startsWith("com.google.firebase.installations.remote.FirebaseInstallationServiceClient")
        }
        findAndHookMethod(
            ContextWrapper::class.java,
            "getPackageName",
            object : XC_MethodHook() {
                override fun afterHookedMethod(param: MethodHookParam<*>) {
                    if (isFirebaseInstallationServiceClient()) {
                        param.result = GRINDR_PACKAGE_NAME
                    }
                }
            }
        )
        findAndHookMethod(
            "com.google.firebase.messaging.Metadata",
            param.classLoader,
            "getPackageInfo",
            String::class.java,  // packageName
            object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam<*>) {
                    if ((param.args[0] as String).contains("grindr")) {
                        param.args[0] = GRINDR_PACKAGE_NAME
                    }
                }
            }
        )
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\SSLUnpinning.kt --- 
package com.grindrplus.hooks
@OptIn(ExperimentalStdlibApi::class)
@SuppressLint("CustomX509TrustManager", "TrustAllX509TrustManager", "BadHostnameVerifier")
fun sslUnpinning(param: XC_LoadPackage.LoadPackageParam) {
    findAndHookConstructor(
        "okhttp3.OkHttpClient\$Builder",
        param.classLoader,
        object : XC_MethodHook() {
            override fun afterHookedMethod(param: MethodHookParam<*>) {
                val trustAlLCerts =
                    arrayOf<TrustManager>(
                        object : X509TrustManager {
                            override fun checkClientTrusted(
                                chain: Array<out X509Certificate>?,
                                authType: String?,
                            ) {}
                            override fun checkServerTrusted(
                                chain: Array<out X509Certificate>?,
                                authType: String?,
                            ) {}
                            override fun getAcceptedIssuers(): Array<X509Certificate> = emptyArray()
                        }
                    )
                val sslContext = SSLContext.getInstance("TLSv1.3")
                sslContext.init(null, trustAlLCerts, SecureRandom())
                callMethod(
                    param.thisObject,
                    "sslSocketFactory",
                    sslContext.socketFactory,
                    trustAlLCerts.first() as X509TrustManager
                )
                callMethod(
                    param.thisObject,
                    "hostnameVerifier",
                    object : HostnameVerifier {
                        override fun verify(hostname: String?, session: SSLSession?): Boolean = true
                    }
                )
            }
        }
    )
    findAndHookMethod(
        "okhttp3.OkHttpClient\$Builder",
        param.classLoader,
        "certificatePinner",
        "okhttp3.CertificatePinner",
        XC_MethodReplacement.DO_NOTHING
    )
    findAndHookMethod(
        "com.android.org.conscrypt.TrustManagerImpl",
        param.classLoader,
        "verifyChain",
        List::class.java, // List<X509Certificate> untrustedChain
        List::class.java, // List<TrustAnchor> trustAnchorChain
        String::class.java, // String host
        Boolean::class.java, // boolean clientAuth
        ByteArray::class.java, // byte[] ocspData
        ByteArray::class.java, // byte[] tlsSctData
        object : XC_MethodHook() {
            override fun beforeHookedMethod(param: MethodHookParam<*>) {
                param.result = param.args[0]
            }
        }
    )
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\StatusDialog.kt --- 
package com.grindrplus.hooks
class StatusDialog : Hook(
    "Status Dialog",
    "Check whether GrindrPlus is alive or not"
) {
    private val tabView = "com.google.android.material.tabs.TabLayout\$TabView"
    override fun init() {
        findClass(tabView).hookConstructor(HookStage.AFTER) { param ->
            val tabView = param.thisObject() as View
            tabView.post {
                val parent = tabView.parent as? ViewGroup
                val position = parent?.indexOfChild(tabView) ?: -1
                if (position == 0) {
                    tabView.setOnLongClickListener { v ->
                        showGrindrPlusDialog(v.context)
                        false
                    }
                }
            }
        }
    }
    private fun showGrindrPlusDialog(context: Context) {
        GrindrPlus.currentActivity?.runOnUiThread {
            try {
                val packageManager = context.packageManager
                val packageInfo = packageManager.getPackageInfo(context.packageName, 0)
                val appVersionName = packageInfo.versionName
                val appVersionCode = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                    packageInfo.longVersionCode
                } else {
                    @Suppress("DEPRECATION")
                    packageInfo.versionCode.toLong()
                }
                val packageName = context.packageName
                val deviceModel = "${Build.MANUFACTURER} ${Build.MODEL}"
                val androidVersion = "${Build.VERSION.RELEASE} (API ${Build.VERSION.SDK_INT})"
                val moduleVersion = try {
                    BuildConfig.VERSION_NAME
                } catch (e: Exception) {
                    "Unknown"
                }
                val bridgeStatus = if (GrindrPlus.bridgeClient.isConnected()) {
                    "Connected"
                } else {
                    "Disconnected"
                }
                val androidDeviceIdStatus = (Config.get("android_device_id", "") as String)
                    .let { id -> if (id.isNotEmpty()) "Spoofing ($id)" else "Not Spoofing (stock)" }
                if (GrindrPlus.bridgeClient.isConnected()) {
                    val isLSPosed = GrindrPlus.bridgeClient.isLSPosed()
                    val isRooted = GrindrPlus.bridgeClient.isRooted()
                }
                val message = buildString {
                    appendLine("GrindrPlus is active and running")
                    appendLine()
                    appendLine("App Information:")
                    appendLine("• Version: $appVersionName ($appVersionCode)")
                    appendLine("• Package: $packageName")
                    appendLine("• Android ID: $androidDeviceIdStatus")
                    appendLine()
                    appendLine("Module Information:")
                    appendLine("• GrindrPlus: $moduleVersion")
                    appendLine("• Bridge Status: $bridgeStatus")
                    if (GrindrPlus.bridgeClient.isConnected()) {
                        appendLine("• LSPosed: ${GrindrPlus.bridgeClient.isLSPosed()}")
                        appendLine("• Rooted: ${GrindrPlus.bridgeClient.isRooted()}")
                    }
                    appendLine()
                    appendLine("Device Information:")
                    appendLine("• Device: $deviceModel")
                    appendLine("• Android: $androidVersion")
                    appendLine()
                    appendLine("Long press this tab to show this dialog")
                }
                AlertDialog.Builder(context)
                    .setTitle("GrindrPlus")
                    .setMessage(message)
                    .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
                    .setNegativeButton("Restart") { dialog, _ ->
                        dialog.dismiss()
                        performCacheClearOperation(context)
                    }
                    .setIcon(android.R.drawable.ic_dialog_info)
                    .show()
            } catch (e: Exception) {
                AlertDialog.Builder(context)
                    .setTitle("GrindrPlus")
                    .setMessage("GrindrPlus is active and running\n\nError retrieving details: ${e.message}")
                    .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
                    .show()
            }
        }
    }
    private fun performCacheClearOperation(context: Context) {
        GrindrPlus.executeAsync {
            val operationResult = CacheClearResult()
            try {
                val cacheDirs = getCacheDirectories(context)
                cacheDirs.forEach { cacheDir ->
                    if (cacheDir.exists() && cacheDir.canWrite()) {
                        val clearResult = clearDirectoryContents(cacheDir)
                        operationResult.addResult(clearResult)
                    }
                }
                clearTemporarySharedPreferences(context, operationResult)
                clearWebViewCache(context, operationResult)
                val totalSizeMB = operationResult.totalSize / (1024 * 1024)
                logi("Cache operation completed: ${operationResult.totalFiles} files removed, ${totalSizeMB}MB freed")
                restartGrindr(100, "Restarting Grindr... (${totalSizeMB}MB freed)")
            } catch (e: Exception) {
                loge("Cache clear operation failed: ${e.message}")
                GrindrPlus.runOnMainThread {
                    GrindrPlus.showToast(Toast.LENGTH_LONG, "Cache clear operation failed: ${e.localizedMessage}")
                }
            }
        }
    }
    private fun getCacheDirectories(context: Context): List<File> {
        val directories = mutableListOf<File>()
        context.cacheDir?.let { directories.add(it) }
        context.externalCacheDir?.let { directories.add(it) }
        return directories
    }
    private fun clearDirectoryContents(directory: File): ClearOperationResult {
        val result = ClearOperationResult()
        if (!directory.exists() || !directory.isDirectory) {
            return result
        }
        try {
            directory.listFiles()?.forEach { file ->
                val fileSize = if (file.isFile) file.length() else 0L
                val deleted = if (file.isDirectory) {
                    val subResult = clearDirectoryContents(file)
                    result.addSubResult(subResult)
                    file.delete()
                } else {
                    file.delete()
                }
                if (deleted) {
                    result.filesCleared++
                    result.bytesCleared += fileSize
                }
            }
        } catch (e: SecurityException) {
            logw("Permission denied accessing directory: ${directory.absolutePath}")
        } catch (e: Exception) {
            logw("Error processing directory: ${directory.absolutePath} - ${e.message}")
        }
        return result
    }
    private fun clearWebViewCache(context: Context, operationResult: CacheClearResult) {
        try {
            val webViewCacheDir = File(context.filesDir.parent, "app_webview")
            if (webViewCacheDir.exists()) {
                val clearResult = clearDirectoryContents(webViewCacheDir)
                operationResult.addResult(clearResult)
            }
        } catch (e: Exception) {
            logw("WebView cache clear failed: ${e.message}")
        }
    }
    private fun clearTemporarySharedPreferences(context: Context, operationResult: CacheClearResult) {
        try {
            val sharedPrefsDir = File(context.filesDir.parent, "shared_prefs")
            if (sharedPrefsDir.exists()) {
                sharedPrefsDir.listFiles()
                    ?.filter { it.name.contains("cache", ignoreCase = true) || it.name.contains("temp", ignoreCase = true) }
                    ?.forEach { file ->
                        val size = file.length()
                        if (file.delete()) {
                            operationResult.totalFiles++
                            operationResult.totalSize += size
                        }
                    }
            }
        } catch (e: Exception) {
            logw("Temporary shared preferences clear failed: ${e.message}")
        }
    }
    private data class ClearOperationResult(
        var filesCleared: Int = 0,
        var bytesCleared: Long = 0L
    ) {
        fun addSubResult(other: ClearOperationResult) {
            filesCleared += other.filesCleared
            bytesCleared += other.bytesCleared
        }
    }
    private data class CacheClearResult(
        var totalFiles: Int = 0,
        var totalSize: Long = 0L
    ) {
        fun addResult(result: ClearOperationResult) {
            totalFiles += result.filesCleared
            totalSize += result.bytesCleared
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\TimberLogging.kt --- 
package com.grindrplus.hooks
@SuppressLint("LogNotTimber")
class TimberLogging :
    Hook("Timber Logging", "Forces Timber to log messages even if no tree is planted") {
    override fun init() {
        if (!BuildConfig.DEBUG) {
            return
        }
        try {
            val forestClass = findClass("timber.log.Timber\$Forest")
            val logMethods = arrayOf("v", "d", "i", "w", "e", "wtf")
            for (method in logMethods) {
                forestClass.hook(method, HookStage.BEFORE) { param ->
                    if (param.args().isNotEmpty() && param.args()[0] is String) {
                        val priority =
                            when (method) {
                                "v" -> Log.VERBOSE
                                "d" -> Log.DEBUG
                                "i" -> Log.INFO
                                "w" -> Log.WARN
                                "e" -> Log.ERROR
                                "wtf" -> Log.ASSERT
                                else -> Log.INFO
                            }
                        val message = param.args()[0] as String
                        val tag =
                            XposedHelpers.getObjectField(param.thisObject(), "explicitTag")
                                ?.toString() ?: "Timber"
                        when (priority) {
                            Log.VERBOSE -> Log.v(tag, message)
                            Log.DEBUG -> Log.d(tag, message)
                            Log.INFO -> Log.i(tag, message)
                            Log.WARN -> Log.w(tag, message)
                            Log.ERROR -> Log.e(tag, message)
                            Log.ASSERT -> Log.e(tag, message)
                        }
                    }
                }
                forestClass.hook(method, HookStage.BEFORE) { param ->
                    if (
                        param.args().size >= 2 &&
                        param.args()[0] is Throwable &&
                        param.args()[1] is String
                    ) {
                        val priority =
                            when (method) {
                                "v" -> Log.VERBOSE
                                "d" -> Log.DEBUG
                                "i" -> Log.INFO
                                "w" -> Log.WARN
                                "e" -> Log.ERROR
                                "wtf" -> Log.ASSERT
                                else -> Log.INFO
                            }
                        val throwable = param.args()[0] as Throwable
                        val message = param.args()[1] as String
                        val tag =
                            XposedHelpers.getObjectField(param.thisObject(), "explicitTag")
                                ?.toString() ?: "Timber"
                        val fullMessage = "$tag: $message - Exception: ${throwable.message}"
                        when (priority) {
                            Log.VERBOSE -> Log.v(tag, fullMessage)
                            Log.DEBUG -> Log.d(tag, fullMessage)
                            Log.INFO -> Log.i(tag, fullMessage)
                            Log.WARN -> Log.w(tag, fullMessage)
                            Log.ERROR -> Log.e(tag, fullMessage)
                            Log.ASSERT -> Log.e(tag, fullMessage)
                        }
                    }
                }
                forestClass.hook(method, HookStage.BEFORE) { param ->
                    if (param.args().size == 1 && param.args()[0] is Throwable) {
                        val priority =
                            when (method) {
                                "v" -> Log.VERBOSE
                                "d" -> Log.DEBUG
                                "i" -> Log.INFO
                                "w" -> Log.WARN
                                "e" -> Log.ERROR
                                "wtf" -> Log.ASSERT
                                else -> Log.INFO
                            }
                        val throwable = param.args()[0] as Throwable
                        val tag =
                            XposedHelpers.getObjectField(param.thisObject(), "explicitTag")
                                ?.toString() ?: "Timber"
                        val fullMessage = "$tag: Exception: ${throwable.message}"
                        when (priority) {
                            Log.VERBOSE -> Log.v(tag, fullMessage)
                            Log.DEBUG -> Log.d(tag, fullMessage)
                            Log.INFO -> Log.i(tag, fullMessage)
                            Log.WARN -> Log.w(tag, fullMessage)
                            Log.ERROR -> Log.e(tag, fullMessage)
                            Log.ASSERT -> Log.e(tag, fullMessage)
                        }
                    }
                }
            }
            findClass("timber.log.Timber\$Tree").hook("log", HookStage.BEFORE) { param ->
                if (param.args().size >= 4) {
                    val priority = param.args()[0] as Int
                    val tag = param.args()[1] as? String ?: "Unknown"
                    val message = param.args()[2] as? String ?: "null"
                    val throwable = param.args()[3] as? Throwable
                    val fullMsg =
                        if (throwable != null) {
                            "$message - Exception: ${throwable.message}"
                        } else {
                            message
                        }
                    when (priority) {
                        Log.VERBOSE -> Log.v(tag, fullMsg)
                        Log.DEBUG -> Log.d(tag, fullMsg)
                        Log.INFO -> Log.i(tag, fullMsg)
                        Log.WARN -> Log.w(tag, fullMsg)
                        Log.ERROR -> Log.e(tag, fullMsg)
                        Log.ASSERT -> Log.e(tag, fullMsg)
                    }
                }
            }
        } catch (e: Exception) {
            loge("Failed to hook Timber: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
        }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\UnlimitedAlbums.kt --- 
package com.grindrplus.hooks
class UnlimitedAlbums : Hook("Unlimited albums", "Allow to be able to view unlimited albums") {
    private val albumsService = "y5.a" // search for 'v1/albums/red-dot'
    private val albumModel = "com.grindrapp.android.model.Album"
    private val filteredSpankBankAlbumContent =
        "com.grindrapp.android.albums.spankbank.domain.model.FilteredSpankBankAlbumContent"
    private val spankBankAlbumModel =
        "com.grindrapp.android.albums.spankbank.domain.model.SpankBankAlbum"
    private val spankBankAlbumContentModel =
        "com.grindrapp.android.albums.spankbank.domain.model.SpankBankAlbumContent"
    private val httpExceptionResponse = "com.grindrapp.android.network.http.HttpExceptionResponse"
    private val sharedAlbumsBrief = "com.grindrapp.android.model.albums.SharedAlbumsBrief"
    private val albumsList = "com.grindrapp.android.model.AlbumsList"
    override fun init() {
        val albumsServiceClass = findClass(albumsService)
        RetrofitUtils.hookService(
            albumsServiceClass,
        ) { originalHandler, proxy, method, args ->
            val result = originalHandler.invoke(proxy, method, args)
            try {
                when {
                    method.isGET("v2/albums/{albumId}") -> handleGetAlbum(args, result)
                    method.isGET("v1/albums") -> handleGetAlbums(args, result)
                    method.isGET("v2/albums/shares") -> handleGetAlbumsShares(args, result)
                    method.isGET("v2/albums/shares/{profileId}") ->
                        handleGetAlbumsSharesProfileId(args, result)
                    method.isGET("v3/albums/{albumId}/view") ->
                        handleGetAlbumsViewAlbumId(args, result)
                    method.isPUT("v1/albums/{albumId}/shares/remove") ->
                        handleRemoveAlbumShares(args, result)
                    else -> result
                }
            } catch (e: Exception) {
                loge("Error handling album request: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
                result
            }
        }
        findClass(albumModel).hookConstructor(HookStage.AFTER) { param ->
            try {
                setObjectField(param.thisObject(), "albumViewable", true)
                setObjectField(param.thisObject(), "viewableUntil", Long.MAX_VALUE)
            } catch (e: Exception) {
                loge("Error making album viewable: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
            }
        }
        findClass(spankBankAlbumModel).hookConstructor(HookStage.AFTER) { param ->
            try {
                setObjectField(param.thisObject(), "albumViewable", true)
                setObjectField(param.thisObject(), "expiresAt", Long.MAX_VALUE)
            } catch (e: Exception) {
                loge("Error making album viewable: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
            }
        }
        listOf(spankBankAlbumContentModel, filteredSpankBankAlbumContent).forEach { clazz ->
            findClass(clazz).hookConstructor(HookStage.AFTER) { param ->
                try {
                    setObjectField(param.thisObject(), "albumViewable", true)
                } catch (e: Exception) {
                    loge("Error making album viewable: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
        }
        findClass(albumModel).hook("isValid", HookStage.BEFORE) { param -> param.setResult(true) }
    }
    @Suppress("UNCHECKED_CAST")
    private suspend fun saveAlbum(grindrAlbum: Any) {
        try {
            val dao = GrindrPlus.database.albumDao()
            val dbAlbum = grindrAlbum.asAlbumToAlbumEntity()
            dao.upsertAlbum(dbAlbum)
            val grindrAlbumContent = getObjectField(grindrAlbum, "content") as? List<Any> ?: return
            grindrAlbumContent.forEach {
                try {
                    val dbAlbumContent = it.toAlbumContentEntity(dbAlbum.id)
                    dao.upsertAlbumContent(dbAlbumContent)
                } catch (e: Exception) {
                    loge("Failed to convert album content: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
        } catch (e: Exception) {
            loge("Failed to save album: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
        }
    }
    private suspend fun saveAlbumContent(albumId: Long, contentEntities: List<AlbumContentEntity>) {
        try {
            val dao = GrindrPlus.database.albumDao()
            val albumExists = dao.albumExists(albumId)
            if (albumExists) {
                contentEntities.forEach { content -> dao.upsertAlbumContent(content) }
            } else {
                logw("Album $albumId doesn't exist, creating placeholder")
                val currentTime = System.currentTimeMillis().toString()
                val placeholderAlbum =
                    AlbumEntity(
                        id = albumId,
                        albumName = "Unknown Album",
                        createdAt = currentTime,
                        profileId = 0L,
                        updatedAt = currentTime
                    )
                dao.upsertAlbum(placeholderAlbum)
                contentEntities.forEach { content -> dao.upsertAlbumContent(content) }
            }
        } catch (e: Exception) {
            loge("Failed to save album content: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
        }
    }
    private fun handleRemoveAlbumShares(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { args, result ->
            val albumId = args[0] as? Long ?: return@withSuspendResult result
            logi("Removing album shares for ID: $albumId")
            if (result.isFail()) {
                try {
                    runBlocking {
                        GrindrPlus.database.withTransaction {
                            val dao = GrindrPlus.database.albumDao()
                            val albumToDelete = dao.getAlbum(albumId)
                            if (albumToDelete != null) {
                                dao.deleteAlbum(albumId)
                                createSuccess(albumId)
                            } else {
                                logd("Album with ID $albumId not found in the database")
                                result
                            }
                        }
                    }
                } catch (e: Exception) {
                    loge("Failed to delete album $albumId: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                    result
                }
            } else {
                result
            }
        }
    private fun handleGetAlbumsViewAlbumId(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { args, result ->
            val albumId = args[0] as? Long ?: return@withSuspendResult result
            logd("Checking if album $albumId is viewable")
            if (!result.isSuccess()) {
                logw("Album $albumId is not viewable, checking database")
                runBlocking {
                    val dao = GrindrPlus.database.albumDao()
                    val album = dao.getAlbum(albumId)
                    if (album != null) {
                        logd("Album $albumId is viewable, returning success")
                        createSuccess(true)
                    } else {
                        logd("Album $albumId is not viewable, returning failure")
                        result
                    }
                }
            }
            result
        }
    private fun handleGetAlbum(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { args, result ->
            val albumId = args[0] as? Long ?: return@withSuspendResult result
            logd("Fetching album with ID: $albumId")
            try {
                GrindrPlus.httpClient
                    .sendRequest(url = "https://grindr.mobi/v1/albums/$albumId", method = "GET")
                    .use { response ->
                        val responseBody = response.body?.string()
                        if (!responseBody.isNullOrEmpty()) {
                            logd("Got ${responseBody.length} bytes for album $albumId")
                            val modifiedResult = parseAlbumContent(albumId, responseBody, result)
                            return@withSuspendResult modifiedResult
                        } else {
                            loge("Empty response body for album $albumId")
                            val modifiedResult = fetchAlbumFromDatabase(albumId, result)
                            return@withSuspendResult modifiedResult
                        }
                    }
            } catch (e: Exception) {
                loge("Failed to fetch album $albumId: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Failed to load album")
                val modifiedResult = fetchAlbumFromDatabase(albumId, result)
                return@withSuspendResult modifiedResult
            }
        }
    private fun fetchAlbumFromDatabase(albumId: Long, originalResult: Any): Any {
        try {
            loge("Fetching album with ID: $albumId from database")
            return runBlocking {
                val dao = GrindrPlus.database.albumDao()
                val album = dao.getAlbum(albumId)
                if (album != null) {
                    val content = dao.getAlbumContent(albumId)
                    var albumObject = getObjectField(originalResult, "a")
                    if (
                        albumObject != null && albumObject.javaClass.name == httpExceptionResponse
                    ) {
                        logw(
                            "Album object is HttpExceptionResponse, creating new Album from entity"
                        )
                        albumObject = album.toGrindrAlbumWithoutContent()
                    }
                    if (albumObject != null) {
                        setObjectField(albumObject, "albumId", albumId)
                        setObjectField(
                            albumObject,
                            "content",
                            content.map { it.toGrindrAlbumContent() }
                        )
                        setObjectField(albumObject, "albumViewable", true)
                        setObjectField(albumObject, "viewableUntil", Long.MAX_VALUE)
                        createSuccess(albumObject)
                    } else {
                        loge("Album is null, cannot set content")
                        originalResult
                    }
                } else {
                    logw("Album $albumId not found in database")
                    originalResult
                }
            }
        } catch (e: Exception) {
            loge("Failed to load album $albumId from database: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
            return originalResult
        }
    }
    private fun parseAlbumContent(albumId: Long, responseBody: String, originalResult: Any): Any {
        try {
            logd("Parsing album content for ID: $albumId")
            val jsonResponse = JSONObject(responseBody)
            jsonResponse.optJSONArray("content")?.let { contentArray ->
                logd("Content array found for album ID: $albumId")
                val albumContentEntities = mutableListOf<AlbumContentEntity>()
                for (i in 0 until contentArray.length()) {
                    try {
                        val contentJson = contentArray.getJSONObject(i)
                        val albumContentEntity =
                            AlbumContentEntity(
                                id = contentJson.optLong("contentId"),
                                albumId = albumId,
                                contentType = contentJson.optString("contentType"),
                                coverUrl = contentJson.optString("coverUrl"),
                                thumbUrl = contentJson.optString("thumbUrl"),
                                url = contentJson.optString("url")
                            )
                        albumContentEntities.add(albumContentEntity)
                    } catch (e: Exception) {
                        loge("Error parsing content item: ${e.message}")
                        Logger.writeRaw(e.stackTraceToString())
                    }
                }
                if (albumContentEntities.isNotEmpty()) {
                    logd("Saving album content for ID: $albumId")
                    try {
                        runBlocking { saveAlbumContent(albumId, albumContentEntities) }
                    } catch (e: Exception) {
                        loge("Failed to save album content: ${e.message}")
                        Logger.writeRaw(e.stackTraceToString())
                    }
                }
                try {
                    val grindrAlbumContentList =
                        albumContentEntities.map { it.toGrindrAlbumContent() }
                    val albumObject = getObjectField(originalResult, "a")
                    if (albumObject != null) {
                        logd("Setting album content for ID: $albumId")
                        setObjectField(albumObject, "content", grindrAlbumContentList)
                        return originalResult
                    } else {
                        loge("Album object not found in result for album ID: $albumId")
                    }
                } catch (e: Exception) {
                    loge("Error setting album content: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
                ?: run {
                    loge("Failed to parse content array for album ID: $albumId")
                    return fetchAlbumFromDatabase(albumId, originalResult)
                }
        } catch (e: Exception) {
            loge("Error parsing album content: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
            return fetchAlbumFromDatabase(albumId, originalResult)
        }
        return originalResult
    }
    @Suppress("UNCHECKED_CAST")
    private fun handleGetAlbums(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { args, result ->
            if (result.isSuccess()) {
                try {
                    val albums = getObjectField(result.getSuccessValue(), "albums") as? List<Any>
                    if (albums != null) {
                        runBlocking {
                            GrindrPlus.database.withTransaction {
                                albums.forEach { album ->
                                    try {
                                        saveAlbum(album)
                                    } catch (e: Exception) {
                                        loge("Error saving album: ${e.message}")
                                        Logger.writeRaw(e.stackTraceToString())
                                    }
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    loge("Error processing albums: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
            try {
                val albums = runBlocking {
                    GrindrPlus.database.withTransaction {
                        val dao = GrindrPlus.database.albumDao()
                        val dbAlbums = dao.getAlbums()
                        dbAlbums.mapNotNull {
                            try {
                                val dbContent = dao.getAlbumContent(it.id)
                                it.toGrindrAlbum(dbContent)
                            } catch (e: Exception) {
                                loge("Error converting album ${it.id}: ${e.message}")
                                Logger.writeRaw(e.stackTraceToString())
                                null
                            }
                        }
                    }
                }
                val newValue =
                    findClass(albumsList)
                        .getConstructor(List::class.java)
                        .newInstance(albums)
                createSuccess(newValue)
            } catch (e: Exception) {
                loge("Error creating albums list: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
                result
            }
        }
    @Suppress("UNCHECKED_CAST")
    private fun handleGetAlbumsShares(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { args, result ->
            logd("Fetching shared albums")
            if (result.isSuccess()) {
                try {
                    runBlocking {
                        GrindrPlus.database.withTransaction {
                            val dao = GrindrPlus.database.albumDao()
                            val albumBriefs =
                                getObjectField(result.getSuccessValue(), "albums") as? List<Any>
                            albumBriefs?.forEach { albumBrief ->
                                try {
                                    val albumEntity = albumBrief.asAlbumBriefToAlbumEntity()
                                    dao.upsertAlbum(albumEntity)
                                    val grindrAlbumContent = getObjectField(albumBrief, "content")
                                    if (grindrAlbumContent != null) {
                                        val dbAlbumContent =
                                            grindrAlbumContent.toAlbumContentEntity(albumEntity.id)
                                        dao.upsertAlbumContent(dbAlbumContent)
                                    }
                                } catch (e: Exception) {
                                    loge("Error processing album brief: ${e.message}")
                                    Logger.writeRaw(e.stackTraceToString())
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    loge("Error saving album briefs: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
            try {
                val albumBriefs = runBlocking {
                    GrindrPlus.database.withTransaction {
                        val dao = GrindrPlus.database.albumDao()
                        val dbAlbums = dao.getAlbums()
                        dbAlbums.mapNotNull {
                            try {
                                val dbContent = dao.getAlbumContent(it.id)
                                if (dbContent.isNotEmpty()) {
                                    it.toGrindrAlbumBrief(dbContent.first())
                                } else {
                                    logw("Album ${it.id} has no content")
                                    null
                                }
                            } catch (e: Exception) {
                                loge("Error converting album ${it.id} to brief: ${e.message}")
                                Logger.writeRaw(e.stackTraceToString())
                                null
                            }
                        }
                    }
                }
                val newValue =
                    findClass(sharedAlbumsBrief)
                        .getConstructor(List::class.java)
                        .newInstance(albumBriefs)
                createSuccess(newValue)
            } catch (e: Exception) {
                loge("Error creating shared albums brief: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
                result
            }
        }
    @Suppress("UNCHECKED_CAST")
    private fun handleGetAlbumsSharesProfileId(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { args, result ->
            logd("Fetching shared albums for profile ID")
            val profileId = args[0] as? Long ?: return@withSuspendResult result
            if (result.isSuccess()) {
                try {
                    runBlocking {
                        GrindrPlus.database.withTransaction {
                            val dao = GrindrPlus.database.albumDao()
                            val albumBriefs =
                                getObjectField(result.getSuccessValue(), "albums") as? List<Any>
                            albumBriefs?.forEach { albumBrief ->
                                try {
                                    val albumEntity = albumBrief.asAlbumBriefToAlbumEntity()
                                    dao.upsertAlbum(albumEntity)
                                    val grindrAlbumContent = getObjectField(albumBrief, "content")
                                    if (grindrAlbumContent != null) {
                                        val dbAlbumContent =
                                            grindrAlbumContent.toAlbumContentEntity(albumEntity.id)
                                        dao.upsertAlbumContent(dbAlbumContent)
                                    }
                                } catch (e: Exception) {
                                    loge("Error processing album brief: ${e.message}")
                                    Logger.writeRaw(e.stackTraceToString())
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    loge("Error saving album briefs: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
            try {
                val albumBriefs = runBlocking {
                    GrindrPlus.database.withTransaction {
                        val dao = GrindrPlus.database.albumDao()
                        val dbAlbums = dao.getAlbums(profileId)
                        dbAlbums.mapNotNull {
                            try {
                                val dbContent = dao.getAlbumContent(it.id)
                                if (dbContent.isNotEmpty()) {
                                    it.toGrindrAlbumBrief(dbContent.first())
                                } else {
                                    logw("Album ${it.id} has no content")
                                    null
                                }
                            } catch (e: Exception) {
                                loge("Error converting album ${it.id} to brief: ${e.message}")
                                Logger.writeRaw(e.stackTraceToString())
                                null
                            }
                        }
                    }
                }
                val newValue =
                    findClass(sharedAlbumsBrief)
                        .getConstructor(List::class.java)
                        .newInstance(albumBriefs)
                createSuccess(newValue)
            } catch (e: Exception) {
                loge("Error creating shared albums brief: ${e.message}")
                result
            }
        }
    private inline fun <T : Closeable?, R> T.use(block: (T) -> R): R {
        var closed = false
        try {
            return block(this)
        } catch (e: Exception) {
            closed = true
            try {
                this?.close()
            } catch (closeException: IOException) {
                e.addSuppressed(closeException)
            }
            throw e
        } finally {
            if (!closed) {
                this?.close()
            }
        }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\UnlimitedProfiles.kt --- 
package com.grindrplus.hooks
class UnlimitedProfiles : Hook(
    "Unlimited profiles",
    "Allow unlimited profiles"
) {
    private val function2 = "kotlin.jvm.functions.Function2"
    private val onProfileClicked = "com.grindrapp.android.ui.browse.E" // search for 'com.grindrapp.android.ui.browse.ServerDrivenCascadeViewModel$onProfileClicked$1'
    private val profileWithPhoto = "com.grindrapp.android.persistence.pojo.ProfileWithPhoto"
    private val serverDrivenCascadeCachedState =
        "com.grindrapp.android.persistence.model.serverdrivencascade.ServerDrivenCascadeCacheState"
    private val serverDrivenCascadeCachedProfile =
        "com.grindrapp.android.persistence.model.serverdrivencascade.ServerDrivenCascadeCachedProfile"
    private val profileTagCascadeFragment = "com.grindrapp.android.ui.tagsearch.ProfileTagCascadeFragment"
    override fun init() {
        findClass(serverDrivenCascadeCachedState)
            .hook("getItems", HookStage.AFTER) { param ->
                val items = (param.getResult() as List<*>).filter {
                    it?.javaClass?.name == serverDrivenCascadeCachedProfile
                }
                param.setResult(items)
            }
        findClass(profileTagCascadeFragment) // search for 'new StringBuilder("cascadeClickEvent/position=");'
            .hook("R", HookStage.BEFORE) { param ->
                param.setResult(true)
            }
        findClass(serverDrivenCascadeCachedProfile)
            .hook("getUpsellType", HookStage.BEFORE) { param ->
                param.setResult(null)
            }
        val profileClass = findClass("com.grindrapp.android.persistence.model.Profile")
        val profileWithPhotoClass = findClass(profileWithPhoto)
        val function2Class = findClass(function2)
        val flowKtClass = findClass("kotlinx.coroutines.flow.FlowKt")
        val profileRepoClass = findClass("com.grindrapp.android.persistence.repository.ProfileRepo")
        profileRepoClass.hook("getProfilesWithPhotosFlow", HookStage.AFTER) { param ->
            val requestedProfileIds = param.arg<List<String>>(0)
            if (requestedProfileIds.isEmpty()) return@hook
            val originalFlow = param.getResult()
            val profileWithPhotoConstructor = profileWithPhotoClass
                .getConstructor(profileClass, List::class.java)
            val profileConstructor = profileClass.getConstructor()
            val proxy = Proxy.newProxyInstance(
                GrindrPlus.classLoader,
                arrayOf(function2Class)
            ) { _, _, args ->
                @Suppress("UNCHECKED_CAST")
                val profilesWithPhoto = args[0] as List<Any>
                if (requestedProfileIds.size > profilesWithPhoto.size) {
                    val profileIds = ArrayList<String>(profilesWithPhoto.size)
                    for (profileWithPhoto in profilesWithPhoto) {
                        val profile = callMethod(profileWithPhoto, "getProfile")
                        profileIds.add(callMethod(profile, "getProfileId") as String)
                    }
                    val profileIdSet = profileIds.toHashSet()
                    val missingProfiles = ArrayList<Any>()
                    for (profileId in requestedProfileIds) {
                        if (profileId !in profileIdSet) {
                            val profile = profileConstructor.newInstance()
                            callMethod(profile, "setProfileId", profileId)
                            callMethod(profile, "setRemoteUpdatedTime", 1L)
                            callMethod(profile, "setLocalUpdatedTime", 0L)
                            missingProfiles.add(
                                profileWithPhotoConstructor.newInstance(profile, emptyList<Any>())
                            )
                        }
                    }
                    if (missingProfiles.isNotEmpty()) {
                        val result = ArrayList<Any>(profilesWithPhoto.size + missingProfiles.size)
                        result.addAll(profilesWithPhoto)
                        result.addAll(missingProfiles)
                        return@newProxyInstance result
                    }
                }
                profilesWithPhoto
            }
            val transformedFlow = callStaticMethod(flowKtClass, "mapLatest", originalFlow, proxy)
            param.setResult(transformedFlow)
        }
        findClass(onProfileClicked).hook("invokeSuspend", HookStage.BEFORE) { param ->
            if (Config.get("disable_profile_swipe", false) as Boolean) {
                getObjectField(param.thisObject(), param.thisObject().javaClass.declaredFields
                    .firstOrNull { it.type.name.contains("ServerDrivenCascadeCachedProfile") }?.name
                )?.let { cachedProfile ->
                    runCatching { getObjectField(cachedProfile, "profileIdLong").toString() }
                        .onSuccess { profileId ->
                            openProfile(profileId)
                            param.setResult(null)
                        }
                        .onFailure { loge("Profile ID not found in cached profile") }
                }
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\hooks\WebSocketAlive.kt --- 
package com.grindrplus.hooks
class WebSocketAlive : Hook(
    "Keep Alive WebSocket",
    "Prevents WebSocket disconnections when app goes to background. Causes battery drain, use with caution."
) {
    private val safeDkLifecycleManager = "com.safedk.android.internal.b"
    private val webSocketClientImpl = "com.grindrapp.android.network.websocket.WebSocketClientImpl"
    private val webSocketFactory = "Ab.p"
    override fun init() {
        hookSafeDkBackgroundDetection()
        hookWebSocketLifecycle()
        hookWebSocketFactory()
    }
    private fun hookSafeDkBackgroundDetection() {
        try {
            findClass(safeDkLifecycleManager).hook("isInBackground", HookStage.BEFORE) { param ->
                logd("Spoofing SafeDK background detection")
                param.setResult(false)
            }
            findClass(safeDkLifecycleManager).hook("a", HookStage.BEFORE) { param ->
                if (param.args().isNotEmpty()) {
                    val isBackground = param.arg<Boolean>(0)
                    if (isBackground) {
                        logd("Preventing SafeDK from setting background state")
                        param.setResult(null)
                    }
                } else {
                    logd("SafeDK method 'a' called with no parameters")
                    param.setResult(null)
                }
            }
            findClass(safeDkLifecycleManager).hook("b", HookStage.BEFORE) { param ->
                logd("Preventing SafeDK background identification")
                param.setResult(null)
            }
            findClass(safeDkLifecycleManager).hook("onActivityStopped", HookStage.BEFORE) { param ->
                logd("Intercepting SafeDK onActivityStopped")
                if (param.args().isNotEmpty()) {
                    handleActivityStopped(param as HookAdapter<Any>)
                }
                param.setResult(null)
            }
            findClass(safeDkLifecycleManager).hook("registerBackgroundForegroundListener", HookStage.AFTER) { param ->
                if (param.args().isNotEmpty()) {
                    val listener = param.arg<Any>(0)
                    try {
                        callMethod(listener, "h")
                    } catch (e: Exception) {
                        // that's fine, we just want to ensure the listener is registered
                    }
                }
            }
        } catch (e: Exception) {
            loge("Failed to hook SafeDK background detection: $e")
        }
    }
    private fun hookWebSocketLifecycle() {
        try {
            findClass(webSocketClientImpl).hook("disconnect", HookStage.BEFORE) { param ->
                if (isBackgroundTriggeredDisconnect()) {
                    logd("Preventing background-triggered WebSocket disconnect")
                    param.setResult(null)
                }
            }
            findClass(webSocketClientImpl).hook("d", HookStage.BEFORE) { param ->
                val code = param.arg<Int>(0)
                val reason = param.arg<String>(1)
                if (isBackgroundRelatedDisconnect(code, reason)) {
                    logd("Blocking background-related WebSocket disconnect: $reason")
                    param.setResult(null)
                }
            }
            findClass(webSocketClientImpl).hook("onClosed", HookStage.AFTER) { param ->
                val code = param.arg<Int>(1)
                val reason = param.arg<String>(2)
                if (shouldAutoReconnect(code, reason)) {
                    logd("Scheduling WebSocket auto-reconnect")
                    scheduleReconnection(param.thisObject(), 2000)
                }
            }
            findClass(webSocketClientImpl).hook("onFailure", HookStage.AFTER) { param ->
                val throwable = param.arg<Throwable>(1)
                val message = throwable.message?.lowercase() ?: ""
                if (isNetworkRelatedFailure(message)) {
                    logd("Scheduling WebSocket auto-reconnect after network failure")
                    scheduleReconnection(param.thisObject(), 5000)
                }
            }
            logi("Successfully hooked WebSocket lifecycle methods")
        } catch (e: Exception) {
            loge("Failed to hook WebSocket lifecycle: $e")
        }
    }
    private fun hookWebSocketFactory() {
        try {
            findClass(webSocketFactory).hook("a", HookStage.AFTER) { param ->
                val webSocketUrl = param.arg<String>(0)
                logd("WebSocket connection created to: $webSocketUrl")
            }
        } catch (e: Exception) {
            loge("Failed to hook WebSocket factory: $e")
        }
    }
    private fun handleActivityStopped(param: HookAdapter<Any>) {
        try {
            val thisObject = param.thisObject()
            val activity = param.arg<Activity>(0)
            val isBackgroundBefore = callMethod(thisObject, "isInBackground") as Boolean
            val backgroundField = thisObject.javaClass.getDeclaredField("g")
            backgroundField.isAccessible = true
            val isBackgroundAfter = backgroundField.getBoolean(thisObject)
            if (!isBackgroundBefore && isBackgroundAfter) {
                logd("Reverting background state change from SafeDK")
                backgroundField.setBoolean(thisObject, false)
            }
        } catch (e: Exception) {
            loge("Error in SafeDK onActivityStopped hook: $e")
        }
    }
    private fun isBackgroundTriggeredDisconnect(): Boolean {
        val stackTrace = Thread.currentThread().stackTrace
        return stackTrace.any {
            it.methodName.contains("background", ignoreCase = true) ||
                    it.methodName.contains("pause", ignoreCase = true) ||
                    it.className.contains("lifecycle", ignoreCase = true) ||
                    it.className.contains("safedk", ignoreCase = true)
        }
    }
    private fun isBackgroundRelatedDisconnect(code: Int, reason: String): Boolean {
        return reason.contains("background", ignoreCase = true) ||
                reason.contains("inactive", ignoreCase = true) ||
                reason.contains("idle", ignoreCase = true) ||
                code == 1001
    }
    private fun shouldAutoReconnect(code: Int, reason: String): Boolean {
        return code == 1001 ||
                reason.contains("background", ignoreCase = true) ||
                reason.contains("inactive", ignoreCase = true)
    }
    private fun isNetworkRelatedFailure(message: String): Boolean {
        return message.contains("network") ||
                message.contains("timeout") ||
                message.contains("connection reset") ||
                message.contains("socket closed")
    }
    private fun scheduleReconnection(webSocketClient: Any, delayMs: Long) {
        Handler(Looper.getMainLooper()).postDelayed({
            try {
                val urlField = webSocketClient.javaClass.getDeclaredField("c")
                urlField.isAccessible = true
                val authToken = urlField.get(webSocketClient) as? String
                if (authToken != null) {
                    callMethod(webSocketClient, "b", authToken)
                    logi("WebSocket reconnection initiated")
                } else {
                    logd("Cannot reconnect WebSocket - no auth token found")
                }
            } catch (e: Exception) {
                loge("Failed to auto-reconnect WebSocket: $e")
            }
        }, delayMs)
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\MainActivity.kt --- 
package com.grindrplus.manager
internal val activityScope = CoroutineScope(Dispatchers.Main + SupervisorJob())
internal const val TAG = "GrindrPlus"
internal const val DATA_URL =
    "https://raw.githubusercontent.com/R0rt1z2/GrindrPlus/refs/heads/master/manifest.json"
sealed class MainNavItem(
    val icon: ImageVector? = null,
    var title: String,
    val composable: @Composable PaddingValues.(Activity) -> Unit,
) {
    data object Settings :
        MainNavItem(Icons.Filled.Settings, "Settings", { SettingsScreen() })
    data object InstallPage :
        MainNavItem(Icons.Rounded.Download, "Install", { InstallPage(it, this) })
    data object Home : MainNavItem(Icons.Rounded.Home, "Home", { HomeScreen(this) })
    data object BlockLog : MainNavItem(Icons.Filled.History, "Block Log", { BlockLogScreen(this) })
    data object Notifications : MainNavItem(Icons.Filled.Newspaper, "News", { NotificationScreen(this) })
    // data object Albums : MainNavItem(Icons.Rounded.PhotoAlbum, "Albums", { ComingSoon() })
    // data object Experiments : MainNavItem(Icons.Rounded.Science, "Experiments", { ComingSoon() })
    companion object {
        val VALUES by lazy {
            listOf(InstallPage, BlockLog, Home, Notifications, Settings)
        }
    }
}
class MainActivity : ComponentActivity() {
    companion object {
        var plausible: Plausible? = null
        val showUninstallDialog = mutableStateOf(false)
    }
    private var showPermissionDialog by mutableStateOf(false)
    private lateinit var receiver: NotificationActionReceiver
    private val requestPermissionLauncher = registerForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { isGranted ->
        if (isGranted) {
            Logger.i("Notification permission granted")
        } else {
            Logger.w("Notification permission denied")
        }
    }
    private fun checkNotificationPermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            when {
                ContextCompat.checkSelfPermission(
                    this,
                    Manifest.permission.POST_NOTIFICATIONS
                ) == PackageManager.PERMISSION_GRANTED -> {
                    // Permission already granted
                    Logger.d("Notification permission already granted")
                }
                shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS) -> {
                    showPermissionDialog = true
                }
                else -> {
                    requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
                }
            }
        }
    }
    private fun checkUnknownSourcesPermission() {
        var allow = false
        allow = packageManager.canRequestPackageInstalls()
        if (!allow) {
            val intent = Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES).apply {
                data = "package:$packageName".toUri()
            }
            Toast.makeText(
                this,
                "Please allow unknown sources for GrindrPlus",
                Toast.LENGTH_LONG
            ).show()
            startActivity(intent)
        }
    }
    private fun checkStoragePermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) { // This permission is for Android 11+
            if (!android.os.Environment.isExternalStorageManager()) {
                val intent = Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION).apply {
                    data = "package:$packageName".toUri()
                }
                Toast.makeText(
                    this,
                    "GrindrPlus needs access to manage files",
                    Toast.LENGTH_LONG
                ).show()
                startActivity(intent)
            }
        }
    }
    private fun registerNotificationReceiver() {
        try {
            receiver = NotificationActionReceiver()
            val intentFilter = IntentFilter().apply {
                addAction("com.grindrplus.COPY_ACTION")
                addAction("com.grindrplus.VIEW_PROFILE_ACTION")
                addAction("com.grindrplus.CUSTOM_ACTION")
                addAction("com.grindrplus.DEFAULT_ACTION")
            }
            ContextCompat.registerReceiver(
                applicationContext,
                receiver,
                intentFilter,
                ContextCompat.RECEIVER_NOT_EXPORTED
            )
            Logger.i("Registered notification action receiver")
        } catch (e: Exception) {
            Logger.e("Failed to register receiver: ${e.message}")
        }
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Timber.plant(DebugTree())
        FileOperationHandler.init(this)
        registerNotificationReceiver()
        val isSystemInDarkTheme = resources.configuration.uiMode and
                android.content.res.Configuration.UI_MODE_NIGHT_MASK ==
                android.content.res.Configuration.UI_MODE_NIGHT_YES
        val statusBarStyle = if (isSystemInDarkTheme) {
            SystemBarStyle.dark(TRANSPARENT)
        } else {
            SystemBarStyle.light(TRANSPARENT, TRANSPARENT)
        }
        val navigationBarStyle = if (isSystemInDarkTheme) {
            SystemBarStyle.dark(TRANSPARENT)
        } else {
            SystemBarStyle.light(TRANSPARENT, TRANSPARENT)
        }
        enableEdgeToEdge(
            statusBarStyle = statusBarStyle,
            navigationBarStyle = navigationBarStyle
        )
        setContent {
            var serviceBound by remember { mutableStateOf(false) }
            var firstLaunchDialog by remember { mutableStateOf(false) }
            var patchInfoDialog by remember { mutableStateOf(false) }
            var showUninstallDialogState by remember { showUninstallDialog }
            var calculatorScreen = remember { mutableStateOf(false) }
// Inside the setContent block in onCreate
            LaunchedEffect(Unit) {
                GrindrPlus.bridgeClient = BridgeClient(this@MainActivity)
                GrindrPlus.bridgeClient.connectAsync { connected ->
                    Logger.initialize(this@MainActivity, GrindrPlus.bridgeClient, false)
                    Config.initialize() // [cite: 18]
                    HookManager().registerHooks(false)
                    TaskManager().registerTasks(false)
                    calculatorScreen.value = Config.get("discreet_icon", false) as Boolean
                    serviceBound = true
                    if (!(Config.get("disable_permission_checks", false) as Boolean)) { // [cite: 19]
                    // --- MODIFIED PERMISSION LOGIC ---
                    // Check for unknown sources first.
                    val hasUnknownSourcesPerm = packageManager.canRequestPackageInstalls()
                    if (!hasUnknownSourcesPerm) {
                        checkUnknownSourcesPermission()
                    } else {
                        // If unknown sources is already granted, check for storage permission.
                        checkStoragePermission()
                    }
                    // --- END OF MODIFICATION ---
                }
                    if (Config.get("analytics", true) as Boolean) { // [cite: 20]
                    val config = AndroidResourcePlausibleConfig(this@MainActivity).also {
                        it.domain = "grindrplus.lol"
                        it.host = "https://plausible.gmmz.dev/api/"
                        it.enable = true // [cite: 21]
                    }
                    plausible = Plausible(
                        config = config, // [cite: 22]
                        client = NetworkFirstPlausibleClient(config)
                    )
                    plausible?.enable(true)
                    plausible?.pageView( // [cite: 23]
                            "app://grindrplus/home",
                    props = mapOf("android_version" to Build.VERSION.SDK_INT)
                    )
                }
                    if (Config.get("first_launch", true) as Boolean) {
                        firstLaunchDialog = true
                        patchInfoDialog = true
                        plausible?.pageView("app://grindrplus/first_launch") // [cite: 25]
                        Config.put("first_launch", false)
                    }
                }
            }
            if (!serviceBound) {
                return@setContent
            }
            GrindrPlusTheme(
                dynamicColor = Config.get("material_you", false) as Boolean,
            ) {
                if (calculatorScreen.value) {
                    CalculatorScreen(calculatorScreen)
                    return@GrindrPlusTheme
                }
                if (showPermissionDialog) {
                    Dialog(
                        onDismissRequest = { showPermissionDialog = false }
                    ) {
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            shape = RoundedCornerShape(16.dp),
                        ) {
                            Column(
                                modifier = Modifier.padding(24.dp),
                                verticalArrangement = Center
                            ) {
                                Text(
                                    text = "Notification Permission",
                                    style = MaterialTheme.typography.headlineSmall,
                                    modifier = Modifier.padding(bottom = 16.dp)
                                )
                                Text(
                                    text = "GrindrPlus needs notification permission to alert you when someone blocks or unblocks you.",
                                    style = MaterialTheme.typography.bodyMedium,
                                    modifier = Modifier.padding(bottom = 16.dp)
                                )
                                Row(
                                    modifier = Modifier.fillMaxWidth(),
                                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                                ) {
                                    OutlinedButton(
                                        onClick = { showPermissionDialog = false },
                                        modifier = Modifier.weight(1f)
                                    ) {
                                        Text("Not now")
                                    }
                                    Button(
                                        onClick = {
                                            showPermissionDialog = false
                                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                                                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
                                            }
                                        },
                                        modifier = Modifier.weight(1f)
                                    ) {
                                        Text("Grant Access")
                                    }
                                }
                            }
                        }
                    }
                }
                if (firstLaunchDialog) {
                    Dialog(
                        onDismissRequest = { firstLaunchDialog = false }) {
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            shape = RoundedCornerShape(16.dp),
                        ) {
                            Column(
                                modifier = Modifier.padding(24.dp),
                                verticalArrangement = Center
                            ) {
                                Text(
                                    text = "Welcome to GrindrPlus!",
                                    style = MaterialTheme.typography.headlineSmall,
                                    modifier = Modifier.padding(bottom = 16.dp)
                                )
                                Text(
                                    text =
                                        "We collect totally anonymous data to improve the app.",
                                    style = MaterialTheme.typography.bodyMedium,
                                    modifier = Modifier.padding(bottom = 16.dp)
                                )
                                Text(
                                    text =
                                        "You can disable this in the settings.",
                                    style = MaterialTheme.typography.bodyMedium,
                                    fontWeight = FontWeight.Bold,
                                    modifier = Modifier.padding(bottom = 16.dp)
                                )
                                Text(
                                    text = "Data collected:",
                                    style = MaterialTheme.typography.bodyMedium,
                                    modifier = Modifier.padding(bottom = 8.dp)
                                )
                                Text(
                                    text = "• App opens\n• Installation success/failure\n• Eventual failure reason\n• Android version",
                                    style = MaterialTheme.typography.bodyMedium
                                )
                                Button(
                                    onClick = { firstLaunchDialog = false },
                                    modifier = Modifier
                                        .align(CenterHorizontally)
                                        .padding(top = 16.dp)
                                ) {
                                    Text("Ok, got it")
                                }
                            }
                        }
                    }
                    return@GrindrPlusTheme
                }
                if (showUninstallDialogState) {
                    Dialog(
                        onDismissRequest = { showUninstallDialogState = false }
                    ) {
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            shape = RoundedCornerShape(16.dp),
                        ) {
                            Column(
                                modifier = Modifier.padding(24.dp),
                                verticalArrangement = Center
                            ) {
                                Text(
                                    text = "Installation Error",
                                    style = MaterialTheme.typography.headlineSmall,
                                    modifier = Modifier.padding(bottom = 16.dp)
                                )
                                Text(
                                    text = "The installation failed because the app signatures don't match.",
                                    style = MaterialTheme.typography.bodyMedium,
                                    modifier = Modifier.padding(bottom = 16.dp)
                                )
                                Text(
                                    text = "Please uninstall Grindr manually first, then try the installation again.",
                                    style = MaterialTheme.typography.bodyMedium,
                                    fontWeight = FontWeight.Bold,
                                    modifier = Modifier.padding(bottom = 16.dp)
                                )
                                if (Build.MANUFACTURER.equals("samsung", ignoreCase = true)) {
                                    Text(
                                        text = "If you have Grindr installed in the Secure Folder, PLEASE UNINSTALL IT from there as well.",
                                        style = MaterialTheme.typography.bodyMedium,
                                        fontWeight = FontWeight.Bold,
                                        modifier = Modifier.padding(bottom = 16.dp)
                                    )
                                }
                                Row(
                                    modifier = Modifier.fillMaxWidth(),
                                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                                ) {
                                    OutlinedButton(
                                        onClick = { showUninstallDialogState = false },
                                        modifier = Modifier.weight(1f)
                                    ) {
                                        Text("Cancel")
                                    }
                                    Button(
                                        onClick = {
                                            try {
                                                val intent = Intent(Intent.ACTION_DELETE)
                                                intent.data = "package:$GRINDR_PACKAGE_NAME".toUri()
                                                startActivity(intent)
                                                showUninstallDialogState = false
                                            } catch (e: Exception) {
                                                Toast.makeText(
                                                    this@MainActivity,
                                                    "Error: ${e.localizedMessage}",
                                                    Toast.LENGTH_SHORT
                                                ).show()
                                            }
                                        },
                                        modifier = Modifier.weight(1f)
                                    ) {
                                        Text("Uninstall")
                                    }
                                }
                            }
                        }
                    }
                }
                if (patchInfoDialog) {
                    Dialog(
                        onDismissRequest = { patchInfoDialog = false }) {
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            shape = RoundedCornerShape(16.dp),
                        ) {
                            Column(
                                modifier = Modifier.padding(24.dp),
                                verticalArrangement = Center
                            ) {
                                Text(
                                    text = "Installation Method",
                                    style = MaterialTheme.typography.headlineSmall,
                                    modifier = Modifier.padding(bottom = 16.dp)
                                )
                                Text(
                                    text = "• If you were using LSPatch previously, go to the Install section and install the latest version.",
                                    style = MaterialTheme.typography.bodyMedium,
                                    modifier = Modifier.padding(bottom = 12.dp)
                                )
                                Text(
                                    text = buildAnnotatedString {
                                        append("• If you were using LSPosed, make sure the module is enabled in the LSPosed manager and Grindr app is within its scope. ")
                                        withStyle(style = SpanStyle(textDecoration = TextDecoration.Underline)) {
                                            append("Do not use the Install section if you're using LSPosed.")
                                        }
                                    },
                                    style = MaterialTheme.typography.bodyMedium,
                                    modifier = Modifier.padding(bottom = 16.dp)
                                )
                                Button(
                                    onClick = { patchInfoDialog = false },
                                    modifier = Modifier
                                        .align(CenterHorizontally)
                                        .padding(top = 8.dp)
                                ) {
                                    Text("Understood")
                                }
                            }
                        }
                    }
                }
                Surface(
                    modifier = Modifier.fillMaxSize(),
                ) {
                    val navController = rememberNavController()
                    Scaffold(
                        topBar = {
                        },
                        content = { innerPadding ->
                            NavHost(
                                navController,
                                startDestination = Home.toString()
                            ) {
                                for (item in MainNavItem.VALUES) {
                                    composable(item.toString()) {
                                        item.composable(
                                            innerPadding,
                                            this@MainActivity
                                        )
                                    }
                                }
                            }
                        },
                        bottomBar = {
                            BottomAppBar(modifier = Modifier) {
                                var selectedItem by remember { mutableIntStateOf(0) }
                                var currentRoute =
                                    navController.currentBackStackEntryAsState().value?.destination?.route
                                        ?: Home.toString()
                                    MainNavItem.VALUES.forEachIndexed { index, navigationItem ->
                                        if (navigationItem.toString() == currentRoute) {
                                            selectedItem = index
                                        }
                                    }
                                NavigationBar {
                                    MainNavItem.VALUES.forEachIndexed { index, item ->
                                        NavigationBarItem(
                                            alwaysShowLabel = true,
                                            icon = {
                                                Icon(
                                                    item.icon!!,
                                                    contentDescription = item.title
                                                )
                                            },
                                            label = { Text(item.title) },
                                            selected = selectedItem == index,
                                            onClick = {
                                                selectedItem = index
                                                currentRoute = item.toString()
                                                navController.navigateItem(item)
                                            }
                                        )
                                    }
                                }
                            }
                        }
                    )
                }
            }
        }
    }
    override fun onDestroy() {
        activityScope.cancel()
        try {
            if (::receiver.isInitialized) {
                applicationContext.unregisterReceiver(receiver)
                Logger.i("Unregistered notification action receiver")
            }
        } catch (e: Exception) {
            Logger.e("Error unregistering receiver: ${e.message}")
        }
        super.onDestroy()
    }
}
fun NavController.navigateItem(item: MainNavItem) {
    navigate(item.toString()) {
        graph.startDestinationRoute?.let { route ->
            popUpTo(route) {
                saveState = true
            }
        }
        launchSingleTop = true
        restoreState = true
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\PushNotifs.kt --- 
package com.grindrplus.manager
class GPlusMessage(
    val id: String,
    val content: String,
    val timestamp: Long
)
const val CHANNEL_PING_URL = "https://github.com/R0rt1z2/GrindrPlus/raw/refs/heads/master/news.json"
val tgMessages = MutableStateFlow<List<GPlusMessage>>(listOf())
suspend fun fetchNotifs(context: Context) = withContext(Dispatchers.IO) {
    val client = OkHttpClient.Builder()
        .callTimeout(1000.seconds.toJavaDuration()).build()
    val request = okhttp3.Request.Builder()
        .url(CHANNEL_PING_URL)
        .header(
            "User-Agent",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36"
        )
        .build()
    client.newCall(request).execute().use { response ->
        if (!response.isSuccessful) throw IOException("Unexpected code $response")
        tgMessages.value =
            response.body!!.string().replace("\n", "").split("|{").asSequence().drop(1)
                .map { "{$it" }
                .map {JsonParser.parseString(it).asJsonObject }
                .map { obj ->
                    GPlusMessage(
                        obj.get("message_id").asString,
                        obj.get("text").asString,
                        obj.get("date").asLong
                    )
                }
                .filterNot { it.content.isBlank() }
                .sortedBy { it.id }.toList()
        val msg = tgMessages.value.lastOrNull() ?: return@use
        if (Config.get("last_push_id", "") != msg.id) {
            Config.put("last_push_id", msg.id)
            if (msg.content.contains("#push"))
                sendNotification(context, msg.content.replace("#push", "").trim())
            else sendNotification(context)
        }
    }
}
fun sendNotification(
    context: Context,
    msg: String = "New message from GrindrPlus! Open News tab to read."
) {
    val nm = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    val channel = android.app.NotificationChannel(
        "update_gplus",
        "GPlus Updates",
        NotificationManager.IMPORTANCE_HIGH
    ).apply {
        description = "Notifications for GPlus communications"
    }
    nm.createNotificationChannel(channel)
    NotificationCompat.Builder(context, "update_gplus").apply {
        setSmallIcon(R.drawable.ic_launcher_foreground)
        setContentTitle("GrindrPlus News")
        setContentText(msg)
        setContentIntent(
            PendingIntent.getActivity(
                context,
                0,
                Intent(context, MainActivity::class.java),
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
        )
        setAutoCancel(true)
        setPriority(NotificationCompat.PRIORITY_MAX)
    }.also { nm.notify(1, it.build()) }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\blocks\BlockLogTypes.kt --- 
package com.grindrplus.manager.blocks
data class BlockEvent(
    val profileId: String,
    val displayName: String,
    val eventType: String,
    val timestamp: Long,
    val packageName: String? = null,
) 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\blocks\BlockLogViewModel.kt --- 
package com.grindrplus.manager.blocks
class BlockLogViewModel : ViewModel() {
    private val _isLoading = MutableStateFlow(true)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()
    private val _events = MutableStateFlow<List<BlockEvent>>(emptyList())
    val events: StateFlow<List<BlockEvent>> = _events.asStateFlow()
    private val _filters = MutableStateFlow(BlockLogFilters())
    val filters: StateFlow<BlockLogFilters> = _filters.asStateFlow()
    private val _filteredEvents = MutableStateFlow<List<BlockEvent>>(emptyList())
    val filteredEvents: StateFlow<List<BlockEvent>> = _filteredEvents.asStateFlow()
    private val _availablePackages = MutableStateFlow<List<String>>(emptyList())
    val availablePackages: StateFlow<List<String>> = _availablePackages.asStateFlow()
    init {
        viewModelScope.launch {
            events.collect { applyFilters() }
        }
        viewModelScope.launch {
            filters.collect { applyFilters() }
        }
    }
    private fun applyFilters() {
        val currentFilters = _filters.value
        val allEvents = _events.value
        _filteredEvents.value = allEvents
            .filter { event ->
                when (event.eventType) {
                    "block" -> currentFilters.showBlocks
                    "unblock" -> currentFilters.showUnblocks
                    else -> true
                }
            }
            .applyTimeFilter(currentFilters.timeRange)
            .let { events ->
                if (currentFilters.nameFilter.isNotEmpty()) {
                    events.filter {
                        it.displayName.contains(currentFilters.nameFilter, ignoreCase = true)
                    }
                } else {
                    events
                }
            }
            .let { events ->
                if (currentFilters.packageNameFilter.isNotEmpty()) {
                    events.filter { event ->
                        val eventPackage = event.packageName ?: AppCloneUtils.GRINDR_PACKAGE_NAME
                        currentFilters.packageNameFilter.contains(eventPackage)
                    }
                } else {
                    events
                }
            }
    }
    fun updateFilters(newFilters: BlockLogFilters) {
        _filters.value = newFilters
    }
    fun loadEvents() {
        viewModelScope.launch(Dispatchers.IO) {
            _isLoading.value = true
            try {
                val eventsArray = GrindrPlus.bridgeClient.getBlockEvents()
                val eventsList = mutableListOf<BlockEvent>()
                val packageSet = mutableSetOf<String>()
                packageSet.add("com.grindrapp.android")
                for (i in 0 until eventsArray.length()) {
                    val event = eventsArray.getJSONObject(i)
                    val packageName = event.optString("packageName", "com.grindrapp.android")
                    if (packageName.isNotEmpty()) {
                        packageSet.add(packageName)
                    }
                    eventsList.add(
                        BlockEvent(
                            profileId = event.getString("profileId"),
                            displayName = event.getString("displayName"),
                            eventType = event.getString("eventType"),
                            timestamp = event.getLong("timestamp"),
                            packageName = packageName
                        )
                    )
                }
                eventsList.sortByDescending { it.timestamp }
                _events.value = eventsList
                _availablePackages.value = packageSet.toList()
            } catch (e: Exception) {
                Logger.e("Failed to load block events: ${e.message}", LogSource.MANAGER)
                Logger.writeRaw(e.stackTraceToString())
            } finally {
                _isLoading.value = false
            }
        }
    }
    fun clearEvents() {
        viewModelScope.launch(Dispatchers.IO) {
            try {
                GrindrPlus.bridgeClient.clearBlockEvents()
                loadEvents()
            } catch (e: Exception) {
                Logger.e("Failed to clear block events: ${e.message}", LogSource.MANAGER)
                Logger.writeRaw(e.stackTraceToString())
            }
        }
    }
    fun exportEventsJson(): String {
        val eventsToExport = _filteredEvents.value.ifEmpty { _events.value }
        val jsonArray = JSONArray()
        eventsToExport.forEach { event ->
            val jsonObject = JSONObject()
            jsonObject.put("profileId", event.profileId)
            jsonObject.put("displayName", event.displayName)
            jsonObject.put("eventType", event.eventType)
            jsonObject.put("timestamp", event.timestamp)
            event.packageName?.let {
                jsonObject.put("packageName", it)
            }
            jsonArray.put(jsonObject)
        }
        return jsonArray.toString(4)
    }
    fun exportEventsToFile(context: Context) {
        val jsonContent = exportEventsJson()
        val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(Date())
        val filename = "block_events_$timestamp.json"
        FileOperationHandler.exportFile(filename, jsonContent)
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\installation\Installation.kt --- 
package com.grindrplus.manager.installation
typealias Print = (String) -> Unit
class Installation(
    private val context: Context,
    val version: String,
    modUrl: String,
    grindrUrl: String,
    private val mapsApiKey: String?
) {
    private val keyStoreUtils = KeyStoreUtils(context)
    private val folder = context.getExternalFilesDir(null) ?: throw IOException("External files directory not available")
    private val unzipFolder = File(folder, "splitApks/").also { it.mkdirs() }
    private val outputDir = File(folder, "LSPatchOutput/").also { it.mkdirs() }
    private val modFile = File(folder, "mod-$version.zip")
    private val bundleFile = File(folder, "grindr-$version.zip")
    private val installStep = InstallApkStep(outputDir)
    // --- UPDATE STEP INSTANTIATION AND ORDER ---
    // 1. ModXMLStep reads from unzipFolder and writes to outputDir
    private val modXmlStep = ModXMLStep(unzipFolder, outputDir)
    // 2. PatchApkStep now reads from outputDir and writes back to outputDir
    private val patchApkStep = PatchApkStep(outputDir, outputDir, modFile, keyStoreUtils.keyStore, mapsApiKey)
    // --- END UPDATE ---
    private val commonSteps = listOf(
        CheckStorageSpaceStep(folder),
        DownloadStep(bundleFile, grindrUrl, "Grindr bundle"),
        DownloadStep(modFile, modUrl, "mod"),
        ExtractBundleStep(bundleFile, unzipFolder),
    )
    suspend fun install(print: Print) = performOperation(
        // --- UPDATE STEP ORDER ---
        steps = commonSteps + listOf(modXmlStep, patchApkStep, installStep),
        operationName = "install-$version",
        print = print,
    )
    suspend fun cloneGrindr(
        packageName: String,
        appName: String,
        debuggable: Boolean,
        embedLSpatch: Boolean,
        print: Print,
    ) = performOperation(
        steps = commonSteps + listOf(
            CloneGrindrStep(unzipFolder, packageName, appName, debuggable),
            SignClonedGrindrApk(keyStoreUtils, unzipFolder),
            ModXMLStep(unzipFolder, outputDir),
            PatchApkStep(outputDir, outputDir, modFile, keyStoreUtils.keyStore, mapsApiKey, embedLSpatch),
            installStep
        ),
        operationName = "clone",
        print = print,
    )
    suspend fun installCustom(
        bundleFile: File,
        modFile: File,
        print: Print
    ) = performOperation(
        steps = listOf(
            CheckStorageSpaceStep(folder),
            ExtractBundleStep(bundleFile, unzipFolder),
            ModXMLStep(unzipFolder, outputDir),
            // Add manual signing step with your keystore details
            ManualSigningStep(
                outputDir,
                keyStoreUtils.keyStore,
                "Alias",      // Replace with your actual alias
                "password"    // Replace with your actual password
            ),
            PatchApkStep(outputDir, outputDir, modFile, keyStoreUtils.keyStore, mapsApiKey),
            installStep
        ),
        operationName = "custom_install",
        print = print
    )
    // ... (rest of the Installation.kt file is unchanged) ...
    suspend fun performOperation(
        steps: List<Step>,
        operationName: String,
        onSuccess: suspend () -> Unit = {},
        print: Print,
    ) = try {
        withContext(Dispatchers.IO) {
            plausible?.pageView("app://grindrplus/$operationName")
            val time = measureTimeMillis {
                for (step in steps) {
                    print("Executing step: ${step.name}")
                    val time = measureTimeMillis {
                        step.execute(context, print)
                    }
                    print("Step ${step.name} completed in ${time / 1000} seconds")
                }
            }
            plausible?.event(
                "${operationName}_success",
                "app://grindrplus/${operationName}_success",
                props = mapOf("time" to time)
            )
            onSuccess()
        }
    } catch (e: CancellationException) {
        print("$operationName was cancelled"); showToast("$operationName was cancelled")
        plausible?.event("${operationName}_cancelled", "app://grindrplus/${operationName}_cancelled")
        throw e
    } catch (e: Exception) {
        val errorMsg = "$operationName failed: ${e.localizedMessage}"
        plausible?.event(
            "${operationName}_failed",
            "app://grindrplus/${operationName}_failure",
            props = mapOf("error" to e.message)
        )
        print(errorMsg); showToast(errorMsg); cleanupOnFailure(); throw e
    }
    private fun cleanupOnFailure() {
        try {
            unzipFolder.listFiles()?.forEach { it.delete() }
            outputDir.listFiles()?.forEach { it.delete() }
            if (bundleFile.exists() && bundleFile.length() <= 100) bundleFile.delete()
            if (modFile.exists() && modFile.length() <= 100) modFile.delete()
        } catch (_: Exception) {}
    }
    fun showToast(message: String) {
        CoroutineScope(Dispatchers.Main).launch {
            Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
        }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\installation\Step.kt --- 
package com.grindrplus.manager.installation
interface Step {
    val name: String
    suspend fun execute(context: Context, print: Print)
}
abstract class BaseStep : Step {
    override suspend fun execute(context: Context, print: Print) {
        try {
            print("===== STEP: $name =====")
            withContext(Dispatchers.IO) {
                doExecute(context, print)
            }
            print("===== COMPLETED: $name =====")
        } catch (e: Exception) {
            print("===== FAILED: $name =====")
            throw IOException("$name failed: ${e.localizedMessage}")
        }
    }
    protected abstract suspend fun doExecute(context: Context, print: Print)
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\installation\steps\CheckStorageSpaceStep.kt --- 
package com.grindrplus.manager.installation.steps
// 1st
class CheckStorageSpaceStep(private val installFolder: File) : BaseStep() {
    override val name = "Checking system resources"
    override suspend fun doExecute(
        context: Context,
        print: Print,
    ) {
        val required = 200 * 1024 * 1024
        val availableStorage = StorageUtils.getAvailableSpace(installFolder)
        print("Available storage space: ${availableStorage / 1024 / 1024}MB")
        if (availableStorage < required) {
            throw IOException("Not enough storage space. Need ${required / 1024 / 1024}MB, but only ${availableStorage / 1024 / 1024}MB available.")
        }
        val availableRam = try {
            val activityManager =
                context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
            val memoryInfo = ActivityManager.MemoryInfo()
            activityManager.getMemoryInfo(memoryInfo)
            memoryInfo.availMem
        } catch (e: Exception) {
            Logger.e("Error getting available RAM: ${e.message}")
            0L
        }
        print("Available RAM: ${availableRam / 1024 / 1024}MB")
        if (availableRam < required) {
            throw IOException("Not enough RAM. Need ${required / 1024 / 1024}MB, but only ${availableRam / 1024 / 1024}MB available.")
        }
        print("System resource checks passed")
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\installation\steps\CloneGrindrStep.kt --- 
package com.grindrplus.manager.installation.steps
class CloneGrindrStep(
    val folder: File,
    val packageName: String,
    val appName: String,
    val debuggable: Boolean,
) : BaseStep() {
    override suspend fun doExecute(
        context: Context,
        print: Print,
    ) {
        print("Cloning Grindr APK...")
        for (file in folder.listFiles()!!) {
            if (!file.name.endsWith(".apk")) {
                print("Skipping ${file.name} as it is not an APK")
                continue
            }
            val manifest = ZipFile(file)
                .use { zip ->
                    zip.getEntry("AndroidManifest.xml")?.let { entry ->
                        zip.getInputStream(entry).use { it.readBytes() }
                    }
                }
                ?: throw IllegalStateException("No manifest in ${file.name}")
            ZipWriter(file, true).use { zip ->
                print("Changing package and app name in ${file.name}")
                val patchedManifestBytes = if (file.name.contains("base")) {
                    ManifestPatcher.patchManifest(
                        manifestBytes = manifest,
                        packageName = packageName,
                        appName = appName,
                        debuggable = debuggable,
                    )
                } else {
                    print("Changing package name in ${file.name}")
                    ManifestPatcher.renamePackage(manifest, packageName)
                }
                print("Deleting old AndroidManifest.xml in ${file.name}")
                zip.deleteEntry(
                    "AndroidManifest.xml",
                    /* fillVoid = */ true //TODO: maybe
                ) // Preserve alignment in libs apk
                print("Adding patched AndroidManifest.xml in ${file.name}")
                zip.writeEntry("AndroidManifest.xml", patchedManifestBytes)
            }
        }
        print("Cloning Grindr APK completed")
    }
    override val name = "Clone grindr apk"
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\installation\steps\DownloadStep.kt --- 
package com.grindrplus.manager.installation.steps
// 2nd for Grindr, 4th for mod
class DownloadStep(
    private val file: File,
    private val url: String,
    private val fileType: String
) : BaseStep() {
    override val name = "Downloading $fileType"
    override suspend fun doExecute(context: Context, print: Print) {
        print("Downloading $fileType file...")
        if (file.exists() && file.length() > 0) {
            if (validateFile(file)) {
                print("Existing $fileType file found, skipping download")
                return
            } else {
                Timber.tag("Download").w("Existing file ${file.name} is corrupt, redownloading")
                file.delete()
            }
        }
        val result = download(context, file, url, print)
        if (!result.success || !file.exists() || file.length() <= 0) {
            throw IOException("Failed to download $fileType, reason ${result.reason}")
        }
        val sizeMB = file.length() / 1024 / (if (fileType == "mod") 1 else 1024)
        print("$fileType download completed (${sizeMB}${if (fileType == "mod") "KB" else "MB"})")
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\installation\steps\ExtractBundleStep.kt --- 
package com.grindrplus.manager.installation.steps
// 3rd
class ExtractBundleStep(
    private val bundleFile: File,
    private val unzipFolder: File
) : BaseStep() {
    override val name = "Extracting Bundle"
    override suspend fun doExecute(context: Context, print: Print) {
        try {
            print("Cleaning extraction directory...")
            unzipFolder.listFiles()?.forEach { it.delete() }
            print("Extracting bundle archive...")
            bundleFile.unzip(unzipFolder)
            val apkFiles = unzipFolder.listFiles()?.filter { it.name.endsWith(".apk") } ?: emptyList()
            if (apkFiles.isEmpty()) {
                throw IOException("No APK files found in the bundle archive")
            }
            print("Successfully extracted ${apkFiles.size} APK files")
            apkFiles.forEachIndexed { index, file ->
                print("  ${index + 1}. ${file.name} (${file.length() / 1024}KB)")
            }
        } catch (e: Exception) {
            throw IOException("Failed to extract bundle file: ${e.localizedMessage}")
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\installation\steps\InstallApkStep.kt --- 
package com.grindrplus.manager.installation.steps
class InstallApkStep(
    private val outputDir: File
) : BaseStep() {
    override val name = "Installing Grindr APK"
    private companion object {
        const val TAG = "InstallApkStep"
    }
    override suspend fun doExecute(context: Context, print: Print) {
        print("Starting APK installation process...")
        val patchedFiles = outputDir.listFiles()?.toList() ?: emptyList()
        if (patchedFiles.isEmpty()) {
            throw IOException("No patched APK files found for installation in ${outputDir.absolutePath}")
        }
        print("Found ${patchedFiles.size} files in output directory:")
        patchedFiles.forEach { file ->
            print("  - ${file.name} (${file.length()} bytes)")
        }
        val filteredApks = patchedFiles.filter {
            it.name.endsWith(".apk") && it.exists() && it.length() > 0
        }
        if (filteredApks.isEmpty()) {
            throw IOException("No valid APK files found for installation. Checked ${patchedFiles.size} files.")
        }
        print("Starting installation of ${filteredApks.size} APK files")
        filteredApks.forEachIndexed { index, file ->
            print("  Installing (${index + 1}/${filteredApks.size}): ${file.name} (${file.length()} bytes)")
            // Verify each APK before installation
            if (!file.exists()) {
                throw IOException("APK file disappeared: ${file.absolutePath}")
            }
            if (file.length() == 0L) {
                throw IOException("APK file is empty: ${file.absolutePath}")
            }
        }
        print("Launching installer...")
        var installationSuccess = false
        var installationError: String? = null
        val success = SessionInstaller().installApks(
            context,
            filteredApks,
            false,
            log = { message ->
                print("INSTALLER: $message")
                Log.i(TAG, "Installer: $message")
            },
            callback = { success, message ->
                installationSuccess = success
                installationError = message
                if (success) {
                    print("✅ APK installation completed successfully")
                    Log.i(TAG, "Installation completed successfully")
                } else {
                    print("❌ APK installation failed: $message")
                    Log.e(TAG, "Installation failed: $message")
                }
            }
        )
        if (!success) {
            val errorMsg = installationError ?: "Unknown installation error"
            throw IOException("Installation failed: $errorMsg")
        }
        if (!installationSuccess) {
            val errorMsg = installationError ?: "Installation callback reported failure"
            throw IOException("Installation failed: $errorMsg")
        }
        print("🎉 APK installation completed successfully!")
        print("Installed ${filteredApks.size} APK files:")
        filteredApks.forEach { file ->
            print("  ✅ ${file.name}")
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\installation\steps\ManualSigningStep.kt --- 
package com.grindrplus.manager.installation.steps
class ManualSigningStep(
    private val inputDir: File,
    private val keyStore: File,
    private val keyAlias: String = "Alias",
    private val keyPassword: String = "password"
) : BaseStep() {
    override val name = "Manual APK Signing"
    override suspend fun doExecute(context: Context, print: Print) {
        val baseApk = File(inputDir, "base.apk")
        if (!baseApk.exists()) {
            throw IOException("base.apk not found for signing")
        }
        // Wait for user confirmation
        print("⏸️ PAUSED: Please sign the APK manually")
        print("APK location: ${baseApk.absolutePath}")
        print("Using keystore: ${keyStore.name}")
        print("Press OK when signing is complete...")
        // Wait for user to manually sign and confirm
        waitForUserConfirmation(context, baseApk.absolutePath)
        if (!baseApk.exists()) {
            throw IOException("APK was deleted during manual signing")
        }
        print("✅ APK ready for LSPatch - assuming signing completed")
    }
    private suspend fun waitForUserConfirmation(context: Context, apkPath: String) {
        val channel = Channel<Boolean>()
        withContext(Dispatchers.Main) {
            androidx.appcompat.app.AlertDialog.Builder(context)
                .setTitle("Manual Signing Required")
                .setMessage("Please sign the APK using:\n\njarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore \"${keyStore.absolutePath}\" \"$apkPath\" \"$keyAlias\"\n\nOR use apksigner:\n\napksigner sign --ks \"${keyStore.absolutePath}\" --ks-key-alias \"$keyAlias\" \"$apkPath\"\n\nPress OK when done.")
                .setPositiveButton("OK") { _, _ ->
                    channel.trySend(true)
                }
                .setCancelable(false)
                .show()
        }
        channel.receive()
        channel.close()
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\installation\steps\ModXmlStep.kt --- 
package com.grindrplus.manager.installation.steps
private const val TYPE_STRING = 3
private const val TYPE_INT_BOOLEAN = 18
class ModXMLStep(
    private val unzipFolder: File,
    private val outputDir: File
) : BaseStep() {
    override val name = "Modifying APK XML Resources (AXML)"
    private companion object {
        const val ANDROID_NAMESPACE = "http://schemas.android.com/apk/res/android"
        const val DEBUGGABLE = "debuggable"
        const val USES_CLEARTEXT_TRAFFIC = "usesCleartextTraffic"
        const val REQUEST_LEGACY_EXTERNAL_STORAGE = "requestLegacyExternalStorage"
        const val FILE_PROVIDER_PATHS_RESOURCE_NAME = "file_paths_grindrplus"
        const val TAG = "ModXMLStep"
    }
    private class PassThroughVisitor(nv: NodeVisitor) : NodeVisitor(nv) {
        override fun child(ns: String?, name: String?): NodeVisitor {
            return PassThroughVisitor(super.child(ns, name))
        }
    }
    override suspend fun doExecute(context: Context, print: Print) {
        print("Starting targeted XML resource modification for base.apk using AXML framework...")
        outputDir.listFiles()?.forEach {
            if (it.isFile) {
                print("Deleting existing file: ${it.name}")
                it.delete()
            }
        }
        val apkFilesToProcess = unzipFolder.listFiles()?.filter { it.name.endsWith(".apk") && it.exists() && it.length() > 0 }
        if (apkFilesToProcess.isNullOrEmpty()) {
            throw IOException("No APK files found in unzip directory to modify.")
        }
        print("Found ${apkFilesToProcess.size} APK files to process")
        val baseApk = findBaseApkWithResources(apkFilesToProcess, print)
        print("Selected ${baseApk.name} for XML patching (${baseApk.length()} bytes)")
        val outputFile = File(outputDir, baseApk.name)
        try {
            modifyApk(baseApk, outputFile, print)
            print("✅ XML modification completed successfully")
            print("Output file: ${outputFile.name} (${outputFile.length()} bytes)")
        } catch (e: Exception) {
            print("❌ XML modification failed: ${e.message}")
            Log.e(TAG, "XML modification failed", e)
            throw e
        }
    }
    private fun findBaseApkWithResources(apkFiles: List<File>, print: Print): File {
        val baseApk = apkFiles.find { it.name == "base.apk" }
        if (baseApk != null && containsManifestAndResources(baseApk)) {
            print("Found base.apk with resources.")
            return baseApk
        }
        return apkFiles.firstOrNull { containsManifestAndResources(it) }
            ?: apkFiles.firstOrNull { containsManifest(it) }
            ?: throw IOException("No suitable APK with AndroidManifest.xml found.")
    }
    private fun containsManifest(apkFile: File): Boolean {
        try {
            ZipInputStream(apkFile.inputStream().buffered()).use { zis ->
                return generateSequence { zis.nextEntry }.any { it.name == "AndroidManifest.xml" }
            }
        } catch (e: Exception) { return false }
    }
    private fun containsManifestAndResources(apkFile: File): Boolean {
        try {
            var hasManifest = false
            var hasResources = false
            ZipInputStream(apkFile.inputStream().buffered()).use { zis ->
                generateSequence { zis.nextEntry }.forEach { entry ->
                    when {
                        entry.name == "AndroidManifest.xml" -> hasManifest = true
                        entry.name.startsWith("res/xml/") -> hasResources = true
                    }
                }
            }
            return hasManifest && hasResources
        } catch (e: Exception) { return false }
    }
    private fun modifyApk(inputFile: File, outputFile: File, print: Print) {
        var manifestBytes: ByteArray? = null
        print("Step 1: Extracting AndroidManifest.xml from ${inputFile.name}")
        ZipInputStream(inputFile.inputStream().buffered()).use { zis ->
            generateSequence { zis.nextEntry }.find { it.name == "AndroidManifest.xml" }?.let {
                print("  Found AndroidManifest.xml, extracting...")
                val baos = ByteArrayOutputStream()
                zis.copyTo(baos)
                manifestBytes = baos.toByteArray()
                print("  Extracted ${manifestBytes!!.size} bytes")
            }
        }
        if (manifestBytes == null) throw IOException("AndroidManifest.xml not found in ${inputFile.name}")
        val packageName = getPackageName(manifestBytes!!)
        print("Step 2: Found package name: $packageName")
        print("Step 3: Patching AndroidManifest.xml")
        val patchedManifestBytes = patchAndroidManifest(manifestBytes!!, packageName, print)
        print("  Patched manifest: ${patchedManifestBytes.size} bytes")
        val broadAccessPathsXml = """<?xml version="1.0" encoding="utf-8"?><paths><root-path name="root" path="."/><files-path name="all_files" path="/"/><cache-path name="all_cache" path="/"/><external-files-path name="all_external_files" path="/"/><external-cache-path name="all_external_cache" path="/"/><external-path name="all_external" path="/"/></paths>""".toByteArray()
        val filesToOverwriteOrAdd = mapOf(
            "res/xml/library_file_paths.xml" to broadAccessPathsXml,
            "res/xml/provider_paths.xml" to broadAccessPathsXml,
            "res/xml/$FILE_PROVIDER_PATHS_RESOURCE_NAME.xml" to broadAccessPathsXml
        )
        print("Step 4: Creating modified APK...")
        ZipOutputStream(outputFile.outputStream().buffered()).use { zos ->
            val processedEntries = mutableSetOf<String>()
            ZipInputStream(inputFile.inputStream().buffered()).use { zis ->
                generateSequence { zis.nextEntry }.forEach { entry ->
                    val entryName = entry.name
                    processedEntries.add(entryName)
                    when {
                        entryName == "AndroidManifest.xml" -> {
                            zos.putNextEntry(ZipEntry(entryName))
                            zos.write(patchedManifestBytes)
                        }
                        filesToOverwriteOrAdd.containsKey(entryName) -> {
                            zos.putNextEntry(ZipEntry(entryName))
                            zos.write(filesToOverwriteOrAdd[entryName]!!)
                        }
                        else -> {
                            zos.putNextEntry(ZipEntry(entry.name))
                            zis.copyTo(zos)
                        }
                    }
                    zos.closeEntry()
                }
            }
            filesToOverwriteOrAdd.forEach { (path, bytes) ->
                if (!processedEntries.contains(path)) {
                    print("  Adding new file: $path (${bytes.size} bytes)")
                    zos.putNextEntry(ZipEntry(path))
                    zos.write(bytes)
                    zos.closeEntry()
                }
            }
        }
    }
    private fun getPackageName(manifestBytes: ByteArray): String {
        var packageName = ""
        AxmlReader(manifestBytes).accept(object : AxmlVisitor() {
            override fun child(ns: String?, name: String?) = if (name == "manifest") object : NodeVisitor() {
                override fun attr(ns: String?, name: String?, resourceId: Int, type: Int, value: Any?) {
                    if (name == "package") packageName = value as String
                }
            } else super.child(ns, name)
        })
        return packageName
    }
    private fun patchAndroidManifest(manifestBytes: ByteArray, packageName: String, print: Print): ByteArray {
        val writer = AxmlWriter()
        val modifications = mutableListOf<String>()
        AxmlReader(manifestBytes).accept(object : AxmlVisitor(writer) {
            override fun child(ns: String?, name: String?): NodeVisitor {
                val manifestNode = super.child(ns, name)
                return if (name == "manifest") {
                    object : NodeVisitor(manifestNode) {
                        override fun child(ns: String?, name: String): NodeVisitor {
                            val childVisitor = super.child(ns, name)
                            return when (name) {
                                "application" -> createApplicationNodeVisitor(childVisitor, packageName, modifications)
                                else -> PassThroughVisitor(childVisitor)
                            }
                        }
                        override fun end() {
                            val permVisitor = super.child(null, "uses-permission")
                            permVisitor.attr(ANDROID_NAMESPACE, "name", -1, TYPE_STRING, Manifest.permission.MANAGE_EXTERNAL_STORAGE)
                            permVisitor.end()
                            modifications.add("Added MANAGE_EXTERNAL_STORAGE permission")
                            super.end()
                        }
                    }
                } else {
                    manifestNode
                }
            }
        })
        print("Manifest modifications applied:")
        modifications.distinct().forEach { mod -> print("  - $mod") }
        return writer.toByteArray()
    }
    private fun createApplicationNodeVisitor(parentVisitor: NodeVisitor, packageName: String, modifications: MutableList<String>): NodeVisitor {
        return object : NodeVisitor(parentVisitor) {
            override fun child(ns: String?, name: String): NodeVisitor {
                val childNv = super.child(ns, name)
                if (name == "provider") {
                    return createProviderNodeVisitor(childNv, packageName, modifications)
                }
                return childNv
            }
            override fun end() {
                attr(ANDROID_NAMESPACE, DEBUGGABLE, -1, TYPE_INT_BOOLEAN, 1)
                attr(ANDROID_NAMESPACE, USES_CLEARTEXT_TRAFFIC, -1, TYPE_INT_BOOLEAN, 1)
                attr(ANDROID_NAMESPACE, REQUEST_LEGACY_EXTERNAL_STORAGE, -1, TYPE_INT_BOOLEAN, 1)
                modifications.add("Set application attributes: debuggable, usesCleartextTraffic, requestLegacyExternalStorage to true")
                super.end()
            }
        }
    }
    private fun createProviderNodeVisitor(parentVisitor: NodeVisitor, packageName: String, modifications: MutableList<String>): NodeVisitor {
        return object : NodeVisitor(parentVisitor) {
            var providerName: String? = null
            var isTargetProvider = false
            override fun attr(ns: String?, name: String, resourceId: Int, type: Int, value: Any?) {
                if (name == "name") {
                    providerName = value as? String
                    isTargetProvider = providerName in listOf("androidx.core.content.FileProvider", "com.canhub.cropper.CropFileProvider")
                }
                val finalValue = if (name == "authorities" && isTargetProvider) {
                    val newValue = (value as String).replace(packageName, "$packageName.grindrplus")
                    modifications.add("Updated provider authorities for $providerName: $newValue")
                    newValue
                } else {
                    value
                }
                super.attr(ns, name, resourceId, type, finalValue)
            }
            override fun child(ns: String?, name: String): NodeVisitor {
                val metaNv = super.child(ns, name)
                if (name == "meta-data" && isTargetProvider) {
                    return createMetaDataNodeVisitor(metaNv, modifications)
                }
                return metaNv
            }
            override fun end() {
                if (isTargetProvider) {
                    attr(ANDROID_NAMESPACE, "exported", -1, TYPE_INT_BOOLEAN, 0)
                    attr(ANDROID_NAMESPACE, "grantUriPermissions", -1, TYPE_INT_BOOLEAN, 1)
                    modifications.add("Ensured $providerName is not exported and grants URI permissions")
                }
                super.end()
            }
        }
    }
    private fun createMetaDataNodeVisitor(parentVisitor: NodeVisitor, modifications: MutableList<String>): NodeVisitor {
        return object : NodeVisitor(parentVisitor) {
            val attributes = mutableListOf<Triple<Triple<String?, String, Int>, Int, Any?>>()
            var isFilePathsTag = false
            override fun attr(ns: String?, name: String, resourceId: Int, type: Int, value: Any?) {
                attributes.add(Triple(Triple(ns, name, resourceId), type, value))
                if (name == "name" && value == "android.support.FILE_PROVIDER_PATHS") {
                    isFilePathsTag = true
                }
            }
            override fun end() {
                for (attr in attributes) {
                    val (attrInfo, type, value) = attr
                    val (ns, name, resId) = attrInfo
                    // *** FIX IS HERE ***
                    // If this is the resource attribute we want to change, modify its value and type before writing it.
                    if (isFilePathsTag && name == "resource") {
                        super.attr(ns, name, resId, TYPE_STRING, "@xml/$FILE_PROVIDER_PATHS_RESOURCE_NAME")
                        modifications.add("Updated FILE_PROVIDER_PATHS resource")
                    } else {
                        // Otherwise, write the attribute as it was.
                        super.attr(ns, name, resId, type, value)
                    }
                }
                super.end()
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\installation\steps\NumberUtil.kt --- 
package com.grindrplus.manager.installation.steps
private val ones = arrayOf(
    "",
    "One",
    "Two",
    "Three",
    "Four",
    "Five",
    "Six",
    "Seven",
    "Eight",
    "Nine",
    "Ten",
    "Eleven",
    "Twelve",
    "Thirteen",
    "Fourteen",
    "Fifteen",
    "Sixteen",
    "Seventeen",
    "Eighteen",
    "Nineteen"
)
private val tens =
    arrayOf("", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety")
tailrec fun numberToWords(num: Int, result: String = ""): String {
    return when {
        num == 0 && result == "" -> "Zero" // base case
        num == 0 -> result.trim() // final result
        num >= 1000000000 -> numberToWords(
            num % 1000000000,
            result + numberToWords(num / 1000000000) + " Billion "
        )
        num >= 1000000 -> numberToWords(
            num % 1000000,
            result + numberToWords(num / 1000000) + " Million "
        )
        num >= 1000 -> numberToWords(num % 1000, result + numberToWords(num / 1000) + " Thousand ")
        num >= 100 -> numberToWords(num % 100, result + numberToWords(num / 100) + " Hundred ")
        num >= 20 -> numberToWords(num % 10, result + tens[num / 10] + " ")
        else -> result + ones[num]
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\installation\steps\PatchApkStep.kt --- 
package com.grindrplus.manager.installation.steps
class PatchApkStep(
    private val inputDir: File,
    private val outputDir: File,
    private val modFile: File,
    private val keyStore: File,
    private val customMapsApiKey: String?,
    private val embedLSPatch: Boolean = true
) : BaseStep() {
    override val name = "Patching Grindr APK (Maps API Key & LSPatch)"
    private companion object {
        const val MAPS_API_KEY_NAME = "com.google.android.geo.API_KEY"
        const val TAG = "PatchApkStep"
    }
    override suspend fun doExecute(context: Context, print: Print) {
        val apkFiles = inputDir.listFiles()?.filter { it.name.endsWith(".apk") && it.exists() && it.length() > 0 }
        if (apkFiles.isNullOrEmpty()) {
            throw IOException("No APK files found in input directory to patch.")
        }
        print("Found ${apkFiles.size} APK files: ${apkFiles.joinToString { it.name }}")
        // Step 1: Comprehensive APK diagnostics before any processing
        print("=== APK DIAGNOSTICS ===")
        apkFiles.forEach { apkFile ->
            diagnoseApkFile(apkFile, context, print)
        }
        try {
            if (customMapsApiKey != null) {
                print("Attempting to apply custom Maps API key...")
                val baseApk = apkFiles.find { it.name == "base.apk" || it.name.startsWith("base.apk-") } ?: apkFiles.first()
                print("Using ${baseApk.name} for Maps API key modification")
                val apkModule = ApkModule.loadApkFile(baseApk)
                val applicationElement = apkModule.androidManifest.applicationElement
                val metaElements = applicationElement.getElements { it.name == "meta-data" }
                var foundMapsKey = false
                while (metaElements.hasNext() && !foundMapsKey) {
                    val element = metaElements.next()
                    val nameAttr = element.searchAttributeByName("name")
                    if (nameAttr != null && nameAttr.valueString == MAPS_API_KEY_NAME) {
                        val valueAttr = element.searchAttributeByName("value")
                        if (valueAttr != null) {
                            print("Found Maps API key element, replacing with custom key")
                            valueAttr.setValueAsString(StyleDocument.parseStyledString(customMapsApiKey))
                            foundMapsKey = true
                        }
                    }
                }
                if (foundMapsKey) {
                    print("Successfully applied Maps API key replacement. Saving APK...")
                    apkModule.writeApk(baseApk)
                    print("APK saved. Running post-modification diagnostics...")
                    diagnoseApkFile(baseApk, context, print)
                } else {
                    print("Maps API key element not found, skipping save.")
                }
            }
        } catch (e: Exception) {
            print("Error during Maps API key patching: ${e.message}")
            throw e
        }
        if (!embedLSPatch) {
            print("Skipping LSPatch. APKs are ready in output directory.")
            return
        }
        print("=== STARTING LSPATCH PROCESS ===")
        // Verify mod file exists and is valid
        if (!modFile.exists() || !modFile.canRead()) {
            throw IOException("Mod file not found or not readable: ${modFile.absolutePath}")
        }
        print("Mod file verified: ${modFile.name} (${modFile.length()} bytes)")
        // Verify keystore exists
        if (!keyStore.exists() || !keyStore.canRead()) {
            throw IOException("Keystore not found or not readable: ${keyStore.absolutePath}")
        }
        print("Keystore verified: ${keyStore.name}")
        // LSPatch needs a clean output directory
        val lspatchOutputDir = File(outputDir, "lspatch_temp").also {
            it.deleteRecursively()
            it.mkdirs()
        }
        val apkFilePaths = apkFiles.map { it.absolutePath }.toTypedArray()
        val logger = object : Logger() {
            override fun d(message: String?) {
                message?.let {
                    print("LSPATCH DEBUG: $it")
                    Log.d(TAG, "LSPATCH: $it")
                }
            }
            override fun i(message: String?) {
                message?.let {
                    print("LSPATCH INFO: $it")
                    Log.i(TAG, "LSPATCH: $it")
                }
            }
            override fun e(message: String?) {
                message?.let {
                    print("LSPATCH ERROR: $it")
                    Log.e(TAG, "LSPATCH: $it")
                }
            }
        }
        print("LSPatch command parameters:")
        print("  Input APKs: ${apkFilePaths.joinToString()}")
        print("  Output dir: ${lspatchOutputDir.absolutePath}")
        print("  Mod file: ${modFile.absolutePath}")
        print("  Keystore: ${keyStore.absolutePath}")
        try {
            withContext(Dispatchers.IO) {
                print("Executing LSPatch in background thread...")
                LSPatch(
                    logger,
                    *apkFilePaths,
                    "-o", lspatchOutputDir.absolutePath,
                    "-l", "2", "-f", "-v",
                    "-m", modFile.absolutePath,
                    "-k", keyStore.absolutePath, "password", "alias", "password"
                ).doCommandLine()
            }
        } catch (e: Exception) {
            print("=== LSPATCH FAILED ===")
            print("Exception type: ${e.javaClass.simpleName}")
            print("Exception message: ${e.message}")
            // Enhanced error diagnostics
            when {
                e.message?.contains("signature", ignoreCase = true) == true -> {
                    print("SIGNATURE-RELATED ERROR DETECTED")
                    print("This usually means LSPatch cannot extract or verify the APK signature")
                    diagnoseSignatureIssues(apkFiles, context, print)
                }
                e.message?.contains("original signature failed") == true -> {
                    print("ORIGINAL SIGNATURE EXTRACTION FAILED")
                    print("LSPatch cannot read the signature from one of the APK files")
                    diagnoseSignatureIssues(apkFiles, context, print)
                }
                else -> {
                    print("General LSPatch error - see logs for details")
                }
            }
            // Log stack trace for debugging
            Log.e(TAG, "LSPatch failed", e)
            e.stackTrace.take(10).forEach { stackElement ->
                Log.e(TAG, "  at $stackElement")
            }
            lspatchOutputDir.deleteRecursively()
            throw IOException("LSPatch failed: ${e.message}. Check logcat for full stack trace.")
        }
        val patchedFiles = lspatchOutputDir.listFiles()
        if (patchedFiles.isNullOrEmpty() || patchedFiles.none { it.name.endsWith(".apk") }) {
            throw IOException("LSPatch failed - no output APK files generated in ${lspatchOutputDir.absolutePath}")
        }
        print("LSPatch generated ${patchedFiles.size} files: ${patchedFiles.joinToString { it.name }}")
        // Move patched files from temp dir back to main output dir
        print("Moving final patched files to output directory...")
        patchedFiles.forEach { file ->
            val finalDest = File(outputDir, file.name)
            if (file.copyTo(finalDest, overwrite = true).exists()) {
                print("  Success: ${file.name} -> ${finalDest.name}")
            } else {
                print("  Warning: Failed to move ${file.name}")
            }
        }
        lspatchOutputDir.deleteRecursively()
        print("=== LSPATCH PROCESS COMPLETED SUCCESSFULLY ===")
        // Final verification of output files
        val finalApks = outputDir.listFiles()?.filter { it.name.endsWith(".apk") }
        if (finalApks.isNullOrEmpty()) {
            throw IOException("No APK files found in output directory after patching")
        }
        print("Final APK files: ${finalApks.joinToString { "${it.name} (${it.length()} bytes)" }}")
    }
    private fun diagnoseApkFile(apkFile: File, context: Context, print: Print) {
        print("Diagnosing APK: ${apkFile.name}")
        print("  File exists: ${apkFile.exists()}")
        print("  File size: ${apkFile.length()} bytes")
        print("  File readable: ${apkFile.canRead()}")
        print("  File writable: ${apkFile.canWrite()}")
        // Check APK structure
        try {
            ZipFile(apkFile).use { zip ->
                val entries = zip.entries().toList()
                val hasManifest = entries.any { it.name == "AndroidManifest.xml" }
                val hasClasses = entries.any { it.name.startsWith("classes") && it.name.endsWith(".dex") }
                val hasResources = entries.any { it.name == "resources.arsc" }
                print("  APK Structure:")
                print("    - AndroidManifest.xml: $hasManifest")
                print("    - classes.dex: $hasClasses")
                print("    - resources.arsc: $hasResources")
                print("    - Total entries: ${entries.size}")
                if (!hasManifest) {
                    print("  ❌ CRITICAL: Missing AndroidManifest.xml")
                }
                if (!hasClasses && !hasResources) {
                    print("  ⚠️ WARNING: No classes.dex or resources.arsc found")
                }
            }
        } catch (e: Exception) {
            print("  ❌ ERROR: Failed to analyze APK structure: ${e.message}")
        }
        // Check signature - FIXED: Use local variable to avoid smart cast issues
        try {
            val packageInfo = context.packageManager.getPackageArchiveInfo(apkFile.absolutePath, PackageManager.GET_SIGNATURES)
            val signatures = packageInfo?.signatures // Store in local variable
            if (signatures != null && signatures.isNotEmpty()) {
                print("  Signatures: ${signatures.size} signature(s) found")
                signatures.forEachIndexed { index, signature ->
                    val sigString = signature.toCharsString()
                    print("    Signature $index: ${sigString.take(20)}... (length: ${sigString.length})")
                }
                print("  Package name: ${packageInfo.packageName ?: "Unknown"}")
            } else {
                print("  ❌ WARNING: No signatures found in APK")
            }
        } catch (e: Exception) {
            print("  ❌ ERROR: Failed to extract signature: ${e.message}")
        }
        print("---")
    }
    private fun diagnoseSignatureIssues(apkFiles: List<File>, context: Context, print: Print) {
        print("=== SIGNATURE DIAGNOSIS ===")
        print("Testing each APK file individually for signature issues:")
        apkFiles.forEach { apkFile ->
            print("Testing: ${apkFile.name}")
            try {
                // Try to get detailed package info
                val packageInfo = context.packageManager.getPackageArchiveInfo(
                    apkFile.absolutePath,
                    PackageManager.GET_SIGNATURES or PackageManager.GET_META_DATA
                )
                if (packageInfo == null) {
                    print("  ❌ FAILED: Could not parse APK at all")
                    return@forEach
                }
                // FIXED: Use local variable to avoid smart cast issues
                val signatures = packageInfo.signatures
                if (signatures == null || signatures.isEmpty()) {
                    print("  ❌ FAILED: No signatures array")
                } else if (signatures.size == 1 && signatures[0].toCharsString().isEmpty()) {
                    print("  ❌ FAILED: Empty signature string")
                } else {
                    print("  ✅ PASSED: ${signatures.size} valid signature(s)")
                    print("  Package: ${packageInfo.packageName ?: "Unknown"}")
                }
            } catch (e: Exception) {
                print("  ❌ ERROR: ${e.javaClass.simpleName}: ${e.message}")
            }
        }
        print("=== SIGNATURE DIAGNOSIS COMPLETE ===")
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\installation\steps\SignClonedGrindrApk.kt --- 
package com.grindrplus.manager.installation.steps
class SignClonedGrindrApk(val keyStoreUtils: KeyStoreUtils, val outputDir: File): BaseStep() {
    override suspend fun doExecute(
        context: Context,
        print: Print,
    ) {
        for (file in outputDir.listFiles()!!) {
            if (!file.name.endsWith(".apk")) {
                print("Skipping ${file.name} as it is not an APK")
                continue
            }
//            val outFile = File(outputDir, "${file.name}-aligned.apk")
//            val zipIn = RandomAccessFile(file, "r");
//            val zipOut = outFile.outputStream();
//
//            print("Aligning ${file.name}...")
//
//            ZipAlign.alignZip(zipIn, zipOut)
//
//            print("Signing ${outFile.name}...")
            try {
                keyStoreUtils.signApk(file, File(outputDir, "${file.name}-signed.apk"))
                //outFile.delete()
                file.delete()
            } catch (e: Exception) {
                print("Failed to sign ${file.name}: ${e.localizedMessage}")
                throw e
            }
        }
    }
    override val name: String = "Sign cloned Grindr APK"
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\settings\SettingsUtils.kt --- 
package com.grindrplus.manager.settings
object SettingsUtils {
    fun testMapsApiKey(
        context: Context,
        viewModelScope: CoroutineScope,
        apiKey: String,
        showTestDialog: (Boolean, String, String, String) -> Unit
    ) {
        showTestDialog(true, "Testing", "Testing your API key...", "")
        viewModelScope.launch {
            try {
                val result = withContext(Dispatchers.IO) {
                    val url = URL("https://maps.googleapis.com/maps/api/geocode/json?address=USA&key=$apiKey")
                    val connection = url.openConnection() as HttpURLConnection
                    connection.requestMethod = "GET"
                    connection.connectTimeout = 10000
                    connection.readTimeout = 10000
                    val responseCode = connection.responseCode
                    val input = if (responseCode >= 400) {
                        connection.errorStream
                    } else {
                        connection.inputStream
                    }
                    val response = input.bufferedReader().use { it.readText() }
                    val jsonResponse = JSONObject(response)
                    val status = jsonResponse.optString("status", "")
                    val errorMessage = if (jsonResponse.has("error_message"))
                        jsonResponse.getString("error_message") else ""
                    Triple(status, errorMessage, response)
                }
                val (status, errorMessage, rawResponse) = result
                when {
                    status == "OK" -> {
                        showTestDialog(
                            false,
                            "Success!",
                            "Your Google Maps API key is working correctly. You can use it with GrindrPlus.",
                            rawResponse
                        )
                    }
                    status == "REQUEST_DENIED" && errorMessage.isNotEmpty() -> {
                        if (errorMessage.contains("API key is invalid")) {
                            showTestDialog(
                                false,
                                "Invalid API Key",
                                "Your API key is invalid. Please double-check that you've copied it correctly.",
                                rawResponse
                            )
                        } else if (errorMessage.contains("not authorized")) {
                            showTestDialog(
                                false,
                                "API Not Enabled",
                                "Your API key is valid but you need to enable the Geocoding API in the Google Cloud Console.",
                                rawResponse
                            )
                        } else {
                            showTestDialog(
                                false,
                                "API Error",
                                "Error: $errorMessage",
                                rawResponse
                            )
                        }
                    }
                    else -> {
                        showTestDialog(
                            false,
                            "Warning",
                            "API returned $status status",
                            rawResponse
                        )
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
                showTestDialog(
                    false,
                    "Connection Error",
                    "Failed to connect to Google Maps API: ${e.message}",
                    e.stackTraceToString()
                )
            }
        }
    }
}
@Composable
fun ApiKeyTestDialog(
    isLoading: Boolean,
    title: String,
    message: String,
    rawResponse: String,
    onDismiss: () -> Unit
) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            shape = RoundedCornerShape(16.dp),
        ) {
            Column(
                modifier = Modifier
                    .padding(20.dp)
                    .fillMaxWidth(),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                if (isLoading) {
                    CircularProgressIndicator(
                        modifier = Modifier
                            .size(48.dp)
                            .padding(bottom = 16.dp)
                    )
                } else {
                    when {
                        title.contains("Success") -> {
                            Icon(
                                imageVector = Icons.Default.CheckCircle,
                                contentDescription = "Success",
                                tint = MaterialTheme.colorScheme.primary,
                                modifier = Modifier.size(48.dp)
                            )
                        }
                        title.contains("Warning") -> {
                            Icon(
                                imageVector = Icons.Default.Warning,
                                contentDescription = "Warning",
                                tint = MaterialTheme.colorScheme.error,
                                modifier = Modifier.size(48.dp)
                            )
                        }
                        else -> {
                            Icon(
                                imageVector = Icons.Default.Error,
                                contentDescription = "Error",
                                tint = MaterialTheme.colorScheme.error,
                                modifier = Modifier.size(48.dp)
                            )
                        }
                    }
                }
                Spacer(modifier = Modifier.height(12.dp))
                Text(
                    text = title,
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold,
                    textAlign = TextAlign.Center
                )
                Spacer(modifier = Modifier.height(12.dp))
                Text(
                    text = message,
                    style = MaterialTheme.typography.bodyLarge,
                    textAlign = TextAlign.Center
                )
                if (rawResponse.isNotEmpty() && !isLoading) {
                    Spacer(modifier = Modifier.height(16.dp))
                    var showResponse by remember { mutableStateOf(false) }
                    Button(
                        onClick = { showResponse = !showResponse },
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.surfaceVariant,
                            contentColor = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    ) {
                        Text(if (showResponse) "Hide Details" else "Show Details")
                    }
                    if (showResponse) {
                        Spacer(modifier = Modifier.height(12.dp))
                        Surface(
                            modifier = Modifier
                                .fillMaxWidth()
                                .heightIn(max = 200.dp),
                            color = MaterialTheme.colorScheme.surfaceVariant,
                            shape = RoundedCornerShape(8.dp)
                        ) {
                            Box(
                                modifier = Modifier
                                    .padding(12.dp)
                                    .verticalScroll(rememberScrollState())
                            ) {
                                Text(
                                    text = rawResponse,
                                    style = MaterialTheme.typography.bodySmall,
                                    fontFamily = androidx.compose.ui.text.font.FontFamily.Monospace
                                )
                            }
                        }
                    }
                }
                Spacer(modifier = Modifier.height(24.dp))
                Button(
                    onClick = onDismiss,
                    modifier = Modifier.fillMaxWidth(),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.primary,
                        contentColor = MaterialTheme.colorScheme.onPrimary
                    )
                ) {
                    Text("Close")
                }
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\settings\SettingsViewModel.kt --- 
package com.grindrplus.manager.settings
@SuppressLint("StaticFieldLeak")
class SettingsViewModel(
    private val context: Context,
) : ViewModel() {
    private val hookHideList = setOf(
        "Status Dialog",
    )
    private val _settingGroups = MutableStateFlow<List<SettingGroup>>(emptyList())
    val settingGroups: StateFlow<List<SettingGroup>> = _settingGroups
    private val _isLoading = MutableStateFlow(true)
    val isLoading: StateFlow<Boolean> = _isLoading
    private val _showApiKeyTestDialog = MutableStateFlow(false)
    val showApiKeyTestDialog: StateFlow<Boolean> = _showApiKeyTestDialog
    private val _apiKeyTestTitle = MutableStateFlow("")
    val apiKeyTestTitle: StateFlow<String> = _apiKeyTestTitle
    private val _apiKeyTestMessage = MutableStateFlow("")
    val apiKeyTestMessage: StateFlow<String> = _apiKeyTestMessage
    private val _apiKeyTestRawResponse = MutableStateFlow("")
    val apiKeyTestRawResponse: StateFlow<String> = _apiKeyTestRawResponse
    private val _apiKeyTestLoading = MutableStateFlow(false)
    val apiKeyTestLoading: StateFlow<Boolean> = _apiKeyTestLoading
    fun dismissApiKeyTestDialog() {
        _showApiKeyTestDialog.value = false
    }
    private fun showApiKeyTestDialog(
        isLoading: Boolean,
        title: String,
        message: String,
        rawResponse: String
    ) {
        _apiKeyTestLoading.value = isLoading
        _apiKeyTestTitle.value = title
        _apiKeyTestMessage.value = message
        _apiKeyTestRawResponse.value = rawResponse
        _showApiKeyTestDialog.value = true
    }
    init {
        loadSettings()
    }
    fun loadSettings() {
        viewModelScope.launch {
            _isLoading.value = true
            try {
                val hooks = Config.getHooksSettings()
                val hookSettings = hooks
                    .filterNot { (hookName, _) -> hookName in hookHideList }
                    .map { (hookName, pair) ->
                        SwitchSetting(
                            id = hookName,
                            title = hookName,
                            description = pair.first,
                            isChecked = pair.second,
                            onCheckedChange = {
                                viewModelScope.launch {
                                    Config.setHookEnabled(hookName, it)
                                    loadSettings()
                                }
                            }
                        )
                    }
                val tasks = Config.getTasksSettings()
                val taskSettings = tasks.map { (taskId, pair) ->
                    SwitchSetting(
                        id = taskId,
                        title = taskId,
                        description = pair.first,
                        isChecked = pair.second,
                        onCheckedChange = {
                            viewModelScope.launch {
                                Config.setTaskEnabled(taskId, it)
                                loadSettings()
                            }
                        }
                    )
                }
                val otherSettings = mutableListOf(
                    TextSetting(
                        id = "command_prefix",
                        title = "Command Prefix",
                        description = "Change the command prefix (default: /)",
                        value = Config.get("command_prefix", "/") as String,
                        onValueChange = {
                            viewModelScope.launch {
                                Config.put("command_prefix", it)
                                loadSettings()
                            }
                        },
                        validator = { input ->
                            when {
                                input.isBlank() -> "Invalid command prefix"
                                input.length > 1 -> "Command prefix must be a single character"
                                !input.matches(Regex("[^a-zA-Z0-9]")) -> "Command prefix must be a special character"
                                else -> null
                            }
                        }
                    ),
                    TextSetting(
                        id = "date_format",
                        title = "Date Format",
                        description = "Format for displaying dates in the app (default: MM/dd/yyyy)",
                        value = Config.get("date_format", "MM/dd/yyyy") as String,
                        onValueChange = {
                            viewModelScope.launch {
                                Config.put("date_format", it)
                                loadSettings()
                            }
                        },
                        validator = { input ->
                            when {
                                input.isBlank() -> "Date format cannot be empty"
                                !input.contains("MM") && !input.contains("M") -> "Format must include month (M or MM)"
                                !input.contains("dd") && !input.contains("d") -> "Format must include day (d or dd)"
                                !input.contains("yyyy") && !input.contains("yy") -> "Format must include year (yy or yyyy)"
                                else -> null
                            }
                        }
                    ),
                    TextSetting(
                        id = "online_indicator",
                        title = "Online indicator duration (mins)",
                        description = "Control when the green dot disappears after inactivity",
                        value = (Config.get("online_indicator", 5) as Number).toString(),
                        onValueChange = {
                            val value = it.toIntOrNull() ?: 5
                            viewModelScope.launch {
                                Config.put("online_indicator", value)
                                loadSettings()
                            }
                        },
                        keyboardType = KeyboardType.Number,
                        validator = { input ->
                            val value = input.toIntOrNull()
                            if (value == null || value <= 0) "Duration must be a positive number" else null
                        }
                    ),
                    SwitchSetting(
                        id = "show_bmi_in_profile",
                        title = "Show BMI in Profile",
                        description = "Display BMI in the profile section",
                        isChecked = Config.get("show_bmi_in_profile", true) as Boolean,
                        onCheckedChange = {
                            viewModelScope.launch {
                                Config.put("show_bmi_in_profile", it)
                                loadSettings()
                            }
                        }
                    ),
                    TextSetting(
                        id = "favorites_grid_columns",
                        title = "Favorites grid columns",
                        description = "Number of columns in the favorites grid (default: 3)",
                        value = Config.get("favorites_grid_columns", 3).toString(),
                        onValueChange = {
                            val value = it.toIntOrNull() ?: 3
                            viewModelScope.launch {
                                Config.put("favorites_grid_columns", value)
                                loadSettings()
                            }
                        },
                        keyboardType = KeyboardType.Number,
                        validator = { input ->
                            val value = input.toIntOrNull()
                            if (value == null || value <= 0) "Number of columns must be a positive number" else null
                        }
                    ),
                    TextSettingWithButtons(
                        id = "android_device_id",
                        title = "Android Device ID",
                        description = "Change the Android Device ID",
                        value = Config.get("android_device_id", "") as String,
                        onValueChange = {
                            viewModelScope.launch {
                                Config.put("android_device_id", it)
                                loadSettings()
                            }
                        },
                        validator = { input ->
                            when {
                                input.isBlank() -> null
                                input.length != 16 -> "Android Device ID must be 16 characters long"
                                !input.matches(Regex("[0-9a-fA-F]+")) -> "Android Device ID must be a hexadecimal string"
                                else -> null
                            }
                        },
                        buttons = listOf(
                            ButtonAction("Generate") {
                                val uuid = java.util.UUID.randomUUID()
                                val newDeviceId = uuid.toString().replace("-", "").substring(0, 16)
                                Config.put("android_device_id", newDeviceId)
                                loadSettings()
                                Toast.makeText(context, "New device ID generated", Toast.LENGTH_SHORT).show()
                            }
                        )
                    ),
                    SwitchSetting(
                        id = "enable_cookie_tap",
                        title = "Enable Cookie Tap",
                        description = "Enable the ability to send cookie taps to other users (they'll see them)",
                        isChecked = Config.get("enable_cookie_tap", false) as Boolean,
                        onCheckedChange = {
                            viewModelScope.launch {
                                Config.put("enable_cookie_tap", it)
                                loadSettings()
                            }
                        }
                    ),
                    SwitchSetting(
                        id = "enable_vip_flag",
                        title = "Enable Star Section",
                        description = "Enables what looks like a recommendation section next to Browse",
                        isChecked = Config.get("enable_vip_flag", false) as Boolean,
                        onCheckedChange = {
                            viewModelScope.launch {
                                Config.put("enable_vip_flag", it)
                                loadSettings()
                            }
                        }
                    ),
                    SwitchSetting(
                        id = "enable_interest_section",
                        title = "Enable Interest Section",
                        description = "Show interests section on profiles",
                        isChecked = Config.get("enable_interest_section", true) as Boolean,
                        onCheckedChange = {
                            viewModelScope.launch {
                                Config.put("enable_interest_section", it)
                                loadSettings()
                            }
                        }
                    ),
                    SwitchSetting(
                        id = "disable_profile_swipe",
                        title = "Disable profile swipe",
                        description = "Disable profile swipe and open profile on click",
                        isChecked = Config.get("disable_profile_swipe", false) as Boolean,
                        onCheckedChange = {
                            viewModelScope.launch {
                                Config.put("disable_profile_swipe", it)
                                loadSettings()
                            }
                        }
                    ),
                    SwitchSetting(
                        id = "force_old_anti_block_behavior",
                        title = "Force old AntiBlock behavior",
                        description = "Use the old AntiBlock behavior (don't use this, required for testing)",
                        isChecked = Config.get("force_old_anti_block_behavior", false) as Boolean,
                        onCheckedChange = {
                            viewModelScope.launch {
                                Config.put("force_old_anti_block_behavior", it)
                                loadSettings()
                            }
                        }
                    ),
                    SwitchSetting(
                        id = "anti_block_use_toasts",
                        title = "Use toasts for AntiBlock hook",
                        description = "Instead of receiving Android notifications, use toasts for block/unblock notifications",
                        isChecked = Config.get("anti_block_use_toasts", false) as Boolean,
                        onCheckedChange = {
                            viewModelScope.launch {
                                Config.put("anti_block_use_toasts", it)
                                loadSettings()
                            }
                        }
                    ),
                    SwitchSetting(
                        id = "reset_database",
                        title = "Reset local database on next start",
                        description = "Will delete all local data on next app start",
                        isChecked = Config.get("reset_database", false) as Boolean,
                        onCheckedChange = {
                            viewModelScope.launch {
                                Config.put("reset_database", it)
                                loadSettings()
                            }
                        }
                    ),
                    SwitchSetting(
                        id = "do_gui_safety_checks",
                        title = "Do GUI safety checks",
                        description = "Prevent graphic glitches when applying GUI based hooks",
                        isChecked = Config.get("do_gui_safety_checks", true) as Boolean,
                        onCheckedChange = {
                            viewModelScope.launch {
                                Config.put("do_gui_safety_checks", it)
                                loadSettings()
                            }
                        }
                    )
                )
                val managerSettings = mutableListOf<Setting>(
                    TextSettingWithButtons(
                        id = "maps_api_key",
                        title = "Maps API Key",
                        description = "Use a custom Maps API Key when using Grindr Plus with LSPatch",
                        value = Config.get("maps_api_key", "") as String,
                        onValueChange = {
                            viewModelScope.launch {
                                Config.put("maps_api_key", it)
                                loadSettings()
                            }
                        },
                        validator = { null },
                        buttons = listOf(
                            ButtonAction("Test") {
                                val apiKey = Config.get("maps_api_key", "") as String
                                if (apiKey.isBlank()) {
                                    Toast.makeText(context, "Please enter an API key first", Toast.LENGTH_SHORT).show()
                                } else {
                                    testMapsApiKey(
                                        context,
                                        viewModelScope,
                                        apiKey,
                                        ::showApiKeyTestDialog
                                    )
                                }
                            }
                        )
                    ),
                    TextSetting(
                        id = "custom_manifest",
                        title = "Custom Manifest URL",
                        description = "Use a custom manifest URL when using Grindr Plus with LSPatch",
                        value = Config.get("custom_manifest", DATA_URL) as String,
                        onValueChange = {
                            viewModelScope.launch {
                                Config.put("custom_manifest", it)
                                loadSettings()
                            }
                        },
                        validator = { null }
                    ),
                    SwitchSetting(
                        id = "analytics",
                        title = "Opt-in analytics",
                        description = "Help improve the app by sending anonymous usage data",
                        isChecked = Config.get("analytics", true) as Boolean,
                        onCheckedChange = {
                            viewModelScope.launch {
                                Config.put("analytics", it)
                                loadSettings()
                            }
                        }
                    ),
                    SwitchSetting(
                        id = "discreet_icon",
                        title = "Camouflage app",
                        description = "Hide the app icon and use a different name",
                        isChecked = Config.get("discreet_icon", false) as Boolean,
                        onCheckedChange = {
                            viewModelScope.launch {
                                Config.put("discreet_icon", it)
                                loadSettings()
                                val appIconManager = AppIconManager(context)
                                appIconManager.changeAppIcon(if (it) AppIconManager.DISCREET_ICON else AppIconManager.DEFAULT_ICON)
                                Toast.makeText(
                                    context,
                                    "App icon changed. It may take a moment to update.",
                                    Toast.LENGTH_LONG
                                ).show()
                            }
                        }
                    ),
                    SwitchSetting(
                        id = "disable_permission_checks",
                        title = "Disable permission checks",
                        description = "Disable permission checks on startup (not recommended)",
                        isChecked = Config.get("disable_permission_checks", false) as Boolean,
                        onCheckedChange = {
                            viewModelScope.launch {
                                Config.put("disable_permission_checks", it)
                                loadSettings()
                            }
                        }
                    )
                )
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    managerSettings += SwitchSetting(
                        id = "material_you",
                        title = "Enable dynamic colors",
                        description = "Use Material You colors for the app\nRestart the app to apply changes",
                        isChecked = Config.get("material_you", false) as Boolean,
                        onCheckedChange = {
                            viewModelScope.launch {
                                Config.put("material_you", it)
                                loadSettings()
                            }
                        }
                    )
                }
                _settingGroups.value = listOf(
                    SettingGroup(
                        id = "hooks",
                        title = "Manage Hooks",
                        settings = hookSettings
                    ),
                    SettingGroup(
                        id = "tasks",
                        title = "Manage Tasks",
                        settings = taskSettings
                    ),
                    SettingGroup(
                        id = "other",
                        title = "Other Settings",
                        settings = otherSettings
                    ),
                    SettingGroup(
                        id = "manager",
                        title = "Manager Settings",
                        settings = managerSettings
                    ),
                )
            } finally {
                _isLoading.value = false
            }
        }
    }
}
class SettingsViewModelFactory(private val context: Context) : ViewModelProvider.Factory {
    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(SettingsViewModel::class.java)) {
            return SettingsViewModel(context) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class: ${modelClass.name}")
    }
}
@Composable
fun rememberViewModel(): SettingsViewModel {
    val context = LocalContext.current
    val factory = remember(context) { SettingsViewModelFactory(context) }
    return viewModel(factory = factory)
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\settings\SettingTypes.kt --- 
package com.grindrplus.manager.settings
data class SwitchSetting(
    override val id: String,
    override val title: String,
    val description: String? = null,
    val isChecked: Boolean,
    val onCheckedChange: (Boolean) -> Unit,
) : Setting(id, title)
sealed class Setting(open val id: String, open val title: String)
data class TextSetting(
    override val id: String,
    override val title: String,
    val description: String? = null,
    val value: String,
    val onValueChange: (String) -> Unit,
    val keyboardType: KeyboardType = KeyboardType.Text,
    val validator: ((String) -> String?)? = null,
) : Setting(id, title)
data class ButtonAction(
    val name: String,
    val action: () -> Unit
)
data class TextSettingWithButtons(
    override val id: String,
    override val title: String,
    val description: String? = null,
    val value: String,
    val onValueChange: (String) -> Unit,
    val keyboardType: KeyboardType = KeyboardType.Text,
    val validator: ((String) -> String?)? = null,
    val buttons: List<ButtonAction> = emptyList()
) : Setting(id, title)
data class ButtonSetting(
    override val id: String,
    override val title: String,
    val onClick: () -> Unit,
) : Setting(id, title)
data class SettingGroup(
    val id: String,
    val title: String,
    val settings: List<Setting>,
)
enum class KeyboardType {
    Text, Number, Email, Password, Phone
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\BlockLogScreen.kt --- 
package com.grindrplus.manager.ui
@SuppressLint("ContextCastToActivity")
@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class)
@Composable
fun BlockLogScreen(innerPadding: PaddingValues) {
    val activity = LocalContext.current as ComponentActivity
    val viewModel: BlockLogViewModel = viewModel()
    val events by viewModel.events.collectAsState()
    val filters by viewModel.filters.collectAsState()
    val filteredEvents by viewModel.filteredEvents.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()
    val availablePackages by viewModel.availablePackages.collectAsState()
    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()
    val clipboardManager = LocalClipboardManager.current
    var showDeleteDialog by remember { mutableStateOf(false) }
    LaunchedEffect(Unit) {
        viewModel.loadEvents()
    }
    if (showDeleteDialog) {
        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            title = { Text("Clear all events") },
            text = { Text("Are you sure you want to clear all block/unblock events? This action cannot be undone.") },
            confirmButton = {
                Button(
                    onClick = {
                        viewModel.clearEvents()
                        showDeleteDialog = false
                    },
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Text("Clear")
                }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteDialog = false }) {
                    Text("Cancel")
                }
            }
        )
    }
    Scaffold(
        modifier = Modifier
            .fillMaxSize()
            .padding(top = 0.dp),
        snackbarHost = { SnackbarHost(snackbarHostState) },
        topBar = {
            TopAppBar(
                title = { Text("Block Log") },
                actions = {
                    IconButton(
                        onClick = {
                            viewModel.exportEventsToFile(activity)
                            scope.launch {
                                snackbarHostState.showSnackbar("Saving block events JSON file...")
                            }
                        }
                    ) {
                        Icon(
                            imageVector = Icons.Default.Download,
                            contentDescription = "Export JSON"
                        )
                    }
                    IconButton(onClick = { showDeleteDialog = true }) {
                        Icon(
                            imageVector = Icons.Default.Delete,
                            contentDescription = "Clear all"
                        )
                    }
                },
                modifier = Modifier.padding(top = 0.dp)
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            FilterPanel(
                filters = filters,
                availablePackages = availablePackages,
                onFiltersChanged = { newFilters ->
                    viewModel.updateFilters(newFilters)
                },
                modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)
            )
            if (filters.isActive) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp, vertical = 4.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = "Filtered: ${filteredEvents.size} of ${events.size} events",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.primary
                    )
                }
            }
            Box(
                modifier = Modifier.weight(1f)
            ) {
                if (isLoading) {
                    CircularProgressIndicator(
                        modifier = Modifier.align(Alignment.Center)
                    )
                } else if (filteredEvents.isEmpty()) {
                    Column(
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(16.dp),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.Center
                    ) {
                        Icon(
                            imageVector = Icons.Default.Error,
                            contentDescription = "No events",
                            modifier = Modifier.size(64.dp),
                            tint = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.6f)
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                        Text(
                            text = if (filters.isActive && events.isNotEmpty())
                                "No events match your filters"
                            else
                                "No block/unblock events found",
                            style = MaterialTheme.typography.bodyLarge,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        if (filters.isActive && events.isNotEmpty()) {
                            Spacer(modifier = Modifier.height(16.dp))
                            Button(
                                onClick = { viewModel.updateFilters(BlockLogFilters()) }
                            ) {
                                Text("Reset Filters")
                            }
                        }
                    }
                } else {
                    LazyColumn(
                        modifier = Modifier.fillMaxSize(),
                        contentPadding = PaddingValues(16.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        val dateFormat = SimpleDateFormat("MMMM d, yyyy", Locale.getDefault())
                        val grouped = filteredEvents.groupBy {
                            dateFormat.format(Date(it.timestamp))
                        }
                        grouped.forEach { (date, dateEvents) ->
                            stickyHeader {
                                Box(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .background(MaterialTheme.colorScheme.background)
                                        .padding(vertical = 8.dp)
                                ) {
                                    Text(
                                        text = date,
                                        style = MaterialTheme.typography.titleMedium,
                                        color = MaterialTheme.colorScheme.primary
                                    )
                                }
                            }
                            items(dateEvents) { event ->
                                BlockEventItem(
                                    event = event,
                                    onCopyId = {
                                        clipboardManager.setText(AnnotatedString(event.profileId))
                                        scope.launch {
                                            snackbarHostState.showSnackbar("Profile ID copied to clipboard")
                                        }
                                    }
                                )
                            }
                        }
                    }
                }
            }
        }
    }
}
@Composable
fun BlockEventItem(
    event: BlockEvent,
    onCopyId: () -> Unit
) {
    val timeFormat = SimpleDateFormat("h:mm a", Locale.getDefault())
    val time = timeFormat.format(Date(event.timestamp))
    val formattedPackage = remember(event.packageName) {
        when (val pkg = event.packageName) {
            null, "com.grindrapp.android" -> null
            else -> when {
                pkg.startsWith(AppCloneUtils.GRINDR_PACKAGE_PREFIX) -> {
                    val cloneName = pkg.removePrefix(AppCloneUtils.GRINDR_PACKAGE_PREFIX)
                    "Clone ${cloneName.replaceFirstChar { it.uppercase() }}"
                }
                else -> pkg.substringAfterLast('.')
            }
        }
    }
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    imageVector = Icons.Default.Block,
                    contentDescription = null,
                    tint = if (event.eventType == "block")
                        MaterialTheme.colorScheme.error
                    else
                        MaterialTheme.colorScheme.primary,
                    modifier = Modifier.size(24.dp)
                )
                Spacer(modifier = Modifier.size(12.dp))
                Column(
                    modifier = Modifier.weight(1f)
                ) {
                    Text(
                        text = event.displayName,
                        style = MaterialTheme.typography.titleMedium,
                        maxLines = 1,
                        overflow = TextOverflow.Ellipsis
                    )
                    Text(
                        text = if (event.eventType == "block")
                            "Blocked you"
                        else
                            "Unblocked you",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    if (formattedPackage != null) {
                        Text(
                            text = formattedPackage,
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.secondary,
                            maxLines = 1,
                            overflow = TextOverflow.Ellipsis
                        )
                    }
                }
                Text(
                    text = time,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            Divider(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical = 8.dp)
            )
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "ID: ${event.profileId}",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.weight(1f)
                )
                IconButton(
                    onClick = onCopyId,
                    modifier = Modifier.size(32.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.ContentCopy,
                        contentDescription = "Copy ID",
                        tint = MaterialTheme.colorScheme.primary,
                        modifier = Modifier.size(18.dp)
                    )
                }
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\CalculatorScreen.kt --- 
package com.grindrplus.manager.ui
@Composable
fun CalculatorScreen(calculatorScreen: MutableState<Boolean>) {
    var display by remember { mutableStateOf("0") }
    var operation by remember { mutableStateOf<String?>(null) }
    var firstNumber by remember { mutableStateOf<Double?>(null) }
    var newNumber by remember { mutableStateOf(true) }
    var showPasswordDialog by remember { mutableStateOf(false) }
    val windowInsets = WindowInsets.systemBars
    val topInset = windowInsets.asPaddingValues().calculateTopPadding()
    val bottomInset = windowInsets.asPaddingValues().calculateBottomPadding()
    var selectedEasterEgg by remember { mutableIntStateOf(0) }
    var showEasterEgg by remember { mutableStateOf(false) }
    val easterEggs = mapOf(
        666 to "https://i.imgur.com/399VOm7.jpeg"
    )
    LaunchedEffect(Unit) {
        showPasswordDialog = Config.get("calculator_first_launch", true) as Boolean
    }
    Surface(
        modifier = Modifier.fillMaxSize(),
        color = MaterialTheme.colorScheme.background
    ) {
        if (showEasterEgg) {
            EasterEggDialog(
                onDismiss = { showEasterEgg = false },
                videoUrl = "${easterEggs[selectedEasterEgg]}",
            )
        }
        if (showPasswordDialog) {
            CalculatorPasswordDialog {
                Config.put("calculator_first_launch", false)
                showPasswordDialog = false
            }
        }
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(
                    start = 16.dp,
                    end = 16.dp,
                    top = topInset + 16.dp,
                    bottom = bottomInset + 16.dp
                ),
            verticalArrangement = Arrangement.SpaceBetween
        ) {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .weight(1f)
                    .clip(RoundedCornerShape(16.dp))
                    .background(MaterialTheme.colorScheme.surfaceVariant)
                    .padding(horizontal = 24.dp, vertical = 16.dp),
                contentAlignment = Alignment.BottomEnd
            ) {
                val formattedDisplay = remember(display) {
                    if (display.length > 12) {
                        display.chunked(12).joinToString("\n")
                    } else {
                        display
                    }
                }
                Text(
                    text = formattedDisplay,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    fontSize = 48.sp,
                    fontWeight = FontWeight.Normal,
                    maxLines = 3,
                    textAlign = TextAlign.End,
                    lineHeight = 52.sp
                )
            }
            Spacer(modifier = Modifier.height(12.dp))
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    CalculatorButton("C", ButtonType.FUNCTION, modifier = Modifier.weight(1f)) {
                        display = "0"
                        operation = null
                        firstNumber = null
                        newNumber = true
                    }
                    Spacer(modifier = Modifier.weight(1f))
                    Spacer(modifier = Modifier.weight(1f))
                    CalculatorButton("÷", ButtonType.OPERATION, modifier = Modifier.weight(1f)) {
                        handleOperation("÷", display) { op, num ->
                            operation = op; firstNumber = num; newNumber = true
                        }
                    }
                }
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    for (number in listOf("7", "8", "9")) {
                        CalculatorButton(
                            number,
                            ButtonType.NUMBER,
                            modifier = Modifier.weight(1f)
                        ) {
                            updateDisplay(number, display, newNumber) {
                                display = it; newNumber = false
                            }
                        }
                    }
                    CalculatorButton("×", ButtonType.OPERATION, modifier = Modifier.weight(1f)) {
                        handleOperation("×", display) { op, num ->
                            operation = op; firstNumber = num; newNumber = true
                        }
                    }
                }
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    for (number in listOf("4", "5", "6")) {
                        CalculatorButton(
                            number,
                            ButtonType.NUMBER,
                            modifier = Modifier.weight(1f)
                        ) {
                            updateDisplay(number, display, newNumber) {
                                display = it; newNumber = false
                            }
                        }
                    }
                    CalculatorButton("-", ButtonType.OPERATION, modifier = Modifier.weight(1f)) {
                        handleOperation("-", display) { op, num ->
                            operation = op; firstNumber = num; newNumber = true
                        }
                    }
                }
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    for (number in listOf("1", "2", "3")) {
                        CalculatorButton(
                            number,
                            ButtonType.NUMBER,
                            modifier = Modifier.weight(1f)
                        ) {
                            updateDisplay(number, display, newNumber) {
                                display = it; newNumber = false
                            }
                        }
                    }
                    CalculatorButton("+", ButtonType.OPERATION, modifier = Modifier.weight(1f)) {
                        handleOperation("+", display) { op, num ->
                            operation = op; firstNumber = num; newNumber = true
                        }
                    }
                }
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    CalculatorButton("0", ButtonType.NUMBER, modifier = Modifier.weight(2f)) {
                        updateDisplay("0", display, newNumber) { display = it; newNumber = false }
                    }
                    CalculatorButton(".", ButtonType.NUMBER, modifier = Modifier.weight(1f)) {
                        if (!display.contains(".") && !newNumber) {
                            display = "$display."
                        } else if (newNumber) {
                            display = "0."
                            newNumber = false
                        }
                    }
                    CalculatorButton("=", ButtonType.EQUALS, modifier = Modifier.weight(1f)) {
                        if (operation == "×" && firstNumber == 53.0) {
                            calculatorScreen.value = false
                            return@CalculatorButton
                        }
                        if (easterEggs.containsKey(firstNumber?.toInt())) {
                            selectedEasterEgg = firstNumber!!.toInt()
                            showEasterEgg = true
                            return@CalculatorButton
                        }
                        if (operation != null && firstNumber != null) {
                            val secondNumber = display.toDoubleOrNull() ?: 0.0
                            val result = when (operation) {
                                "+" -> firstNumber!! + secondNumber
                                "-" -> firstNumber!! - secondNumber
                                "×" -> firstNumber!! * secondNumber
                                "÷" -> if (secondNumber != 0.0) firstNumber!! / secondNumber else Double.POSITIVE_INFINITY
                                else -> secondNumber
                            }
                            display = if (result % 1 == 0.0) result.toInt()
                                .toString() else result.toString()
                            operation = null
                            firstNumber = null
                            newNumber = true
                        }
                    }
                }
            }
        }
    }
}
@Composable
fun EasterEggDialog(onDismiss: () -> Unit, videoUrl: String) {
    Dialog(
        onDismissRequest = onDismiss,
        properties = DialogProperties(
            usePlatformDefaultWidth = false,
            dismissOnBackPress = true,
            dismissOnClickOutside = true
        )
    ) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            shape = RoundedCornerShape(16.dp),
        ) {
            val context = LocalContext.current
            Column(
                modifier = Modifier.padding(24.dp),
                verticalArrangement = Arrangement.Center
            ) {
                AsyncImage(
                    model = videoUrl,
                    contentDescription = null,
                    modifier = Modifier.fillMaxWidth()
                        .size(200.dp)
                        .clip(RoundedCornerShape(16.dp)),
                    contentScale = ContentScale.Crop
                )
                Spacer(modifier = Modifier.height(16.dp))
                Button(
                    onClick = onDismiss,
                    modifier = Modifier.align(Alignment.CenterHorizontally)
                ) {
                    Text("Close")
                }
            }
        }
    }
}
@Composable
fun CalculatorPasswordDialog(onDismiss: () -> Unit) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            shape = RoundedCornerShape(16.dp),
        ) {
            Column(
                modifier = Modifier.padding(24.dp),
                verticalArrangement = Arrangement.Center
            ) {
                Text(
                    text = "Calculator Exit Code",
                    style = MaterialTheme.typography.headlineSmall,
                    modifier = Modifier.padding(bottom = 16.dp)
                )
                Text(
                    text = "To exit calculator mode, enter:",
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.padding(bottom = 8.dp)
                )
                Text(
                    text = "53 × =",
                    style = MaterialTheme.typography.bodyLarge,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.padding(bottom = 16.dp)
                )
                Text(
                    text = "1. Press 5 then 3\n2. Press × (multiply)\n3. Press = (equals)",
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.padding(bottom = 16.dp)
                )
                Button(
                    onClick = onDismiss,
                    modifier = Modifier.align(Alignment.CenterHorizontally)
                ) {
                    Text("Got it")
                }
            }
        }
    }
}
enum class ButtonType { NUMBER, OPERATION, FUNCTION, EQUALS }
@Composable
private fun CalculatorButton(
    text: String,
    type: ButtonType,
    modifier: Modifier = Modifier,
    onClick: () -> Unit,
) {
    val interactionSource = remember { MutableInteractionSource() }
    val isPressed by interactionSource.collectIsPressedAsState()
    val scale = animateFloatAsState(
        targetValue = if (isPressed) 0.95f else 1f,
        label = "buttonScale"
    )
    val buttonColor = when (type) {
        ButtonType.NUMBER -> ButtonDefaults.buttonColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant,
            contentColor = MaterialTheme.colorScheme.onSurfaceVariant
        )
        ButtonType.OPERATION -> ButtonDefaults.buttonColors(
            containerColor = MaterialTheme.colorScheme.primaryContainer,
            contentColor = MaterialTheme.colorScheme.onPrimaryContainer
        )
        ButtonType.FUNCTION -> ButtonDefaults.buttonColors(
            containerColor = MaterialTheme.colorScheme.tertiaryContainer,
            contentColor = MaterialTheme.colorScheme.onTertiaryContainer
        )
        ButtonType.EQUALS -> ButtonDefaults.buttonColors(
            containerColor = MaterialTheme.colorScheme.primary,
            contentColor = MaterialTheme.colorScheme.onPrimary
        )
    }
    Button(
        onClick = onClick,
        shape = RoundedCornerShape(16.dp),
        colors = buttonColor,
        interactionSource = interactionSource,
        elevation = ButtonDefaults.buttonElevation(
            defaultElevation = 4.dp,
            pressedElevation = 2.dp
        ),
        modifier = modifier
            .height(60.dp)
            .fillMaxWidth()
            .scale(scale.value),
        contentPadding = PaddingValues(0.dp)
    ) {
        Text(
            text = text,
            fontSize = 24.sp,
            fontWeight = FontWeight.Medium,
        )
    }
}
private fun updateDisplay(
    input: String,
    currentDisplay: String,
    isNewNumber: Boolean,
    onUpdate: (String) -> Unit,
) {
    if (isNewNumber) {
        onUpdate(input)
    } else {
        if (currentDisplay == "0") {
            onUpdate(input)
        } else {
            onUpdate(currentDisplay + input)
        }
    }
}
private fun handleOperation(
    op: String,
    currentDisplay: String,
    onOperation: (String, Double) -> Unit,
) {
    val number = currentDisplay.toDoubleOrNull() ?: 0.0
    onOperation(op, number)
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\ConsoleLogger.kt --- 
package com.grindrplus.manager.ui
@Composable
fun ConsoleOutput(
    logEntries: List<LogEntry>,
    modifier: Modifier = Modifier,
    onClear: (() -> Unit)? = null,
) {
    val listState = rememberLazyListState()
    val context = LocalContext.current
    var showCopiedToast by remember { mutableStateOf(false) }
    val logs = logEntries.joinToString("\n") { it.message }
    var uploadingLogs by remember { mutableStateOf(false) }
    val scope = rememberCoroutineScope()
    LaunchedEffect(logEntries.size) {
        if (logEntries.isNotEmpty()) {
            listState.animateScrollToItem(logEntries.size - 1)
        }
    }
    LaunchedEffect(showCopiedToast) {
        if (showCopiedToast) {
            delay(2000)
            showCopiedToast = false
        }
    }
    Column(modifier = modifier) {
        Surface(
            modifier = Modifier
                .fillMaxWidth()
                .height(48.dp),
            color = MaterialTheme.colorScheme.surfaceVariant,
            shape = RoundedCornerShape(topStart = 8.dp, topEnd = 8.dp)
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 12.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Logs (${logEntries.size} entries)",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                Spacer(modifier = Modifier.weight(1f))
                IconButton(
                    onClick = {
                        val clipboard = getSystemService(context, ClipboardManager::class.java)
                        val clip = ClipData.newPlainText("Console Logs", logs)
                        clipboard?.setPrimaryClip(clip)
                        showCopiedToast = true
                    }
                ) {
                    Icon(
                        imageVector = Icons.Default.ContentCopy,
                        contentDescription = "Copy logs",
                        tint = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
                IconButton(
                    onClick = {
                        if (uploadingLogs) return@IconButton
                        uploadingLogs = true
                        scope.launch {
                            Toast.makeText(context, "Uploading logs...", Toast.LENGTH_SHORT).show()
                            uploadAndShare(logs, context)
                            delay(1000) // Prevent from spamming upload button
                        }.invokeOnCompletion {
                            uploadingLogs = false // should be always invoked
                        }
                    }
                ) {
                    Icon(
                        imageVector = Icons.Default.Share,
                        contentDescription = "Share logs",
                        tint = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
                if (onClear != null) {
                    IconButton(onClick = onClear) {
                        Icon(
                            imageVector = Icons.Default.Clear,
                            contentDescription = "Clear logs",
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            }
        }
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .weight(1f)
                .clip(RoundedCornerShape(bottomStart = 8.dp, bottomEnd = 8.dp))
                .background(MaterialTheme.colorScheme.surface.copy(alpha = 0.7f))
                .border(
                    width = 1.dp,
                    color = MaterialTheme.colorScheme.outlineVariant,
                    shape = RoundedCornerShape(bottomStart = 8.dp, bottomEnd = 8.dp)
                )
        ) {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(8.dp),
                state = listState
            ) {
                items(logEntries) { entry ->
                    LogEntryItem(entry)
                }
            }
            if (showCopiedToast) {
                Surface(
                    modifier = Modifier
                        .align(Alignment.TopCenter)
                        .padding(top = 8.dp),
                    color = MaterialTheme.colorScheme.primaryContainer,
                    shape = RoundedCornerShape(4.dp)
                ) {
                    Text(
                        text = "Copied to clipboard",
                        modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp),
                        color = MaterialTheme.colorScheme.onPrimaryContainer
                    )
                }
            }
        }
    }
}
@Composable
internal fun LogEntryItem(entry: LogEntry) {
    val logColor = when (entry.type) {
        // TODO: Move to Theme.kt
        LogType.SUCCESS -> Color(0xFF4CAF50)
        LogType.WARNING -> Color(0xFFFFC107)
        LogType.ERROR -> Color(0xFFE91E63)
        LogType.DEBUG -> Color(0xFF9C27B0)
        LogType.VERBOSE -> Color(0xFF757575)
        LogType.INFO -> MaterialTheme.colorScheme.onSurfaceVariant
    }
    Column {
        val progressBar =
            "<progressBar:([0-9.]+):>".toRegex().find(entry.message)?.groupValues?.get(1)
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 4.dp),
            verticalAlignment = Alignment.Top
        ) {
            Text(
                text = entry.message.replace("<progressBar:$progressBar:>", ""),
                color = logColor,
                style = MaterialTheme.typography.bodySmall,
                fontFamily = FontFamily.Monospace,
                modifier = Modifier.weight(1f)
            )
        }
        val progress = progressBar?.toFloatOrNull()
        if (progress != null) {
            LinearProgressIndicator(
                progress = { progress },
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical = 4.dp)
                    .height(4.dp)
                    .clip(RoundedCornerShape(2.dp)),
                color = logColor,
                trackColor = logColor.copy(alpha = 0.3f),
            )
        }
    }
}
object ConsoleLogger {
    fun log(message: String, type: LogType = LogType.INFO): LogEntry {
        return LogEntry(
            timestamp = System.currentTimeMillis().toString(),
            message = message,
            type = type
        )
    }
    fun parseLogType(message: String): LogType {
        return when {
            message.startsWith("ERROR:") || message.contains("error", ignoreCase = true) ||
                    message.contains("failed", ignoreCase = true) || message.contains(
                "exception",
                ignoreCase = true
            ) ->
                LogType.ERROR
            message.startsWith("WARNING:") || message.contains("warning", ignoreCase = true) ||
                    message.contains("stalled", ignoreCase = true) ->
                LogType.WARNING
            message.startsWith("DEBUG:") || message.startsWith("LSPOSED D") ->
                LogType.DEBUG
            message.contains("complete", ignoreCase = true) || message.contains(
                "success",
                ignoreCase = true
            ) ||
                    message.contains("finished", ignoreCase = true) || message.contains("100%") ->
                LogType.SUCCESS
            else ->
                LogType.INFO
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\HomeScreen.kt --- 
package com.grindrplus.manager.ui
@Composable
fun HomeScreen(innerPadding: PaddingValues, viewModel: HomeViewModel = viewModel()) {
    val context = LocalContext.current
    LaunchedEffect(Unit) {
        viewModel.fetchData()
    }
    Column(
        modifier = Modifier
            .padding(innerPadding)
            .fillMaxSize()
            .padding(24.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                text = "GrindrPlus",
                fontSize = 48.sp,
                fontWeight = FontWeight.Bold
            )
            Text(
                text = "Enhanced Features for Grindr",
                fontSize = 16.sp,
                fontWeight = FontWeight.Medium
            )
        }
        viewModel.errorMessage.value?.let { message ->
            Text(
                text = message,
                color = Red,
                fontSize = 14.sp,
                fontWeight = FontWeight.Medium
            )
        }
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                text = "Contributors",
                fontSize = 14.sp,
                fontWeight = FontWeight.Medium
            )
            if (viewModel.isLoading.value) {
                CircularProgressIndicator(
                    modifier = Modifier.padding(16.dp),
                    strokeWidth = 2.dp
                )
            } else {
                LazyRow(
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    items(viewModel.contributors.size) { index ->
                        val (login, avatarUrl) = viewModel.contributors.entries.elementAt(viewModel.contributors.size - index - 1)
                        AsyncImage(
                            model = avatarUrl,
                            contentDescription = "Avatar of $login",
                            modifier = Modifier
                                .size(48.dp)
                                .clip(CircleShape)
                                .clickable {
                                    Intent(
                                        Intent.ACTION_VIEW,
                                        "https://github.com/$login".toUri()
                                    ).also { intent ->
                                        context.startActivity(intent)
                                    }
                                },
                            contentScale = ContentScale.Crop
                        )
                    }
                }
            }
        }
        LazyColumn(
            verticalArrangement = Arrangement.spacedBy(8.dp),
            modifier = Modifier.padding(top = 16.dp)
        ) {
            val sortedReleases = viewModel.releases.entries.sortedByDescending { (_, release) -> release.publishedAt }
            items(sortedReleases.size) { index ->
                val (_, release) = sortedReleases[index]
                androidx.compose.material3.Card(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(
                        modifier = Modifier.padding(12.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            AsyncImage(
                                model = release.avatarUrl,
                                contentDescription = "Avatar of ${release.author}",
                                modifier = Modifier
                                    .size(32.dp)
                                    .clip(CircleShape),
                                contentScale = ContentScale.Crop
                            )
                            Text(
                                text =
                                    "${release.author} • ${release.name}", fontSize = 14.sp, fontWeight = FontWeight.Bold
                            )
                        }
                        MarkdownText(
                            markdown = release.description,
                            syntaxHighlightColor = Color.Transparent,
                            modifier = Modifier.fillMaxWidth()
                        )
                    }
                }
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\HomeViewModel.kt --- 
package com.grindrplus.manager.ui
data class Release(
    val name: String,
    val description: String,
    val author: String,
    val avatarUrl: String,
    val publishedAt: Instant,
)
class HomeViewModel : ViewModel() {
    val contributors = mutableStateMapOf<String, String>()
    val releases = mutableStateMapOf<String, Release>()
    val isLoading = mutableStateOf(true)
    val errorMessage = mutableStateOf<String?>(null)
    // Flag to avoid multiple fetches
    private var hasFetched = false
    companion object {
        private val TAG = HomeViewModel::class.simpleName
        private const val CONTRIBUTORS_URL = "https://api.github.com/repos/R0rt1z2/GrindrPlus/contributors"
        private const val RELEASES_URL = "https://api.github.com/repos/R0rt1z2/GrindrPlus/releases"
        // Reuse the HTTP client across requests
        private val client = OkHttpClient()
    }
    private suspend fun fetchUrlContent(url: String): String {
        val request = Request.Builder()
            .url(url)
            .header("Accept", "application/vnd.github.v3+json")
            .build()
        return withContext(Dispatchers.IO) {
            client.newCall(request).execute().use { response ->
                if (!response.isSuccessful) {
                    throw Exception("Failed to fetch data: ${response.message}")
                }
                response.body?.string() ?: throw Exception("Empty response body")
            }
        }
    }
    private suspend fun parseContributors(jsonContent: String) = withContext(Dispatchers.Default) {
        val jsonArray = JSONArray(jsonContent)
        // Accumulate new data in a temporary map
        val newContributors = mutableMapOf<String, String>()
        for (i in 0 until jsonArray.length()) {
            val contributor = jsonArray.getJSONObject(i)
            if (contributor.getString("login").contains("bot")) continue
            newContributors[contributor.getString("login")] = contributor.getString("avatar_url")
        }
        // Update the state in bulk
        contributors.clear()
        contributors.putAll(newContributors)
    }
    private suspend fun parseReleases(jsonContent: String) = withContext(Dispatchers.Default) {
        val jsonArray = JSONArray(jsonContent)
        val newReleases = mutableMapOf<String, Release>()
        for (i in 0 until jsonArray.length()) {
            val release = jsonArray.getJSONObject(i)
            val id = release.getString("id")
            val name = if (!release.isNull("name"))
                release.getString("name") else release.getString("tag_name")
            val description = if (!release.isNull("body"))
                release.getString("body") else "No description provided"
            val author = release.getJSONObject("author").getString("login")
            val avatarUrl = release.getJSONObject("author").getString("avatar_url")
            val publishedAt = Instant.parse(release.getString("published_at"))
            newReleases[id] = Release(name, description, author, avatarUrl, publishedAt)
        }
        releases.clear()
        releases.putAll(newReleases)
    }
    fun fetchData(forceRefresh: Boolean = false) {
        if (hasFetched && !forceRefresh) return
        if (forceRefresh) {
            hasFetched = false
            errorMessage.value = null
        }
        hasFetched = true
        isLoading.value = true
        viewModelScope.launch {
            try {
                // Both requests are made in parallel
                val contributorsDeferred = async { fetchUrlContent(CONTRIBUTORS_URL) }
                val releasesDeferred = async { fetchUrlContent(RELEASES_URL) }
                parseContributors(contributorsDeferred.await())
                parseReleases(releasesDeferred.await())
            } catch (e: Exception) {
                Logger.e("$TAG: Error fetching data: ${e.message}")
                errorMessage.value = "An error occurred: ${e.message}"
            } finally {
                isLoading.value = false
            }
        }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\HttpClient.kt --- 
package com.grindrplus.manager.ui
// A single, shared client for the entire app to use.
object HttpClient {
    val instance: OkHttpClient = OkHttpClient.Builder()
        .connectTimeout(15, TimeUnit.SECONDS)
        .readTimeout(15, TimeUnit.SECONDS)
        .build()
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\InstallScreen.kt --- 
package com.grindrplus.manager.ui
private val logEntries = mutableStateListOf<LogEntry>()
@Composable
fun InstallPage(context: Activity, innerPadding: PaddingValues, viewModel: InstallScreenViewModel = viewModel()) {
    // 1. State from ViewModel
    val isLoading by viewModel.isLoading.collectAsState()
    val errorMessage by viewModel.errorMessage.collectAsState()
    val versionData = viewModel.versionData
    // 2. UI-Specific State
    var selectedVersion by remember { mutableStateOf<Data?>(null) }
    var isInstalling by remember { mutableStateOf(false) }
    var isCloning by remember { mutableStateOf(false) }
    var installationSuccessful by remember { mutableStateOf(false) }
    val isRooted = remember { RootBeer(context).isRooted }
    var showCloneDialog by remember { mutableStateOf(false) }
    var installation by remember { mutableStateOf<Installation?>(null) }
    var warningBannerVisible by remember { mutableStateOf(true) }
    var rootedBannerVisible by remember { mutableStateOf(isRooted) }
    var showCustomFileDialog by remember { mutableStateOf(false) }
    var useCustomFiles by remember { mutableStateOf(false) }
    var customVersionName by remember { mutableStateOf("custom") }
    var customBundleUri by remember { mutableStateOf<Uri?>(null) }
    var customModUri by remember { mutableStateOf<Uri?>(null) }
    // 3. Side Effects
    val manifestUrl = (Config.get("custom_manifest", DATA_URL) as String).ifBlank { null }
    LaunchedEffect(Unit) {
        viewModel.loadVersionData(manifestUrl.toString())
    }
    // Creates a background task to auto-select the latest version
    LaunchedEffect(versionData.size) {
        if (selectedVersion == null && versionData.isNotEmpty()) {
            selectedVersion = versionData.first()
            addLog("Auto-selected latest version: ${selectedVersion?.modVer}", LogType.INFO)
        }
    }
    LaunchedEffect(selectedVersion) {
        if (selectedVersion == null) return@LaunchedEffect
        val mapsApiKey = (Config.get("maps_api_key", "") as String).ifBlank { null }
        installation = Installation(
            context,
            selectedVersion!!.modVer,
            selectedVersion!!.modUrl,
            selectedVersion!!.grindrUrl,
            mapsApiKey
        )
    }
    val print: Print = { output ->
        val logType = ConsoleLogger.parseLogType(output)
        context.runOnUiThread {
            addLog(output, logType)
        }
    }
    fun startCustomInstallation() {
        if (customBundleUri == null || customModUri == null) {
            showToast(context, "Please select both bundle and mod files")
            return
        }
        isInstalling = true
        addLog("Starting custom installation with version name: $customVersionName...", LogType.INFO)
        activityScope.launch {
            try {
                val bundleFile = createTempFileFromUri(context, customBundleUri!!, "grindr-$customVersionName.zip")
                val modFile = createTempFileFromUri(context, customModUri!!, "mod-$customVersionName.zip")
                val mapsApiKey = (Config.get("maps_api_key", "") as String).ifBlank { null }
                val customInstallation = Installation(
                    context,
                    customVersionName,
                    modFile.absolutePath,
                    bundleFile.absolutePath,
                    mapsApiKey
                )
                withContext(Dispatchers.IO) {
                    customInstallation.installCustom(
                        bundleFile,
                        modFile,
                        print
                    )
                }
                addLog("Custom installation completed successfully!", LogType.SUCCESS)
                showToast(context, "Installation complete!")
                installationSuccessful = true
            } catch (e: Exception) {
                handleInstallationError(e, context)
            } finally {
                isInstalling = false
            }
        }
    }
    if (showCloneDialog) {
        CloneDialog(
            context = context,
            onDismiss = { showCloneDialog = false },
            onStartCloning = { packageName, appName, debuggable, embedLSPatch ->
                showCloneDialog = false
                isCloning = true
                activityScope.launch {
                    addLog("Starting Grindr cloning process...", LogType.INFO)
                    addLog("Target package: $packageName", LogType.INFO)
                    addLog("Target app name: $appName", LogType.INFO)
                    val success = try {
                        installation!!.cloneGrindr(
                            packageName, appName, debuggable, embedLSPatch,
                            print
                        )
                        true
                    } catch (e: Exception) {
                        Logger.i("Cloning failed: ${e.localizedMessage}")
                        addLog("Cloning failed: ${e.localizedMessage}", LogType.ERROR)
                        false
                    }
                    if (success) {
                        addLog("Grindr clone created successfully!", LogType.SUCCESS)
                    } else {
                        addLog("Failed to clone Grindr", LogType.ERROR)
                    }
                    isCloning = false
                }
            }
        )
    }
    if (showCustomFileDialog) {
        FileDialog(
            context = context,
            onDismiss = { showCustomFileDialog = false },
            onSelect = { versionName, bundleUri, modUri ->
                customVersionName = versionName
                customBundleUri = bundleUri
                customModUri = modUri
                useCustomFiles = true
                showCustomFileDialog = false
                addLog("Custom files selected. Version: $versionName", LogType.INFO)
                addLog("Bundle: ${bundleUri.lastPathSegment}, Mod: ${modUri.lastPathSegment}", LogType.INFO)
            }
        )
    }
    Column(
        modifier = Modifier
            .padding(innerPadding)
            .padding(16.dp)
            .fillMaxSize()
    ) {
        if (isLoading) {
            LoadingScreen()
        } else if (errorMessage != null) {
            ErrorScreen(errorMessage!!) {
                viewModel.loadVersionData(manifestUrl.toString())
            }
        } else {
            MessageBanner(
                text = "• Don't close the app while installation is in progress\n• Grindr WILL crash on first launch after installation",
                isVisible = warningBannerVisible,
                isPulsating = isInstalling || isCloning,
                modifier = Modifier.fillMaxWidth(),
                type = BannerType.WARNING,
                onDismiss = { warningBannerVisible = false }
            )
            if (isLSPosed()) {
                MessageBanner(
                    text = "We detected that you are using LSPosed. Only use this screen to create clones, not to install the modded Grindr.",
                    isVisible = rootedBannerVisible,
                    isPulsating = true,
                    modifier = Modifier.fillMaxWidth(),
                    type = BannerType.ERROR,
                    onDismiss = { rootedBannerVisible = false }
                )
            }
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                VersionSelector(
                    versions = if (useCustomFiles)
                        listOf(Data(customVersionName, "", "")) + versionData
                    else
                        versionData,
                    selectedVersion = if (useCustomFiles && customBundleUri != null)
                        Data(customVersionName, "", "")
                    else
                        selectedVersion,
                    onVersionSelected = { selected ->
                        if (selected.modVer == customVersionName && useCustomFiles) {
                        } else if (selected.modVer == "custom") {
                            showCustomFileDialog = true
                        } else {
                            selectedVersion = selected
                            useCustomFiles = false
                            addLog("Selected version ${selected.modVer}", LogType.INFO)
                        }
                    },
                    isEnabled = !isInstalling && !isCloning,
                    modifier = Modifier.fillMaxWidth(),
                    customOption = "Use Custom Files..."
                )
            }
            Spacer(modifier = Modifier.height(16.dp))
            ConsoleOutput(
                logEntries = logEntries,
                modifier = Modifier.weight(0.5f),
                onClear = {
                    logEntries.clear()
                    addLog("Successfully cleared logs!", LogType.SUCCESS)
                }
            )
            Spacer(modifier = Modifier.height(16.dp))
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                OutlinedButton(
                    onClick = {
                        activityScope.launch {
                            try {
                                withContext(Dispatchers.IO) {
                                    StorageUtils.cleanupOldInstallationFiles(
                                        context, true, selectedVersion?.modVer
                                    )
                                }
                                addLog(
                                    "Cleaned up old installation files",
                                    LogType.SUCCESS
                                )
                            } catch (e: Exception) {
                                addLog(
                                    "Failed to clean up: ${e.localizedMessage}",
                                    LogType.ERROR
                                )
                            }
                        }
                    },
                    enabled = !isInstalling && !isCloning,
                    colors = ButtonDefaults.outlinedButtonColors(
                        contentColor = MaterialTheme.colorScheme.primary,
                        disabledContentColor = MaterialTheme.colorScheme.onSurface.copy(
                            alpha = 0.38f
                        )
                    ),
                    modifier = Modifier.weight(1f)
                ) {
                    Text(
                        "Clean Up",
                        modifier = Modifier.padding(vertical = 8.dp)
                    )
                }
                Spacer(modifier = Modifier.width(16.dp))
                Button(
                    onClick = {
                        if (installationSuccessful) {
                            launchGrindr(context)
                        } else {
                            if (useCustomFiles && customBundleUri != null && customModUri != null) {
                                startCustomInstallation()
                            } else {
                                if (selectedVersion == null) {
                                    showToast(context, "Please select a version first")
                                    return@Button
                                }
                                startInstallation(
                                    selectedVersion!!,
                                    onStarted = { isInstalling = true },
                                    onCompleted = { success ->
                                        isInstalling = false
                                        installationSuccessful = success
                                    },
                                    context,
                                    print
                                )
                            }
                        }
                    },
                    enabled = ((selectedVersion != null || (useCustomFiles && customBundleUri != null && customModUri != null)) ||
                            installationSuccessful) && !isInstalling && !isCloning,
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.primary,
                        contentColor = MaterialTheme.colorScheme.onPrimary,
                        disabledContainerColor = MaterialTheme.colorScheme.onSurface.copy(
                            alpha = 0.12f
                        ),
                        disabledContentColor = MaterialTheme.colorScheme.onSurface.copy(
                            alpha = 0.38f
                        )
                    ),
                    modifier = Modifier.weight(1f)
                ) {
                    Text(
                        text = if (isInstalling) {
                            "Installing..."
                        } else if (installationSuccessful) {
                            "Open Grindr"
                        } else {
                            "Install"
                        },
                        modifier = Modifier.padding(vertical = 8.dp)
                    )
                }
            }
            if (isGrindrInstalled(context)) {
                Spacer(modifier = Modifier.height(8.dp))
                Button(
                    onClick = { showCloneDialog = true },
                    enabled = !isInstalling && !isCloning,
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.secondaryContainer,
                        contentColor = MaterialTheme.colorScheme.onSecondaryContainer
                    ),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Icon(
                        imageVector = Icons.Default.ContentCopy,
                        contentDescription = "Clone",
                        modifier = Modifier.padding(end = 8.dp)
                    )
                    Text(
                        text = if (isCloning) "Cloning..." else "Clone Grindr",
                        modifier = Modifier.padding(vertical = 8.dp)
                    )
                }
            }
        }
    }
}
@Composable
fun LoadingScreen() {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            modifier = Modifier.padding(horizontal = 24.dp)
        ) {
            CircularProgressIndicator(
                color = MaterialTheme.colorScheme.primary,
                trackColor = MaterialTheme.colorScheme.surfaceVariant
            )
            Spacer(modifier = Modifier.height(16.dp))
            Text(
                "Loading available versions...",
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onBackground
            )
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                "If loading appears stuck, please force close the app and try again.",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                textAlign = TextAlign.Center
            )
        }
    }
}
@Composable
fun ErrorScreen(errorMessage: String, onRetry: () -> Unit) {
    Column(
        modifier = Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(
            text = "Error: $errorMessage",
            style = MaterialTheme.typography.bodyLarge,
            color = MaterialTheme.colorScheme.error
        )
        Spacer(modifier = Modifier.height(16.dp))
        Button(
            onClick = onRetry,
            colors = ButtonDefaults.buttonColors(
                containerColor = MaterialTheme.colorScheme.primary,
                contentColor = MaterialTheme.colorScheme.onPrimary
            )
        ) {
            Text("Retry")
        }
    }
}
private fun startInstallation(
    version: Data,
    onStarted: () -> Unit,
    onCompleted: (Boolean) -> Unit,
    context: Activity,
    print: Print
) {
    onStarted()
    addLog("Starting installation for version ${version.modVer}...", LogType.INFO)
    activityScope.launch {
        try {
            val mapsApiKey = (Config.get("maps_api_key", "") as String).ifBlank { null }
            val installation = Installation(
                context,
                version.modVer,
                version.modUrl,
                version.grindrUrl,
                mapsApiKey
            )
            withContext(Dispatchers.IO) {
                installation.install(
                    print = print
                )
            }
            addLog("Installation completed successfully!", LogType.SUCCESS)
            showToast(context, "Installation complete!")
            onCompleted(true)
        } catch (e: Exception) {
            handleInstallationError(e, context)
            onCompleted(false)
        }
    }
}
private suspend fun createTempFileFromUri(context: Context, uri: Uri, filename: String): File {
    return withContext(Dispatchers.IO) {
        val tempFile = File(context.filesDir, filename)
        context.contentResolver.openInputStream(uri)?.use { inputStream ->
            tempFile.outputStream().use { outputStream ->
                inputStream.copyTo(outputStream)
            }
        } ?: throw IOException("Failed to open input stream for URI: $uri")
        tempFile
    }
}
private fun handleInstallationError(e: Exception, context: Context) {
    val errorMessage = "ERROR: ${e.localizedMessage ?: "Unknown error"}"
    addLog(errorMessage, LogType.ERROR)
    if (errorMessage.contains("INCOMPATIBLE") || e.message?.contains("INCOMPATIBLE") == true) {
        if (context is MainActivity) {
            context.runOnUiThread { MainActivity.showUninstallDialog.value = true }
        } else {
            showToast(context, "Installation failed: Signature mismatch. Please uninstall Grindr first.")
        }
    } else {
        showToast(context, "Installation failed: ${e.localizedMessage}")
    }
    ErrorHandler.logError(
        context,
        TAG,
        "Installation failed",
        e
    )
}
private fun addLog(message: String, type: LogType = LogType.INFO) {
    if (message.contains("<>:")) {
        val prefix = message.split("<>:")[0]
        logEntries.find { it.message.startsWith(prefix) }?.let {
            logEntries.remove(it)
        }
    }
    val logEntry = ConsoleLogger.log(message.replace("<>:", ":"), type)
    logEntries.add(logEntry)
}
private fun showToast(context: Context, message: String) {
    Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
}
private fun launchGrindr(context: Context) {
    try {
        val launchIntent = context.packageManager.getLaunchIntentForPackage(GRINDR_PACKAGE_NAME)
        if (launchIntent != null) {
            context.startActivity(launchIntent)
        } else {
            showToast(context, "Could not launch Grindr. App may need to be opened manually.")
        }
    } catch (e: Exception) {
        showToast(context, "Error launching Grindr: ${e.localizedMessage}")
    }
}
private fun isGrindrInstalled(context: Context): Boolean {
    return try {
        context.packageManager.getPackageInfo(GRINDR_PACKAGE_NAME, 0)
        true
    } catch (_: PackageManager.NameNotFoundException) {
        false
    }
}
data class Data(
    val modVer: String,
    val grindrUrl: String,
    val modUrl: String,
) 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\InstallScreenViewModel.kt --- 
package com.grindrplus.manager.ui
class InstallScreenViewModel : ViewModel() {
    private val _isLoading = MutableStateFlow(true)
    val isLoading = _isLoading.asStateFlow()
    private val _loadingText = MutableStateFlow("Loading available versions...")
    private val _errorMessage = MutableStateFlow<String?>(null)
    val errorMessage = _errorMessage.asStateFlow()
    val versionData = mutableStateListOf<Data>()
    fun loadVersionData(manifestUrl: String) {
        _isLoading.value = true
        _errorMessage.value = null
        viewModelScope.launch {
            // Update loading text after 10 seconds of waiting
            val textUpdateJob = launch {
                delay(10000)
                _loadingText.value = "Still loading... Check your internet connectivity."
            }
            val result = withContext(Dispatchers.IO) {
                fetchVersions(manifestUrl)
            }
            textUpdateJob.cancel() // Cancel the text update job once loading is done
            if (result.isSuccess) {
                versionData.clear()
                versionData.addAll(result.getOrThrow())
                Logger.d("Found ${versionData.size} available versions")
            } else {
                _errorMessage.value = result.exceptionOrNull()?.localizedMessage ?: "Unknown error"
                Logger.e("Error loading version data: ${_errorMessage.value}")
            }
            _isLoading.value = false
        }
    }
    private fun fetchVersions(manifestUrl: String): Result<List<Data>> {
        val client = HttpClient.instance
        val maxRetries = 3
        var lastException: Exception? = null
        for (attempt in 1..maxRetries) {
            try {
                Logger.d("Loading version data from $manifestUrl (Attempt $attempt/$maxRetries)")
                val request = Request.Builder().url(manifestUrl).build()
                client.newCall(request).execute().use { response ->
                    if (!response.isSuccessful) throw IOException("Server error: ${response.code}")
                    val body = response.body?.string() ?: throw IOException("Empty response body")
                    return Result.success(parseVersionData(body))
                }
            } catch (e: Exception) {
                lastException = e
                Logger.e("Attempt $attempt failed: ${e.message}")
                if (attempt < maxRetries) Thread.sleep(2000) // Use sleep for non-coroutine delay
            }
        }
        return Result.failure(lastException ?: IOException("Unknown error after $maxRetries retries"))
    }
    private fun parseVersionData(jsonData: String): List<Data> {
        return try {
            val result = mutableListOf<Data>()
            val jsonObject = JSONObject(jsonData)
            jsonObject.keys().forEach { key ->
                val jsonArray = jsonObject.getJSONArray(key)
                if (jsonArray.length() >= 2) {
                    result.add(
                        Data(
                            modVer = key,
                            grindrUrl = jsonArray.getString(0),
                            modUrl = jsonArray.getString(1)
                        )
                    )
                }
            }
            result.sortedByDescending { it.modVer }
        } catch (e: JSONException) {
            throw IOException("Invalid data format: ${e.localizedMessage}")
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\LogExplorerScreen.kt --- 
package com.grindrplus.manager.ui
enum class LogType {
    INFO, WARNING, ERROR, DEBUG, VERBOSE, SUCCESS
}
data class LogEntry(
    val timestamp: String?,
    val message: String,
    val type: LogType
)
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DebugLogsScreen(
    onBack: () -> Unit,
) {
    var logs by remember { mutableStateOf(emptyList<LogEntry>()) }
    val context = LocalContext.current
    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()
    var showExportDialog by remember { mutableStateOf(false) }
    var showReportDialog by remember { mutableStateOf(false) }
    var debugModeEnabled by remember {
        mutableStateOf(Config.get("debug_mode", false) as Boolean)
    }
    val isDebugBuild = BuildConfig.DEBUG
    BackHandler(onBack = onBack)
    LaunchedEffect(Unit) {
        launch {
            withContext(Dispatchers.IO) {
                val log = File(context.getExternalFilesDir(null), "grindrplus.log")
                fun parseLogs(logs: List<String>) =
                    logs.map {
                        LogEntry(
                            timestamp = null,
                            message = it,
                            type = when {
                                it.startsWith("I") -> LogType.INFO
                                it.startsWith("W") -> LogType.WARNING
                                it.startsWith("E") -> LogType.ERROR
                                it.startsWith("D") -> LogType.DEBUG
                                it.startsWith("V") -> LogType.VERBOSE
                                else -> LogType.INFO
                            }
                        )
                    }
                logs = parseLogs(log.readLines())
                val watchService = FileSystems.getDefault().newWatchService()
                log.toPath().parent.register(
                    watchService,
                    java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY
                )
                while (true) {
                    val key = watchService.take()
                    for (event in key.pollEvents()) {
                        if (event.context() == log.name) {
                            val newLog = log.readLines()
                            logs = parseLogs(newLog)
                        }
                    }
                    key.reset()
                }
            }
        }
    }
    if (showExportDialog) {
        ExportLogsDialog(
            onDismissRequest = { showExportDialog = false },
            onZipExport = {
                scope.launch {
                    try {
                        val zipFile = FileOperationHandler.createLogsZip(context)
                        if (zipFile != null) {
                            FileOperationHandler.exportZipFile(
                                "grindrplus_logs.zip",
                                zipFile
                            )
                        } else {
                            snackbarHostState.showSnackbar("Failed to create logs package")
                        }
                    } catch (e: Exception) {
                        snackbarHostState.showSnackbar("Error exporting logs: ${e.message}")
                    }
                    showExportDialog = false
                }
            },
            onUrlExport = {
                showExportDialog = false
                scope.launch(Dispatchers.IO) {
                    try {
                        withContext(Dispatchers.Main) {
                            snackbarHostState.showSnackbar("Generating URL... This may take a while.")
                        }
                        val log = File(context.getExternalFilesDir(null), "grindrplus.log")
                        val logContent = log.readText()
                        uploadAndShare(logContent, context)
                    } catch (e: Exception) {
                        withContext(Dispatchers.Main) {
                            snackbarHostState.showSnackbar("Error: ${e.message ?: "Unknown error"}")
                        }
                    }
                }
            }
        )
    }
    if (showReportDialog) {
        ReportIssueDialog(
            onDismiss = { showReportDialog = false },
            onOpenGitHub = {
                val intent = Intent(Intent.ACTION_VIEW, "https://github.com/R0rt1z2/GrindrPlus/issues".toUri())
                context.startActivity(intent)
                showReportDialog = false
            }
        )
    }
    Scaffold(
        snackbarHost = {
            SnackbarHost(
                hostState = snackbarHostState,
                modifier = Modifier.padding(bottom = 80.dp)
            )
        },
        topBar = {
            TopAppBar(
                title = { Text("Logs") },
                navigationIcon = {
                    IconButton(onClick = onBack) {
                        Icon(
                            imageVector = Icons.Default.ChevronRight,
                            contentDescription = "Back",
                            modifier = Modifier.rotate(180f)
                        )
                    }
                },
                actions = {
                    IconButton(
                        onClick = {
                            if (!isDebugBuild) {
                                val newState = !debugModeEnabled
                                debugModeEnabled = newState
                                Config.put("debug_mode", newState)
                                scope.launch {
                                    snackbarHostState.showSnackbar(
                                        if (newState) "Verbose logging enabled" else "Verbose logging disabled"
                                    )
                                }
                            }
                        },
                        enabled = !isDebugBuild
                    ) {
                        Box {
                            Icon(
                                imageVector = Icons.Default.Code,
                                contentDescription = "Toggle Verbose Logging",
                                tint = if (isDebugBuild || debugModeEnabled)
                                    MaterialTheme.colorScheme.primary
                                else
                                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)
                            )
                            if (isDebugBuild) {
                                Box(
                                    modifier = Modifier
                                        .size(8.dp)
                                        .background(MaterialTheme.colorScheme.primary, CircleShape)
                                        .align(Alignment.TopEnd)
                                )
                            }
                        }
                    }
                }
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(horizontal = 16.dp, vertical = 8.dp)
        ) {
            LogsViewer(
                logs = logs,
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(16.dp))
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Button(
                    onClick = { showExportDialog = true },
                    modifier = Modifier.weight(1f)
                ) {
                    Text("Export Logs")
                }
                Spacer(modifier = Modifier.padding(horizontal = 8.dp))
                Button(
                    onClick = {
                        logs = emptyList()
                        Logger.clearLogs()
                    },
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.errorContainer,
                        contentColor = MaterialTheme.colorScheme.onErrorContainer
                    )
                ) {
                    Text("Clear Logs")
                }
            }
            Spacer(modifier = Modifier.height(8.dp))
            Button(
                onClick = { showReportDialog = true },
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.secondaryContainer,
                    contentColor = MaterialTheme.colorScheme.onSecondaryContainer
                )
            ) {
                Text("Report an Issue")
            }
            Spacer(modifier = Modifier.height(90.dp))
        }
    }
}
@Composable
fun LogsViewer(
    logs: List<LogEntry>,
    modifier: Modifier = Modifier
) {
    val listState = rememberLazyListState()
    LaunchedEffect(logs.size) {
        if (logs.isNotEmpty()) {
            listState.scrollToItem(logs.size - 1)
        }
    }
    Card(
        modifier = modifier,
        shape = RoundedCornerShape(8.dp)
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f))
        ) {
            if (logs.isEmpty()) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        "No logs available",
                        color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f)
                    )
                }
            } else {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(horizontal = 8.dp, vertical = 4.dp),
                    state = listState
                ) {
                    items(logs) { logEntry ->
                        LogEntryItem(logEntry)
                        if (logEntry != logs.last()) {
                            HorizontalDivider(
                                color = MaterialTheme.colorScheme.outlineVariant.copy(alpha = 0.3f),
                                modifier = Modifier.padding(vertical = 2.dp)
                            )
                        }
                    }
                }
            }
        }
    }
}
@Composable
fun ExportLogsDialog(
    onDismissRequest: () -> Unit,
    onZipExport: () -> Unit,
    onUrlExport: () -> Unit
) {
    Dialog(onDismissRequest = onDismissRequest) {
        Card(
            modifier = Modifier
                .fillMaxWidth(0.9f)
                .padding(16.dp),
            shape = MaterialTheme.shapes.large
        ) {
            Column(
                modifier = Modifier.padding(24.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "Export Logs",
                    style = MaterialTheme.typography.headlineSmall
                )
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    text = "Choose how you would like to export the logs:",
                    style = MaterialTheme.typography.bodyMedium
                )
                Spacer(modifier = Modifier.height(24.dp))
                Column(
                    verticalArrangement = Arrangement.spacedBy(16.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Button(
                        onClick = onZipExport,
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(48.dp)
                    ) {
                        Text(
                            "Generate ZIP",
                            fontSize = 14.sp,
                            maxLines = 1,
                            overflow = TextOverflow.Ellipsis
                        )
                    }
                    Button(
                        onClick = onUrlExport,
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(48.dp),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.secondaryContainer,
                            contentColor = MaterialTheme.colorScheme.onSecondaryContainer
                        )
                    ) {
                        Text(
                            "Generate URL",
                            fontSize = 14.sp,
                            maxLines = 1,
                            overflow = TextOverflow.Ellipsis
                        )
                    }
                    Button(
                        onClick = onDismissRequest,
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(48.dp),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.surfaceVariant,
                            contentColor = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    ) {
                        Text("Cancel")
                    }
                }
            }
        }
    }
}
@Composable
fun ReportIssueDialog(
    onDismiss: () -> Unit,
    onOpenGitHub: () -> Unit
) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth(0.9f)
                .padding(16.dp),
            shape = MaterialTheme.shapes.large
        ) {
            Box(modifier = Modifier.fillMaxWidth()) {
                IconButton(
                    onClick = onDismiss,
                    modifier = Modifier
                        .align(Alignment.TopEnd)
                        .size(36.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Close,
                        contentDescription = "Close dialog",
                        tint = MaterialTheme.colorScheme.onSurfaceVariant,
                        modifier = Modifier.size(18.dp)
                    )
                }
                Column(
                    modifier = Modifier.padding(24.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        text = "Report an Issue",
                        style = MaterialTheme.typography.headlineSmall
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    Text(
                        text = "To help the developer fix issues, you can report it on GitHub by using the \"New Issue\" button and then using the \"Bug Report\" template.",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                    Spacer(modifier = Modifier.height(24.dp))
                    Button(
                        onClick = onOpenGitHub,
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(48.dp)
                    ) {
                        Text("Open GitHub")
                    }
                }
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\NotificationsScreen.kt --- 
package com.grindrplus.manager.ui
@Composable
fun NotificationScreen(innerPadding: PaddingValues) {
    val messages by tgMessages.collectAsState()
    val listState = rememberLazyListState()
    val context = LocalContext.current
    if (messages.isEmpty()) {
        LaunchedEffect(Unit) { fetchNotifs(context) }
    }
    LaunchedEffect(messages.size) {
        if (messages.isNotEmpty()) {
            listState.animateScrollToItem(messages.size - 1)
        }
    }
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(innerPadding)
    ) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
                .clickable {
                    context.startActivity(Intent(Intent.ACTION_VIEW).apply {
                        data = "https://t.me/grindrplusci".toUri()
                    })
                },
            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
        ) {
            Column {
                Text(
                    text = "News & Updates",
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.padding(16.dp),
                    textAlign = TextAlign.Center
                )
                MarkdownText(
                    markdown = "This is a mirror of our Telegram channel, click <b>here</b> to join.",
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier
                        .padding(horizontal = 16.dp)
                        .padding(bottom = 12.dp),
                )
            }
        }
        if (messages.isEmpty()) {
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = "No messages yet",
                    style = MaterialTheme.typography.bodyLarge,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        } else {
            LazyColumn(
                state = listState,
                modifier = Modifier
                    .fillMaxSize()
                    .padding(horizontal = 16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp),
                contentPadding = PaddingValues(vertical = 16.dp)
            ) {
                items(messages) { message ->
                    MessageBubble(message = message)
                }
            }
        }
    }
}
@Composable
fun MessageBubble(message: com.grindrplus.manager.GPlusMessage) {
    val dateFormat = remember { SimpleDateFormat("MMM dd, yyyy HH:mm", Locale.getDefault()) }
    val formattedTime = remember(message.timestamp) {
        dateFormat.format(Date(message.timestamp * 1000))
    }
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.Start
    ) {
        Card(
            modifier = Modifier
                .widthIn(max = 280.dp)
                .wrapContentWidth(),
            shape = RoundedCornerShape(
                topStart = 4.dp,
                topEnd = 16.dp,
                bottomStart = 16.dp,
                bottomEnd = 16.dp
            ),
            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
        ) {
            Column(
                modifier = Modifier.padding(12.dp)
            ) {
                MarkdownText(
                    markdown = message.content,
                    syntaxHighlightColor = Color.Transparent,
                )
                Spacer(modifier = Modifier.height(4.dp))
                Text(
                    text = formattedTime,
                    style = MaterialTheme.typography.labelSmall,
                    color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.7f),
                    modifier = Modifier.align(Alignment.End)
                )
            }
        }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\SettingsScreen.kt --- 
package com.grindrplus.manager.ui
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SettingsScreen(
    viewModel: SettingsViewModel = rememberViewModel(),
) {
    val isLoading by viewModel.isLoading.collectAsState()
    val settingGroups by viewModel.settingGroups.collectAsState()
    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()
    var showAboutDialog by remember { mutableStateOf(false) }
    var showResetDialog by remember { mutableStateOf(false) }
    val context = LocalContext.current
    var debugLogsScreen by remember { mutableStateOf(false) }
    val showApiKeyTestDialog by viewModel.showApiKeyTestDialog.collectAsState()
    val apiKeyTestTitle by viewModel.apiKeyTestTitle.collectAsState()
    val apiKeyTestMessage by viewModel.apiKeyTestMessage.collectAsState()
    val apiKeyTestRawResponse by viewModel.apiKeyTestRawResponse.collectAsState()
    val apiKeyTestLoading by viewModel.apiKeyTestLoading.collectAsState()
    if (debugLogsScreen) {
        DebugLogsScreen(
            onBack = { debugLogsScreen = false },
        )
        return
    }
    if (showAboutDialog) {
        AboutDialog(
            onDismiss = { showAboutDialog = false },
            onViewSourceCode = {
                val intent =
                    Intent(Intent.ACTION_VIEW, "https://github.com/R0rt1z2/GrindrPlus".toUri())
                context.startActivity(intent)
            }
        )
    }
    if (showResetDialog) {
        ResetSettingsDialog(
            onDismiss = { showResetDialog = false },
            onConfirm = {
                scope.launch {
                    Config.writeRemoteConfig(JSONObject())
                    val packageManager = context.packageManager
                    val intent = packageManager.getLaunchIntentForPackage(context.packageName)
                    intent?.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
                    context.startActivity(intent)
                    android.os.Process.killProcess(android.os.Process.myPid())
                }
            }
        )
    }
    if (showApiKeyTestDialog) {
        ApiKeyTestDialog(
            isLoading = apiKeyTestLoading,
            title = apiKeyTestTitle,
            message = apiKeyTestMessage,
            rawResponse = apiKeyTestRawResponse,
            onDismiss = viewModel::dismissApiKeyTestDialog
        )
    }
    Scaffold(
        modifier = Modifier.fillMaxSize(),
        snackbarHost = { SnackbarHost(snackbarHostState) },
        topBar = {
            TopAppBar(
                title = { Text("Settings") },
                actions = {
                    Box {
                        var expanded by remember { mutableStateOf(false) }
                        IconButton(onClick = { expanded = true }) {
                            Icon(
                                imageVector = Icons.Default.MoreVert,
                                contentDescription = "More options"
                            )
                        }
                        DropdownMenu(
                            expanded = expanded,
                            onDismissRequest = { expanded = false }
                        ) {
                            DropdownMenuItem(
                                text = { Text("Debug logs") },
                                onClick = {
                                    expanded = false
                                    debugLogsScreen = true
                                }
                            )
                            DropdownMenuItem(
                                text = { Text("Export settings") },
                                onClick = {
                                    expanded = false
                                    scope.launch {
                                        val result = Config.readRemoteConfig()
                                        FileOperationHandler.exportFile(
                                            "grindrplus_settings.json",
                                            result.toString(4)
                                        )
                                        snackbarHostState.showSnackbar("Settings exported successfully")
                                    }
                                }
                            )
                            DropdownMenuItem(
                                text = { Text("Import settings") },
                                onClick = {
                                    expanded = false
                                    try {
                                        FileOperationHandler.importFile(
                                            arrayOf("application/json")
                                        ) {
                                            Config.writeRemoteConfig(JSONObject(it))
                                            viewModel.loadSettings()
                                            scope.launch {
                                                snackbarHostState.showSnackbar("Settings imported successfully")
                                            }
                                        }
                                    } catch (e: Exception) {
                                        scope.launch {
                                            snackbarHostState.showSnackbar("Failed to import settings: ${e.message}")
                                        }
                                    }
                                }
                            )
                            DropdownMenuItem(
                                text = { Text("Reset settings") },
                                onClick = {
                                    expanded = false
                                    showResetDialog = true
                                }
                            )
                            DropdownMenuItem(
                                text = { Text("About") },
                                onClick = {
                                    expanded = false
                                    showAboutDialog = true
                                }
                            )
                        }
                    }
                }
            )
        }
    ) { innerPadding ->
        if (isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(innerPadding),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator(
                    color = MaterialTheme.colorScheme.primary,
                    strokeWidth = 3.dp
                )
            }
        } else {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(innerPadding),
                verticalArrangement = Arrangement.spacedBy(16.dp),
                contentPadding = PaddingValues(
                    top = 16.dp,
                    start = 16.dp,
                    end = 16.dp,
                    bottom = 100.dp
                )
            ) {
                item {
                    PackageSelector(
                        onPackageSelected = { packageName ->
                            viewModel.loadSettings()
                        }
                    )
                }
                settingGroups.forEach { group ->
                    item {
                        SettingGroupSection(
                            group = group,
                            onSettingChanged = {
                                scope.launch {
                                    snackbarHostState.showSnackbar("Setting updated")
                                }
                            }
                        )
                    }
                }
            }
        }
    }
}
@Composable
fun ResetSettingsDialog(
    onDismiss: () -> Unit,
    onConfirm: () -> Unit
) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            shape = MaterialTheme.shapes.large
        ) {
            Column(
                modifier = Modifier.padding(24.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "Reset Settings",
                    style = MaterialTheme.typography.headlineSmall
                )
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    text = "This action will reset all settings to their default values. This action cannot be undone and the app will restart.",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Spacer(modifier = Modifier.height(24.dp))
                Row(
                    horizontalArrangement = Arrangement.spacedBy(16.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Button(
                        onClick = onDismiss,
                        modifier = Modifier
                            .weight(1f)
                            .height(48.dp),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.surfaceVariant,
                            contentColor = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    ) {
                        Text("Cancel")
                    }
                    Button(
                        onClick = onConfirm,
                        modifier = Modifier
                            .weight(1f)
                            .height(48.dp),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.error,
                            contentColor = MaterialTheme.colorScheme.onError
                        )
                    ) {
                        Text("Reset")
                    }
                }
            }
        }
    }
}
@Composable
fun AboutDialog(
    onDismiss: () -> Unit,
    onViewSourceCode: () -> Unit,
) {
    val context = LocalContext.current
    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth(1f)
                .padding(16.dp),
            shape = MaterialTheme.shapes.large
        ) {
            Column(
                modifier = Modifier.padding(24.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "GrindrPlus",
                    style = MaterialTheme.typography.headlineMedium
                )
                Spacer(modifier = Modifier.height(16.dp))
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.Center
                ) {
                    Surface(
                        modifier = Modifier.size(56.dp),
                        shape = MaterialTheme.shapes.medium,
                        color = MaterialTheme.colorScheme.primaryContainer
                    ) {
                        Box(contentAlignment = Alignment.Center) {
                            Icon(
                                imageVector = Icons.Default.Info,
                                contentDescription = "App Icon",
                                tint = MaterialTheme.colorScheme.onPrimaryContainer,
                                modifier = Modifier.size(32.dp)
                            )
                        }
                    }
                    Spacer(modifier = Modifier.width(16.dp))
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text(
                            text = "Made with ❤️ by",
                            style = MaterialTheme.typography.bodyLarge
                        )
                        Row {
                            Text(
                                text = "R0rt1z2",
                                style = MaterialTheme.typography.bodyLarge.copy(
                                    color = MaterialTheme.colorScheme.primary
                                ),
                                modifier = Modifier.clickable {
                                    val intent = Intent(
                                        Intent.ACTION_VIEW,
                                        "https://github.com/R0rt1z2".toUri()
                                    )
                                    context.startActivity(intent)
                                }
                            )
                            Text(
                                text = " and ",
                                style = MaterialTheme.typography.bodyLarge
                            )
                            Text(
                                text = "Rattly",
                                style = MaterialTheme.typography.bodyLarge.copy(
                                    color = MaterialTheme.colorScheme.primary
                                ),
                                modifier = Modifier.clickable {
                                    val intent = Intent(
                                        Intent.ACTION_VIEW,
                                        "https://github.com/Rattlyy".toUri()
                                    )
                                    context.startActivity(intent)
                                }
                            )
                        }
                    }
                }
                Spacer(modifier = Modifier.height(24.dp))
                Row(
                    horizontalArrangement = Arrangement.spacedBy(16.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Button(
                        onClick = onDismiss,
                        modifier = Modifier
                            .weight(1f)
                            .height(56.dp),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.surfaceVariant,
                            contentColor = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    ) {
                        Text(
                            "Close",
                            style = MaterialTheme.typography.titleMedium
                        )
                    }
                    Button(
                        onClick = onViewSourceCode,
                        modifier = Modifier
                            .weight(1f)
                            .height(56.dp)
                    ) {
                        Text(
                            "Source",
                            style = MaterialTheme.typography.titleMedium
                        )
                    }
                }
            }
        }
    }
}
@Composable
fun SettingGroupSection(
    group: SettingGroup,
    onSettingChanged: () -> Unit,
) {
    Column(
        modifier = Modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        Text(
            text = group.title,
            style = MaterialTheme.typography.titleMedium,
            color = MaterialTheme.colorScheme.primary,
            modifier = Modifier.padding(bottom = 4.dp)
        )
        Surface(
            modifier = Modifier.fillMaxWidth(),
            color = MaterialTheme.colorScheme.surfaceContainer,
            shape = MaterialTheme.shapes.medium,
            tonalElevation = 1.dp
        ) {
            Column {
                group.settings.forEachIndexed { index, setting ->
                    ImprovedSettingItem(setting, onSettingChanged)
                    if (index < group.settings.size - 1) {
                        HorizontalDivider(
                            modifier = Modifier.padding(horizontal = 16.dp),
                            color = MaterialTheme.colorScheme.outlineVariant.copy(alpha = 0.5f)
                        )
                    }
                }
            }
        }
    }
}
@Composable
fun ImprovedSettingItem(
    setting: Setting,
    onSettingChanged: () -> Unit,
) {
    when (setting) {
        is SwitchSetting -> ImprovedSwitchSetting(setting) { onSettingChanged() }
        is TextSetting -> ImprovedTextSetting(setting) { onSettingChanged() }
        is TextSettingWithButtons -> ImprovedTextSettingWithButtons(setting) { onSettingChanged() }
        is ButtonSetting -> ImprovedButtonSetting(setting)
    }
}
@Composable
fun ImprovedSwitchSetting(
    setting: SwitchSetting,
    onChanged: () -> Unit,
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 14.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = setting.title,
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurface
            )
            setting.description?.let {
                Text(
                    text = it,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.padding(top = 2.dp)
                )
            }
        }
        Spacer(modifier = Modifier.width(16.dp))
        Switch(
            checked = setting.isChecked,
            onCheckedChange = {
                setting.onCheckedChange(it)
                onChanged()
            },
            colors = SwitchDefaults.colors(
                checkedThumbColor = MaterialTheme.colorScheme.onPrimary,
                checkedTrackColor = MaterialTheme.colorScheme.primary,
                checkedBorderColor = MaterialTheme.colorScheme.primary,
                uncheckedThumbColor = MaterialTheme.colorScheme.outline,
                uncheckedTrackColor = MaterialTheme.colorScheme.surfaceVariant,
                uncheckedBorderColor = MaterialTheme.colorScheme.outline
            )
        )
    }
}
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ImprovedTextSetting(
    setting: TextSetting,
    onChanged: () -> Unit,
) {
    var isExpanded by remember { mutableStateOf(false) }
    var text by remember { mutableStateOf(setting.value) }
    var errorMessage by remember { mutableStateOf<String?>(null) }
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 12.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clip(MaterialTheme.shapes.small)
                .clickable { isExpanded = !isExpanded },
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = setting.title,
                    style = MaterialTheme.typography.bodyLarge,
                    color = MaterialTheme.colorScheme.onSurface
                )
                setting.description?.let {
                    Text(
                        text = it,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.8f),
                        modifier = Modifier.padding(top = 2.dp)
                    )
                }
                if (text.isNotBlank() && !isExpanded) {
                    Surface(
                        modifier = Modifier
                            .padding(top = 8.dp)
                            .fillMaxWidth(),
                        shape = MaterialTheme.shapes.small,
                        color = MaterialTheme.colorScheme.surfaceContainerLow,
                    ) {
                        Text(
                            text = text,
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant,
                            modifier = Modifier.padding(8.dp),
                            maxLines = 2,
                            overflow = TextOverflow.Ellipsis
                        )
                    }
                }
            }
            Spacer(modifier = Modifier.width(8.dp))
            IconButton(onClick = { isExpanded = !isExpanded }) {
                Icon(
                    imageVector = Icons.Default.ChevronRight,
                    contentDescription = "Edit setting",
                    tint = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.rotate(if (isExpanded) 90f else 0f)
                )
            }
        }
        AnimatedVisibility(visible = isExpanded) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 8.dp)
            ) {
                OutlinedTextField(
                    value = text,
                    onValueChange = { value ->
                        text = value
                        errorMessage = setting.validator?.invoke(value)
                    },
                    modifier = Modifier.fillMaxWidth(),
                    isError = errorMessage != null,
                    supportingText = {
                        if (errorMessage != null) {
                            Text(
                                text = errorMessage!!,
                                color = MaterialTheme.colorScheme.error
                            )
                        }
                    },
                    keyboardOptions = KeyboardOptions(
                        keyboardType = when (setting.keyboardType) {
                            KeyboardType.Number -> androidx.compose.ui.text.input.KeyboardType.Number
                            KeyboardType.Email -> androidx.compose.ui.text.input.KeyboardType.Email
                            KeyboardType.Password -> androidx.compose.ui.text.input.KeyboardType.Password
                            KeyboardType.Phone -> androidx.compose.ui.text.input.KeyboardType.Phone
                            else -> androidx.compose.ui.text.input.KeyboardType.Text
                        },
                        imeAction = ImeAction.Done
                    ),
                    keyboardActions = KeyboardActions(
                        onDone = {
                            if (errorMessage == null) {
                                setting.onValueChange(text)
                                isExpanded = false
                                onChanged()
                            }
                        }
                    ),
                    singleLine = true,
                    shape = MaterialTheme.shapes.small,
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = MaterialTheme.colorScheme.primary,
                        unfocusedBorderColor = MaterialTheme.colorScheme.outline,
                        focusedContainerColor = MaterialTheme.colorScheme.surfaceContainerHigh,
                        unfocusedContainerColor = MaterialTheme.colorScheme.surfaceContainerLow
                    ),
                    trailingIcon = {
                        IconButton(
                            onClick = {
                                if (errorMessage == null) {
                                    setting.onValueChange(text)
                                    isExpanded = false
                                    onChanged()
                                }
                            },
                            enabled = errorMessage == null
                        ) {
                            Icon(
                                Icons.Default.Check,
                                contentDescription = "Save",
                                tint = if (errorMessage == null)
                                    MaterialTheme.colorScheme.primary
                                else
                                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.38f)
                            )
                        }
                    }
                )
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 8.dp),
                    horizontalArrangement = Arrangement.End
                ) {
                    Button(
                        onClick = {
                            isExpanded = false
                        },
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.surfaceVariant,
                            contentColor = MaterialTheme.colorScheme.onSurfaceVariant
                        ),
                        modifier = Modifier.padding(end = 8.dp)
                    ) {
                        Text("Cancel")
                    }
                    Button(
                        onClick = {
                            if (errorMessage == null) {
                                setting.onValueChange(text)
                                isExpanded = false
                                onChanged()
                            }
                        },
                        enabled = errorMessage == null,
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.primary,
                            contentColor = MaterialTheme.colorScheme.onPrimary,
                            disabledContainerColor = MaterialTheme.colorScheme.surfaceVariant,
                            disabledContentColor = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.38f)
                        )
                    ) {
                        Text("Save")
                    }
                }
            }
        }
    }
}
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ImprovedTextSettingWithButtons(
    setting: TextSettingWithButtons,
    onChanged: () -> Unit,
) {
    var isExpanded by remember { mutableStateOf(false) }
    var text by remember { mutableStateOf(setting.value) }
    var errorMessage by remember { mutableStateOf<String?>(null) }
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 12.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clip(MaterialTheme.shapes.small)
                .clickable { isExpanded = !isExpanded },
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = setting.title,
                    style = MaterialTheme.typography.bodyLarge,
                    color = MaterialTheme.colorScheme.onSurface
                )
                setting.description?.let {
                    Text(
                        text = it,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.8f),
                        modifier = Modifier.padding(top = 2.dp)
                    )
                }
                if (text.isNotBlank() && !isExpanded) {
                    Surface(
                        modifier = Modifier
                            .padding(top = 8.dp)
                            .fillMaxWidth(),
                        shape = MaterialTheme.shapes.small,
                        color = MaterialTheme.colorScheme.surfaceContainerLow,
                    ) {
                        Text(
                            text = text,
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant,
                            modifier = Modifier.padding(8.dp),
                            maxLines = 2,
                            overflow = TextOverflow.Ellipsis
                        )
                    }
                }
            }
            Spacer(modifier = Modifier.width(8.dp))
            IconButton(onClick = { isExpanded = !isExpanded }) {
                Icon(
                    imageVector = Icons.Default.ChevronRight,
                    contentDescription = "Edit setting",
                    tint = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.rotate(if (isExpanded) 90f else 0f)
                )
            }
        }
        AnimatedVisibility(visible = isExpanded) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 8.dp)
            ) {
                OutlinedTextField(
                    value = text,
                    onValueChange = { value ->
                        text = value
                        errorMessage = setting.validator?.invoke(value)
                    },
                    modifier = Modifier.fillMaxWidth(),
                    isError = errorMessage != null,
                    supportingText = {
                        if (errorMessage != null) {
                            Text(
                                text = errorMessage!!,
                                color = MaterialTheme.colorScheme.error
                            )
                        }
                    },
                    keyboardOptions = KeyboardOptions(
                        keyboardType = when (setting.keyboardType) {
                            KeyboardType.Number -> androidx.compose.ui.text.input.KeyboardType.Number
                            KeyboardType.Email -> androidx.compose.ui.text.input.KeyboardType.Email
                            KeyboardType.Password -> androidx.compose.ui.text.input.KeyboardType.Password
                            KeyboardType.Phone -> androidx.compose.ui.text.input.KeyboardType.Phone
                            else -> androidx.compose.ui.text.input.KeyboardType.Text
                        },
                        imeAction = ImeAction.Done
                    ),
                    keyboardActions = KeyboardActions(
                        onDone = {
                            if (errorMessage == null) {
                                setting.onValueChange(text)
                                isExpanded = false
                                onChanged()
                            }
                        }
                    ),
                    singleLine = true,
                    shape = MaterialTheme.shapes.small,
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = MaterialTheme.colorScheme.primary,
                        unfocusedBorderColor = MaterialTheme.colorScheme.outline,
                        focusedContainerColor = MaterialTheme.colorScheme.surfaceContainerHigh,
                        unfocusedContainerColor = MaterialTheme.colorScheme.surfaceContainerLow
                    ),
                    trailingIcon = {
                        IconButton(
                            onClick = {
                                if (errorMessage == null) {
                                    setting.onValueChange(text)
                                    isExpanded = false
                                    onChanged()
                                }
                            },
                            enabled = errorMessage == null
                        ) {
                            Icon(
                                Icons.Default.Check,
                                contentDescription = "Save",
                                tint = if (errorMessage == null)
                                    MaterialTheme.colorScheme.primary
                                else
                                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.38f)
                            )
                        }
                    }
                )
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 8.dp),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    if (setting.buttons.isNotEmpty()) {
                        Row(modifier = Modifier.weight(1f)) {
                            setting.buttons.forEach { buttonAction ->
                                Button(
                                    onClick = {
                                        buttonAction.action()
                                        text = setting.value
                                    },
                                    colors = ButtonDefaults.buttonColors(
                                        containerColor = MaterialTheme.colorScheme.primary,
                                        contentColor = MaterialTheme.colorScheme.onPrimary
                                    ),
                                    modifier = Modifier.padding(end = 8.dp)
                                ) {
                                    Text(buttonAction.name)
                                }
                            }
                        }
                    }
                    Row(
                        horizontalArrangement = Arrangement.End
                    ) {
                        Button(
                            onClick = {
                                isExpanded = false
                            },
                            colors = ButtonDefaults.buttonColors(
                                containerColor = MaterialTheme.colorScheme.surfaceVariant,
                                contentColor = MaterialTheme.colorScheme.onSurfaceVariant
                            ),
                            modifier = Modifier.padding(end = 8.dp)
                        ) {
                            Text("Cancel")
                        }
                        Button(
                            onClick = {
                                if (errorMessage == null) {
                                    setting.onValueChange(text)
                                    isExpanded = false
                                    onChanged()
                                }
                            },
                            enabled = errorMessage == null,
                            colors = ButtonDefaults.buttonColors(
                                containerColor = MaterialTheme.colorScheme.primary,
                                contentColor = MaterialTheme.colorScheme.onPrimary,
                                disabledContainerColor = MaterialTheme.colorScheme.surfaceVariant,
                                disabledContentColor = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.38f)
                            )
                        ) {
                            Text("Save")
                        }
                    }
                }
            }
        }
    }
}
@Composable
fun ImprovedButtonSetting(setting: ButtonSetting) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 14.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = setting.title,
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurface
            )
        }
        Button(
            onClick = setting.onClick,
            colors = ButtonDefaults.buttonColors(
                containerColor = MaterialTheme.colorScheme.primaryContainer,
                contentColor = MaterialTheme.colorScheme.onPrimaryContainer
            ),
            modifier = Modifier.padding(start = 16.dp)
        ) {
            Text("Open")
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\components\BlocksFilter.kt --- 
package com.grindrplus.manager.ui.components
enum class FilterTimeRange {
    ALL_TIME,
    LAST_24H,
    LAST_WEEK,
    LAST_MONTH
}
data class BlockLogFilters(
    val showBlocks: Boolean = true,
    val showUnblocks: Boolean = true,
    val timeRange: FilterTimeRange = FilterTimeRange.ALL_TIME,
    val nameFilter: String = "",
    val packageNameFilter: Set<String> = emptySet(),
    val isActive: Boolean = false
)
@Composable
fun FilterPanel(
    filters: BlockLogFilters,
    availablePackages: List<String>,
    onFiltersChanged: (BlockLogFilters) -> Unit,
    modifier: Modifier = Modifier
) {
    var expanded by remember { mutableStateOf(false) }
    val rotationState by animateFloatAsState(
        targetValue = if (expanded) 180f else 0f
    )
    val activeFiltersCount = remember(filters) {
        var count = 0
        if (!filters.showBlocks || !filters.showUnblocks) count++
        if (filters.timeRange != FilterTimeRange.ALL_TIME) count++
        if (filters.nameFilter.isNotEmpty()) count++
        if (filters.packageNameFilter.isNotEmpty()) count++
        count
    }
    Surface(
        modifier = modifier.fillMaxWidth(),
        color = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    imageVector = Icons.Outlined.FilterAlt,
                    contentDescription = null,
                    tint = MaterialTheme.colorScheme.primary
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = "Filters",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.SemiBold
                )
                if (activeFiltersCount > 0) {
                    Spacer(modifier = Modifier.width(8.dp))
                    Surface(
                        shape = RoundedCornerShape(16.dp),
                        color = MaterialTheme.colorScheme.primary
                    ) {
                        Text(
                            text = activeFiltersCount.toString(),
                            modifier = Modifier.padding(horizontal = 8.dp, vertical = 2.dp),
                            style = MaterialTheme.typography.labelSmall,
                            color = MaterialTheme.colorScheme.onPrimary
                        )
                    }
                }
                Spacer(modifier = Modifier.weight(1f))
                IconButton(onClick = { expanded = !expanded }) {
                    Icon(
                        imageVector = Icons.Default.ExpandMore,
                        contentDescription = if (expanded) "Collapse" else "Expand",
                        modifier = Modifier.rotate(rotationState)
                    )
                }
            }
            AnimatedVisibility(
                visible = expanded,
                enter = expandVertically(),
                exit = shrinkVertically()
            ) {
                Column {
                    Spacer(modifier = Modifier.height(16.dp))
                    Text(
                        text = "Event Type",
                        style = MaterialTheme.typography.labelLarge,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        FilterChip(
                            selected = filters.showBlocks,
                            onClick = {
                                onFiltersChanged(filters.copy(
                                    showBlocks = !filters.showBlocks,
                                    isActive = true
                                ))
                            },
                            label = { Text("Blocks") },
                            leadingIcon = {
                                Icon(
                                    imageVector = Icons.Default.Block,
                                    contentDescription = null,
                                    modifier = Modifier.size(18.dp),
                                    tint = MaterialTheme.colorScheme.error
                                )
                            }
                        )
                        FilterChip(
                            selected = filters.showUnblocks,
                            onClick = {
                                onFiltersChanged(filters.copy(
                                    showUnblocks = !filters.showUnblocks,
                                    isActive = true
                                ))
                            },
                            label = { Text("Unblocks") },
                            leadingIcon = {
                                Icon(
                                    imageVector = Icons.Outlined.RestoreFromTrash,
                                    contentDescription = null,
                                    modifier = Modifier.size(18.dp),
                                    tint = MaterialTheme.colorScheme.primary
                                )
                            }
                        )
                    }
                    if (availablePackages.isNotEmpty()) {
                        Spacer(modifier = Modifier.height(16.dp))
                        Text(
                            text = "App Instance",
                            style = MaterialTheme.typography.labelLarge,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        PackageFilterSelector(
                            availablePackages = availablePackages,
                            selectedPackages = filters.packageNameFilter,
                            onPackageFilterChanged = { selectedPackages ->
                                onFiltersChanged(filters.copy(
                                    packageNameFilter = selectedPackages,
                                    isActive = true
                                ))
                            }
                        )
                    }
                    Spacer(modifier = Modifier.height(16.dp))
                    Text(
                        text = "Time Range",
                        style = MaterialTheme.typography.labelLarge,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    TimeRangeFilter(
                        selectedRange = filters.timeRange,
                        onRangeSelected = { range ->
                            onFiltersChanged(filters.copy(
                                timeRange = range,
                                isActive = true
                            ))
                        }
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    Text(
                        text = "Filter by Name",
                        style = MaterialTheme.typography.labelLarge,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    OutlinedTextField(
                        value = filters.nameFilter,
                        onValueChange = { name ->
                            onFiltersChanged(filters.copy(
                                nameFilter = name,
                                isActive = true
                            ))
                        },
                        modifier = Modifier.fillMaxWidth(),
                        placeholder = { Text("Enter display name") },
                        leadingIcon = {
                            Icon(
                                imageVector = Icons.Outlined.Person,
                                contentDescription = null
                            )
                        },
                        singleLine = true,
                        shape = RoundedCornerShape(8.dp)
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    Button(
                        onClick = {
                            onFiltersChanged(BlockLogFilters())
                        },
                        modifier = Modifier.fillMaxWidth(),
                        shape = RoundedCornerShape(8.dp)
                    ) {
                        Text("Reset Filters")
                    }
                }
            }
        }
    }
}
@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun PackageFilterSelector(
    availablePackages: List<String>,
    selectedPackages: Set<String>,
    onPackageFilterChanged: (Set<String>) -> Unit
) {
    val displayNames = remember(availablePackages) {
        availablePackages.associateWith { packageName ->
            when {
                packageName == "com.grindrapp.android" -> "Original Grindr"
                packageName.startsWith("com.grindrapp.android.") -> {
                    val cloneName = packageName.removePrefix("com.grindrapp.android.")
                    "Clone ${cloneName.replaceFirstChar { it.uppercase() }}"
                }
                else -> packageName.substringAfterLast('.')
            }
        }
    }
    FlowRow(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.spacedBy(8.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        availablePackages.forEach { packageName ->
            FilterChip(
                selected = selectedPackages.contains(packageName),
                onClick = {
                    val newSelectedPackages = selectedPackages.toMutableSet()
                    if (selectedPackages.contains(packageName)) {
                        newSelectedPackages.remove(packageName)
                    } else {
                        newSelectedPackages.add(packageName)
                    }
                    onPackageFilterChanged(newSelectedPackages)
                },
                label = { Text(displayNames[packageName] ?: packageName) },
                leadingIcon = {
                    if (selectedPackages.contains(packageName)) {
                        Icon(
                            imageVector = Icons.Default.Check,
                            contentDescription = null,
                            modifier = Modifier.size(18.dp)
                        )
                    } else {
                        Icon(
                            imageVector = Icons.Outlined.Android,
                            contentDescription = null,
                            modifier = Modifier.size(18.dp)
                        )
                    }
                }
            )
        }
    }
}
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TimeRangeFilter(
    selectedRange: FilterTimeRange,
    onRangeSelected: (FilterTimeRange) -> Unit
) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        FilterChip(
            selected = selectedRange == FilterTimeRange.ALL_TIME,
            onClick = { onRangeSelected(FilterTimeRange.ALL_TIME) },
            label = { Text("All Time") },
            leadingIcon = if (selectedRange == FilterTimeRange.ALL_TIME) {
                { Icon(Icons.Default.Check, contentDescription = null) }
            } else null
        )
        FilterChip(
            selected = selectedRange == FilterTimeRange.LAST_24H,
            onClick = { onRangeSelected(FilterTimeRange.LAST_24H) },
            label = { Text("24h") },
            leadingIcon = if (selectedRange == FilterTimeRange.LAST_24H) {
                { Icon(Icons.Default.Check, contentDescription = null) }
            } else null
        )
        FilterChip(
            selected = selectedRange == FilterTimeRange.LAST_WEEK,
            onClick = { onRangeSelected(FilterTimeRange.LAST_WEEK) },
            label = { Text("Week") },
            leadingIcon = if (selectedRange == FilterTimeRange.LAST_WEEK) {
                { Icon(Icons.Default.Check, contentDescription = null) }
            } else null
        )
        FilterChip(
            selected = selectedRange == FilterTimeRange.LAST_MONTH,
            onClick = { onRangeSelected(FilterTimeRange.LAST_MONTH) },
            label = { Text("Month") },
            leadingIcon = if (selectedRange == FilterTimeRange.LAST_MONTH) {
                { Icon(Icons.Default.Check, contentDescription = null) }
            } else null
        )
    }
}
fun List<BlockEvent>.applyTimeFilter(timeRange: FilterTimeRange): List<BlockEvent> {
    if (timeRange == FilterTimeRange.ALL_TIME) return this
    val currentTime = System.currentTimeMillis()
    val cutoffTime = when (timeRange) {
        FilterTimeRange.LAST_24H -> currentTime - (24 * 60 * 60 * 1000)
        FilterTimeRange.LAST_WEEK -> currentTime - (7 * 24 * 60 * 60 * 1000)
        FilterTimeRange.LAST_MONTH -> currentTime - (30L * 24 * 60 * 60 * 1000)
        else -> 0
    }
    return this.filter { it.timestamp >= cutoffTime }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\components\CloneDialog.kt --- 
package com.grindrplus.manager.ui.components
@Composable
fun CloneDialog(
    context: Context,
    onDismiss: () -> Unit,
    onStartCloning: (packageName: String, appName: String, debuggable: Boolean, embedLSPatch: Boolean) -> Unit
) {
    val hasReachedMaxClones = remember { AppCloneUtils.hasReachedMaxClones(context) }
    val nextCloneNumber = remember { AppCloneUtils.getNextCloneNumber(context) }
    if (hasReachedMaxClones) {
        MaxClonesReachedDialog(
            onDismiss = onDismiss
        )
        return
    }
    var appName by remember { mutableStateOf("Grindr ${numberToWords(nextCloneNumber)}") }
    var debuggable by remember { mutableStateOf(false) }
    var embedLSPatch by remember { mutableStateOf(true) }
    var isError by remember { mutableStateOf(false) }
    var errorText by remember { mutableStateOf("") }
    val packagePrefix = AppCloneUtils.GRINDR_PACKAGE_PREFIX
    var packageSuffix by remember { mutableStateOf(numberToWords(nextCloneNumber).lowercase()) }
    val fullPackageName = "$packagePrefix$packageSuffix"
    val prefixVisualTransformation = VisualTransformation { text ->
        val prefixedText = buildAnnotatedString {
            withStyle(SpanStyle(color = Color.Gray)) {
                append(packagePrefix)
            }
            append(text)
        }
        val offsetMapping = object : OffsetMapping {
            override fun originalToTransformed(offset: Int): Int {
                return offset + packagePrefix.length
            }
            override fun transformedToOriginal(offset: Int): Int {
                return if (offset <= packagePrefix.length) 0 else offset - packagePrefix.length
            }
        }
        TransformedText(prefixedText, offsetMapping)
    }
    Dialog(onDismissRequest = onDismiss) {
        Surface(
            modifier = Modifier
                .fillMaxWidth()
                .wrapContentHeight(),
            shape = MaterialTheme.shapes.medium,
            color = MaterialTheme.colorScheme.surface
        ) {
            Column(
                modifier = Modifier
                    .padding(16.dp)
                    .fillMaxWidth(),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "Clone Grindr",
                    style = MaterialTheme.typography.headlineSmall,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Text(
                    text = "${AppCloneUtils.getExistingClones(context).size}/${AppCloneUtils.MAX_CLONES} clones used",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                Spacer(modifier = Modifier.height(16.dp))
                OutlinedTextField(
                    value = packageSuffix,
                    onValueChange = {
                        packageSuffix = it
                        isError = false
                    },
                    label = { Text("Package Name") },
                    modifier = Modifier.fillMaxWidth(),
                    isError = isError,
                    supportingText = {
                        if (isError) {
                            Text(errorText, color = MaterialTheme.colorScheme.error)
                        } else {
                            Text("Suffix must be unique and have no numbers in it")
                        }
                    },
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Ascii),
                    singleLine = true,
                    visualTransformation = prefixVisualTransformation
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = appName,
                    onValueChange = { appName = it },
                    label = { Text("App Name") },
                    modifier = Modifier.fillMaxWidth(),
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
                    singleLine = true
                )
                Spacer(modifier = Modifier.height(16.dp))
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Text("Debuggable")
                    Switch(
                        checked = debuggable,
                        onCheckedChange = { debuggable = it }
                    )
                }
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Text("Embed LSPatch")
                    Switch(
                        checked = embedLSPatch,
                        onCheckedChange = { embedLSPatch = it }
                    )
                }
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    TextButton(onClick = onDismiss) {
                        Text("Cancel")
                    }
                    Spacer(modifier = Modifier.width(8.dp))
                    Button(
                        onClick = {
                            if (packageSuffix.isBlank()) {
                                isError = true
                                errorText = "Please enter a valid suffix"
                                return@Button
                            }
                            if (AppCloneUtils.getExistingClones(context)
                                    .contains(fullPackageName)
                            ) {
                                isError = true
                                errorText = "This package name already exists"
                                return@Button
                            }
                            if (packageSuffix.any { it.isDigit() }) {
                                isError = true
                                errorText = "Package name must not contain numbers"
                                return@Button
                            }
                            onStartCloning(fullPackageName, appName, debuggable, embedLSPatch)
                        }
                    ) {
                        Text("Clone")
                    }
                }
            }
        }
    }
}
@Composable
fun MaxClonesReachedDialog(
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Maximum Clones Reached") },
        text = {
            Text("GrindrPlus only supports up to 5 clones. Please uninstall an existing clone before creating a new one.")
        },
        confirmButton = {
            Button(
                onClick = onDismiss
            ) {
                Text("OK")
            }
        }
    )
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\components\FileDialog.kt --- 
package com.grindrplus.manager.ui.components
@Composable
fun FileDialog(
    context: Context,
    onDismiss: () -> Unit,
    onSelect: (versionName: String, bundleUri: Uri, modUri: Uri) -> Unit
) {
    var customVersionName by remember { mutableStateOf("custom") }
    var bundleUri by remember { mutableStateOf<Uri?>(null) }
    var modUri by remember { mutableStateOf<Uri?>(null) }
    val bundleFilePicker = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri -> uri?.let { bundleUri = it } }
    val modFilePicker = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri -> uri?.let { modUri = it } }
    Dialog(onDismissRequest = onDismiss) {
        Card(
            shape = RoundedCornerShape(16.dp),
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier.padding(20.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "Custom Installation",
                    style = MaterialTheme.typography.headlineSmall,
                    modifier = Modifier.padding(bottom = 16.dp)
                )
                OutlinedTextField(
                    value = customVersionName,
                    onValueChange = { customVersionName = it },
                    label = { Text("Version Name") },
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(modifier = Modifier.height(16.dp))
                OutlinedButton(
                    onClick = { bundleFilePicker.launch("*/*") },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text(bundleUri?.lastPathSegment ?: "Select Grindr Bundle")
                }
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedButton(
                    onClick = { modFilePicker.launch("*/*") },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text(modUri?.lastPathSegment ?: "Select Mod File")
                }
                Spacer(modifier = Modifier.height(16.dp))
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    TextButton(onClick = onDismiss) {
                        Text("Cancel")
                    }
                    Spacer(modifier = Modifier.width(8.dp))
                    Button(
                        onClick = {
                            if (bundleUri != null && modUri != null) {
                                onSelect(customVersionName, bundleUri!!, modUri!!)
                            }
                        },
                        enabled = bundleUri != null && modUri != null
                    ) {
                        Text("Select Files")
                    }
                }
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\components\MessageBanner.kt --- 
package com.grindrplus.manager.ui.components
enum class BannerType {
    INFO,
    SUCCESS,
    WARNING,
    ERROR
}
@Composable
fun MessageBanner(
    text: String,
    modifier: Modifier = Modifier,
    type: BannerType = BannerType.INFO,
    isVisible: Boolean = true,
    isPulsating: Boolean = false,
    onDismiss: (() -> Unit)? = null
) {
    var bannerVisible by remember { mutableStateOf(isVisible) }
    val (backgroundColor, borderColor, iconTint, icon) = when (type) {
        BannerType.INFO -> Quad(
            Color(0xFF2196F3).copy(alpha = 0.15f),
            Color(0xFF2196F3).copy(alpha = 0.5f),
            Color(0xFF2196F3),
            Icons.Default.Info
        )
        BannerType.SUCCESS -> Quad(
            Color(0xFF4CAF50).copy(alpha = 0.15f),
            Color(0xFF4CAF50).copy(alpha = 0.5f),
            Color(0xFF4CAF50),
            Icons.Default.CheckCircle
        )
        BannerType.WARNING -> Quad(
            Color(0xFFFFC107).copy(alpha = 0.15f),
            Color(0xFFFFC107).copy(alpha = 0.5f),
            Color(0xFFFFC107),
            Icons.Default.Warning
        )
        BannerType.ERROR -> Quad(
            Color(0xFFF44336).copy(alpha = 0.15f),
            Color(0xFFF44336).copy(alpha = 0.5f),
            Color(0xFFF44336),
            Icons.Outlined.Error
        )
    }
    AnimatedVisibility(
        visible = bannerVisible,
        enter = fadeIn(animationSpec = tween(300)),
        exit = fadeOut(animationSpec = tween(300))
    ) {
        val infiniteTransition = rememberInfiniteTransition(label = "pulsating")
        val alpha by infiniteTransition.animateFloat(
            initialValue = 0.8f,
            targetValue = 1f,
            animationSpec = infiniteRepeatable(
                animation = tween(1200, easing = FastOutSlowInEasing),
                repeatMode = RepeatMode.Reverse
            ),
            label = "alpha"
        )
        Surface(
            modifier = modifier
                .fillMaxWidth()
                .padding(bottom = 16.dp)
                .alpha(if (isPulsating && bannerVisible) alpha else 1f)
                .clip(RoundedCornerShape(8.dp))
                .border(
                    width = 1.dp,
                    color = borderColor,
                    shape = RoundedCornerShape(8.dp)
                ),
            color = backgroundColor
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(12.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    imageVector = icon,
                    contentDescription = type.name.lowercase(),
                    tint = iconTint,
                    modifier = Modifier.padding(end = 12.dp)
                )
                Text(
                    text = text,
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Medium,
                    color = MaterialTheme.colorScheme.onSurface,
                    textAlign = TextAlign.Start,
                    modifier = Modifier.weight(1f)
                )
                if (onDismiss != null) {
                    Icon(
                        imageVector = Icons.Default.Close,
                        contentDescription = "Dismiss",
                        tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),
                        modifier = Modifier
                            .padding(start = 8.dp)
                            .clickable {
                                bannerVisible = false
                                onDismiss()
                            }
                    )
                }
            }
        }
    }
}
private data class Quad<A, B, C, D>(val first: A, val second: B, val third: C, val fourth: D) 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\components\PackageSelector.kt --- 
package com.grindrplus.manager.ui.components
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PackageSelector(
    onPackageSelected: (String) -> Unit
) {
    val context = LocalContext.current
    var expanded by remember { mutableStateOf(false) }
    var packages by remember(Config.readRemoteConfig()) {
        mutableStateOf(Config.getAvailablePackages(context))
    }
    LaunchedEffect(Unit) {
        packages = Config.getAvailablePackages(context)
    }
    var selectedPackage by remember {
        mutableStateOf(Config.getCurrentPackage())
    }
    if (packages.size <= 1) {
        return
    }
    fun formatPackageName(packageName: String): String {
        val packageManager = context.packageManager
        return when {
            packageName == Constants.GRINDR_PACKAGE_NAME -> "Main Grindr App"
            packageName.startsWith(AppCloneUtils.GRINDR_PACKAGE_PREFIX) -> {
                try {
                    val appInfo = packageManager.getApplicationInfo(packageName, 0)
                    val appName = packageManager.getApplicationLabel(appInfo).toString()
                    if (appName != packageName && appName.isNotEmpty()) {
                        "Clone: $appName"
                    } else {
                        val suffix = packageName.removePrefix(AppCloneUtils.GRINDR_PACKAGE_PREFIX)
                        "Clone: $suffix"
                    }
                } catch (_: Exception) {
                    val suffix = packageName.removePrefix(AppCloneUtils.GRINDR_PACKAGE_PREFIX)
                    "Clone: $suffix"
                }
            }
            else -> packageName
        }
    }
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(bottom = 16.dp)
    ) {
        Text(
            text = "Select App",
            style = MaterialTheme.typography.labelMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant,
            modifier = Modifier.padding(bottom = 4.dp)
        )
        Surface(
            modifier = Modifier
                .fillMaxWidth()
                .clip(RoundedCornerShape(8.dp))
                .background(MaterialTheme.colorScheme.surfaceContainerHigh),
            onClick = { expanded = true },
            color = MaterialTheme.colorScheme.surfaceContainerHigh
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp, vertical = 12.dp),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = formatPackageName(selectedPackage),
                    style = MaterialTheme.typography.bodyLarge,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Icon(
                    imageVector = Icons.Default.ArrowDropDown,
                    contentDescription = "Select app",
                    tint = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
        DropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false },
            modifier = Modifier
                .fillMaxWidth(0.9f)
                .background(MaterialTheme.colorScheme.surfaceContainerHigh)
        ) {
            packages.forEach { packageName ->
                DropdownMenuItem(
                    text = {
                        Text(
                            text = formatPackageName(packageName),
                            style = MaterialTheme.typography.bodyMedium
                        )
                    },
                    onClick = {
                        selectedPackage = packageName
                        expanded = false
                        Config.setCurrentPackage(packageName)
                        onPackageSelected(packageName)
                    }
                )
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\components\VersionSelector.kt --- 
package com.grindrplus.manager.ui.components
@Composable
fun VersionSelector(
    versions: List<Data>,
    selectedVersion: Data?,
    onVersionSelected: (Data) -> Unit,
    modifier: Modifier = Modifier,
    isEnabled: Boolean = true,
    label: String = "Select a GrindrPlus version",
    customOption: String? = null
) {
    var expanded by remember { mutableStateOf(false) }
    var textFieldSize by remember { mutableStateOf(Size.Zero) }
    val localDensity = LocalDensity.current
    Column(modifier = modifier) {
        Surface(
            modifier = Modifier
                .fillMaxWidth()
                .clickable(
                    enabled = isEnabled,
                    indication = null,
                    interactionSource = remember { MutableInteractionSource() }
                ) {
                    expanded = !expanded
                }
                .onGloballyPositioned { coordinates ->
                    textFieldSize = coordinates.size.toSize()
                },
            shape = MaterialTheme.shapes.small,
            border = BorderStroke(1.dp, MaterialTheme.colorScheme.outline)
        ) {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Column {
                    Text(
                        text = selectedVersion?.modVer ?: label,
                        style = MaterialTheme.typography.bodyLarge,
                        color = if (selectedVersion != null)
                            MaterialTheme.colorScheme.onSurface
                        else
                            MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f),
                        fontWeight = if (selectedVersion != null) FontWeight.Normal else FontWeight.Light,
                        modifier = Modifier.padding(top = 4.dp)
                    )
                }
                Icon(
                    imageVector = Icons.Default.ArrowDropDown,
                    contentDescription = "Dropdown",
                    modifier = Modifier
                        .align(Alignment.CenterEnd)
                        .rotate(if (expanded) 180f else 0f),
                    tint = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
        DropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false },
            modifier = Modifier
                .width(with(localDensity) { textFieldSize.width.toDp() })
        ) {
            if (customOption != null) {
                DropdownMenuItem(
                    text = {
                        Text(
                            customOption,
                            fontStyle = FontStyle.Italic
                        )
                    },
                    onClick = {
                        onVersionSelected(Data("custom", "", ""))
                        expanded = false
                    },
                    leadingIcon = {
                        Icon(
                            imageVector = Icons.Default.Add,
                            contentDescription = "Custom"
                        )
                    }
                )
                HorizontalDivider(
                    modifier = Modifier.padding(vertical = 4.dp)
                )
            }
            if (versions.isEmpty()) {
                DropdownMenuItem(
                    text = {
                        Text(
                            "No versions available",
                            color = MaterialTheme.colorScheme.error
                        )
                    },
                    onClick = { expanded = false }
                )
            } else {
                versions.forEach { version ->
                    if (version.modVer != "custom") {
                        DropdownMenuItem(
                            text = { Text("Version ${version.modVer}") },
                            onClick = {
                                onVersionSelected(version)
                                expanded = false
                            }
                        )
                    }
                }
            }
        }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\theme\Theme.kt --- 
package com.grindrplus.manager.ui.theme
val GrindrYellow = Color(0xFFFFCC00)
val GrindrDarkYellow = Color(0xFFA38300)
private val LightColorScheme = lightColorScheme(
    primary = GrindrYellow,
    onPrimary = Color(0xFF000000),
    primaryContainer = Color(0xFFFFE897),
    onPrimaryContainer = Color(0xFF241A00),
    secondary = GrindrDarkYellow,
    onSecondary = Color(0xFFFFFFFF),
    secondaryContainer = Color(0xFFF2E1BB),
    onSecondaryContainer = Color(0xFF231B04),
    tertiary = Color(0xFF47664A),
    onTertiary = Color(0xFFFFFFFF),
    tertiaryContainer = Color(0xFFC8ECC9),
    onTertiaryContainer = Color(0xFF03210C),
    error = Color(0xFFBA1A1A),
    onError = Color(0xFFFFFFFF),
    errorContainer = Color(0xFFFFDAD6),
    onErrorContainer = Color(0xFF410002),
    background = Color(0xFFFFF8F1),
    onBackground = Color(0xFF1F1B13),
    surface = Color(0xFFFFF8F1),
    onSurface = Color(0xFF1F1B13),
    surfaceVariant = Color(0xFFEBE1CF),
    onSurfaceVariant = Color(0xFF4C4639),
    outline = Color(0xFF7E7667),
    outlineVariant = Color(0xFFCFC6B4),
    scrim = Color(0xFF000000),
    inverseSurface = Color(0xFF343027),
    inverseOnSurface = Color(0xFFF8F0E2),
    inversePrimary = GrindrDarkYellow,
    surfaceDim = Color(0xFFE1D9CC),
    surfaceBright = Color(0xFFFFF8F1),
    surfaceContainerLowest = Color(0xFFFFFFFF),
    surfaceContainerLow = Color(0xFFFBF3E5),
    surfaceContainer = Color(0xFFF5EDDF),
    surfaceContainerHigh = Color(0xFFF0E7D9),
    surfaceContainerHighest = Color(0xFFEAE1D4)
)
private val DarkColorScheme = darkColorScheme(
    primary = GrindrYellow,
    onPrimary = Color(0xFF000000),
    primaryContainer = GrindrDarkYellow,
    onPrimaryContainer = Color(0xFFFFE897),
    secondary = Color(0xFFD5C5A1),
    onSecondary = Color(0xFF50462A),
    secondaryContainer = GrindrDarkYellow,
    onSecondaryContainer = Color(0xFFF2E1BB),
    tertiary = Color(0xFFADCFAE),
    onTertiary = Color(0xFF2F4D34),
    tertiaryContainer = Color(0xFF47664A),
    onTertiaryContainer = Color(0xFFC8ECC9),
    error = Color(0xFFFFB4AB),
    onError = Color(0xFF690005),
    errorContainer = Color(0xFF93000A),
    onErrorContainer = Color(0xFFFFDAD6),
    background = Color(0xFF1F1B13),
    onBackground = Color(0xFFF8F0E2),
    surface = Color(0xFF1F1B13),
    onSurface = Color(0xFFF8F0E2),
    surfaceVariant = Color(0xFF4C4639),
    onSurfaceVariant = Color(0xFFCFC6B4),
    outline = Color(0xFF999080),
    outlineVariant = Color(0xFF4C4639),
    scrim = Color(0xFF000000),
    inverseSurface = Color(0xFFF8F0E2),
    inverseOnSurface = Color(0xFF343027),
    inversePrimary = GrindrYellow,
    surfaceDim = Color(0xFF141009),
    surfaceBright = Color(0xFF3C372B),
    surfaceContainerLowest = Color(0xFF0F0C06),
    surfaceContainerLow = Color(0xFF1A160F),
    surfaceContainer = Color(0xFF1F1B13),
    surfaceContainerHigh = Color(0xFF29251C),
    surfaceContainerHighest = Color(0xFF342F25)
)
@Composable
fun GrindrPlusTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    dynamicColor: Boolean = false,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }
        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }
    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\ui\theme\Typography.kt --- 
package com.grindrplus.manager.ui.theme
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    ),
    bodyMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.25.sp
    ),
    bodySmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 12.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.4.sp
    ),
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.SemiBold,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    titleMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.SemiBold,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.15.sp
    ),
    titleSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.1.sp
    )
)
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\utils\AppCloneUtils.kt --- 
package com.grindrplus.manager.utils
object AppCloneUtils {
    const val MAX_CLONES = 5
    const val GRINDR_PACKAGE_PREFIX = "com.grindrapp.android."
    const val GRINDR_PACKAGE_NAME = "com.grindr"
    /**
     * Check if Grindr is installed on the device
     */
    fun isGrindrInstalled(context: Context): Boolean {
        return try {
            context.packageManager.getPackageInfo(GRINDR_PACKAGE_NAME, 0)
            true
        } catch (e: PackageManager.NameNotFoundException) {
            false
        }
    }
    /**
     * Get existing Grindr clones to determine next suffix number
     */
    fun getExistingClones(context: Context): List<String> {
        val pm = context.packageManager
        val packages = pm.getInstalledPackages(0)
        return packages
            .filter { it.packageName.startsWith(GRINDR_PACKAGE_PREFIX) }
            .map { it.packageName }
    }
    /**
     * Get next available clone number
     * Returns -1 if maximum number of clones is reached
     */
    fun getNextCloneNumber(context: Context): Int {
        val clones = getExistingClones(context)
        if (clones.size >= MAX_CLONES) {
            Timber.e("Maximum number of clones ($MAX_CLONES) reached")
            return -1
        }
        var nextNum = 1
        while (clones.any { it == "$GRINDR_PACKAGE_PREFIX${numberToWords(nextNum).lowercase()}" }) {
            nextNum++
        }
        return nextNum
    }
    /**
     * Check if maximum number of clones is reached
     */
    fun hasReachedMaxClones(context: Context): Boolean {
        return getExistingClones(context).size >= MAX_CLONES
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\utils\AppIconManager.kt --- 
package com.grindrplus.manager.utils
class AppIconManager(private val context: Context) {
    companion object {
        const val DEFAULT_ICON = "default"
        const val DISCREET_ICON = "disguised"
    }
    fun changeAppIcon(iconType: String): Boolean {
        return try {
            val packageManager = context.packageManager
            val componentName = when (iconType) {
                DEFAULT_ICON -> ComponentName(context, "com.grindrplus.manager.MainActivity")
                DISCREET_ICON -> ComponentName(context, "com.grindrplus.manager.MainActivityAlias")
                else -> return false
            }
            disableAllAliases()
            packageManager.setComponentEnabledSetting(
                componentName,
                PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
                PackageManager.DONT_KILL_APP
            )
            true
        } catch (e: Exception) {
            Timber.e(e, "Failed to change app icon")
            false
        }
    }
    private fun disableAllAliases() {
        val packageManager = context.packageManager
        val aliasesToDisable = listOf(
            ComponentName(context, "com.grindrplus.manager.MainActivity"),
            ComponentName(context, "com.grindrplus.manager.MainActivityAlias")
        )
        for (alias in aliasesToDisable) {
            packageManager.setComponentEnabledSetting(
                alias,
                PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                PackageManager.DONT_KILL_APP
            )
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\utils\Download.kt --- 
package com.grindrplus.manager.utils
data class DownloadResult(val success: Boolean, val reason: String?) {
    companion object {
        fun success() = DownloadResult(true, null)
        fun failure(reason: String) = DownloadResult(false, reason)
    }
}
@Suppress("ObjectPropertyName")
private var _fetch: Fetch? = null
private val fetch: Fetch get() = _fetch!!
/**
 * Downloads a file using Fetch2 library
 * with proper error handling and progress monitoring
 *
 * @param context Android context
 * @param out Destination file
 * @param url URL to download from
 * @param print Callback to report download progress
 * @return True if download succeeded, false otherwise
 */
suspend fun download(
    context: Context,
    out: File,
    url: String,
    printConsole: (String) -> Unit,
): DownloadResult = withContext(Dispatchers.IO) {
    try {
        out.parentFile?.mkdirs()
        var lastUpdateTime = System.currentTimeMillis()
        var lastBytesDownloaded = 0L
        var averageSpeed = 0.0
        if (_fetch == null || _fetch?.isClosed == true) {
            _fetch = Fetch.Impl.getInstance(
                FetchConfiguration.Builder(context)
                    .setDownloadConcurrentLimit(10)
                    .setAutoRetryMaxAttempts(3)
                    .enableLogging(true)
                    .enableAutoStart(true)
                    .enableRetryOnNetworkGain(true)
                    .setHttpDownloader(
                        OkHttpDownloader(
                            getCustomTrustedOkHttpClient(context),
                            Downloader.FileDownloaderType.PARALLEL
                        )
                    )
                    .setNotificationManager(
                        object : DefaultFetchNotificationManager(context) {
                            override fun getFetchInstanceForNamespace(namespace: String) = fetch
                        }
                    )
                    .build()
            )
        }
        val request = Request(url, out.absolutePath).apply {
            priority = Priority.HIGH
            networkType = NetworkType.ALL
        }
        return@withContext suspendCoroutine { continuation ->
            fetch.addListener(object : FetchListener {
                override fun onStarted(
                    download: Download,
                    downloadBlocks: List<DownloadBlock>,
                    totalBlocks: Int,
                ) {
                    printConsole("Starting download...")
                }
                @SuppressLint("DefaultLocale")
                override fun onProgress(
                    download: Download,
                    etaInMilliSeconds: Long,
                    downloadedBytesPerSecond: Long,
                ) {
                    val currentTime = System.currentTimeMillis()
                    val timeDelta = currentTime - lastUpdateTime
                    if (timeDelta > 0) {
                        val bytesDelta = download.downloaded - lastBytesDownloaded
                        val currentSpeed = bytesDelta.toDouble() / timeDelta / 1024 / 1024
                        averageSpeed = if (averageSpeed == 0.0) currentSpeed
                        else (averageSpeed * 0.7 + currentSpeed * 0.3)
                        val percentage = download.progress
                        val speedText = when {
                            averageSpeed >= 1.0 -> String.format("%.2f Mb/s", averageSpeed * 8)
                            averageSpeed >= 0.001 -> String.format(
                                "%.2f Kb/s",
                                averageSpeed * 1024 * 8
                            )
                            else -> String.format("%.2f b/s", averageSpeed * 1024 * 1024 * 8)
                        }
                        printConsole(
                            "Download status<>: " +
                                    "$percentage% $speedText " +
                                    "(ETA:${etaInMilliSeconds.div(60000)}m${
                                        (etaInMilliSeconds.rem(
                                            60000
                                        )).div(1000)
                                    }s)<progressBar:${(percentage / 100f).coerceIn(0f, 1f)}:>"
                        )
                        lastUpdateTime = currentTime
                        lastBytesDownloaded = download.downloaded
                    }
                }
                override fun onError(download: Download, error: Error, throwable: Throwable?) {
                    fetch.removeListener(this)
                    fetch.close()
                    if (out.exists()) out.delete()
                    continuation.resume(DownloadResult.failure(error.name))
                }
                override fun onCompleted(download: Download) {
                    fetch.removeListener(this)
                    printConsole("Completed download")
                    if (validateFile(out)) {
                        continuation.resume(DownloadResult.success())
                    } else {
                        if (out.exists()) out.delete()
                        continuation.resume(DownloadResult.failure("Downloaded file validation failed"))
                    }
                }
                override fun onCancelled(download: Download) {
                    fetch.removeListener(this)
                    if (out.exists()) out.delete()
                    continuation.resume(DownloadResult.failure("Download cancelled"))
                }
                override fun onPaused(download: Download) {
                    printConsole("Paused.")
                }
                override fun onQueued(download: Download, waitingOnNetwork: Boolean) {}
                override fun onRemoved(download: Download) {}
                override fun onDeleted(download: Download) {}
                override fun onResumed(download: Download) {}
                override fun onWaitingNetwork(download: Download) {}
                override fun onAdded(download: Download) {}
                override fun onDownloadBlockUpdated(
                    download: Download,
                    downloadBlock: DownloadBlock,
                    totalBlocks: Int,
                ) {
                }
            })
            try {
                fetch.removeAll()
                fetch.enqueue(request)
            } catch (e: Exception) {
                if (out.exists()) out.delete()
                continuation.resume(DownloadResult.failure(e.message ?: "Unknown error"))
            }
        }
    } catch (e: CancellationException) {
        if (out.exists()) out.delete()
        throw e
    } catch (e: Exception) {
        if (out.exists()) out.delete()
        return@withContext DownloadResult.failure(e.message ?: "Unknown error")
    }
}
fun getCustomTrustedOkHttpClient(context: Context): OkHttpClient {
    // Load the default trust manager
    val defaultTrustManager =
        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()).apply {
            init(null as KeyStore?)
        }.trustManagers[0] as X509TrustManager
    // Load custom certificate
    val certificateFactory = CertificateFactory.getInstance("X.509")
    val customCertificate = context.resources.openRawResource(R.raw.cert)
        .use { certificateFactory.generateCertificate(it) }
    // Create keystore with custom certificate
    val keyStore = KeyStore.getInstance(KeyStore.getDefaultType()).apply {
        load(null, null)
        setCertificateEntry("custom", customCertificate)
    }
    // Create custom trust manager
    val customTrustManager =
        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()).apply {
            init(keyStore)
        }.trustManagers[0] as X509TrustManager
    // Combine both trust managers
    val combinedTrustManager = @SuppressLint("CustomX509TrustManager")
    object : X509TrustManager {
        override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) {
            try {
                defaultTrustManager.checkClientTrusted(chain, authType)
            } catch (_: Exception) {
                customTrustManager.checkClientTrusted(chain, authType)
            }
        }
        override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {
            try {
                defaultTrustManager.checkServerTrusted(chain, authType)
            } catch (_: Exception) {
                customTrustManager.checkServerTrusted(chain, authType)
            }
        }
        override fun getAcceptedIssuers(): Array<X509Certificate> =
            defaultTrustManager.acceptedIssuers + customTrustManager.acceptedIssuers
    }
    val sslContext = SSLContext.getInstance("TLS").apply {
        init(null, arrayOf(combinedTrustManager), SecureRandom())
    }
    return OkHttpClient.Builder()
        .sslSocketFactory(sslContext.socketFactory, combinedTrustManager)
        .hostnameVerifier { _, _ -> true }
        .build()
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\utils\ErrorHandling.kt --- 
package com.grindrplus.manager.utils
// TODO: Sync with module once everything's connected
object ErrorHandler {
    private const val TAG = "ErrorHandler"
    private const val LOG_FILE_PREFIX = "grindrplus_log_"
    fun logError(context: Context, tag: String, message: String, error: Throwable?) {
        Timber.tag(tag).e(error, message)
        CoroutineScope(Dispatchers.IO).launch {
            try {
                val logDir = File(context.getExternalFilesDir(null), "logs")
                if (!logDir.exists()) {
                    logDir.mkdirs()
                }
                cleanupOldLogs(logDir, 5)
                val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(Date())
                val logFile = File(logDir, "$LOG_FILE_PREFIX${timestamp}.txt")
                FileOutputStream(logFile, true).use { output ->
                    val writer = PrintWriter(output)
                    writer.println("---- ERROR LOG $timestamp ----")
                    writer.println("Device: ${Build.MANUFACTURER} ${Build.MODEL}")
                    writer.println("Android: ${Build.VERSION.RELEASE} (SDK ${Build.VERSION.SDK_INT})")
                    writer.println("Message: $message")
                    if (error != null) {
                        writer.println("Exception: ${error.javaClass.name}: ${error.message}")
                        val sw = StringWriter()
                        val pw = PrintWriter(sw)
                        error.printStackTrace(pw)
                        writer.println(sw.toString())
                    }
                    writer.println("----------------------")
                    writer.println()
                    writer.flush()
                }
            } catch (e: Exception) {
                Timber.tag(TAG).e(e, "Failed to write to error log")
            }
        }
    }
    fun showToast(context: Context, message: String, length: Int = Toast.LENGTH_SHORT) {
        CoroutineScope(Dispatchers.Main).launch {
            Toast.makeText(context, message, length).show()
        }
    }
    @Suppress("SameParameterValue")
    private fun cleanupOldLogs(logDir: File, keepCount: Int) {
        try {
            val logFiles = logDir.listFiles { file ->
                file.isFile && file.name.startsWith(LOG_FILE_PREFIX)
            }
            if (logFiles != null && logFiles.size > keepCount) {
                val sortedFiles = logFiles.sortedBy { it.lastModified() }
                for (i in 0 until sortedFiles.size - keepCount) {
                    sortedFiles[i].delete()
                }
            }
        } catch (e: Exception) {
            Timber.tag(TAG).e(e, "Failed to cleanup old logs")
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\utils\FileOperationHandler.kt --- 
package com.grindrplus.manager.utils
object FileOperationHandler {
    lateinit var activity: ComponentActivity
    private lateinit var importFileLauncher: ActivityResultLauncher<Array<String>>
    private lateinit var exportFileLauncher: ActivityResultLauncher<String>
    private lateinit var exportZipLauncher: ActivityResultLauncher<String>
    fun init(activity: ComponentActivity) {
        this.activity = activity
        this.importFileLauncher =
            FileOperationHandler.activity.registerForActivityResult(
                ActivityResultContracts.OpenDocument()
            ) { uri ->
                uri?.let { readFromFile(it) }
            }
        this.exportFileLauncher =
            FileOperationHandler.activity.registerForActivityResult(
                ActivityResultContracts.CreateDocument("application/json")
            ) { uri ->
                uri?.let { writeToFile(it) }
            }
        this.exportZipLauncher =
            FileOperationHandler.activity.registerForActivityResult(
                ActivityResultContracts.CreateDocument("application/zip")
            ) { uri ->
                uri?.let { writeZipToFile(it) }
            }
    }
    private var pendingExportContent: String? = null
    private var pendingExportZipFile: File? = null
    private var onImportComplete: ((String) -> Unit)? = null
    fun exportFile(filename: String, content: String) {
        pendingExportContent = content
        exportFileLauncher.launch(filename)
    }
    fun exportZipFile(filename: String, zipFile: File) {
        pendingExportZipFile = zipFile
        exportZipLauncher.launch(filename)
    }
    fun importFile(mimeTypes: Array<String>, onComplete: (String) -> Unit) {
        onImportComplete = onComplete
        importFileLauncher.launch(mimeTypes)
    }
    private fun writeToFile(uri: android.net.Uri) {
        try {
            val content = pendingExportContent ?: return
            activity.contentResolver.openOutputStream(uri)?.use { outputStream ->
                outputStream.write(content.toByteArray())
            }
        } catch (e: Exception) {
            Logger.apply {
                e("Failed to write file: ${e.message}")
                writeRaw(e.stackTraceToString())
            }
        } finally {
            pendingExportContent = null
        }
    }
    private fun writeZipToFile(uri: android.net.Uri) {
        try {
            val zipFile = pendingExportZipFile ?: return
            activity.contentResolver.openOutputStream(uri)?.use { outputStream ->
                zipFile.inputStream().use { input ->
                    input.copyTo(outputStream)
                }
            }
            zipFile.delete()
        } catch (e: Exception) {
            Logger.apply {
                e("Failed to write zip file: ${e.message}")
                writeRaw(e.stackTraceToString())
            }
        } finally {
            pendingExportZipFile = null
        }
    }
    private fun readFromFile(uri: android.net.Uri) {
        try {
            activity.contentResolver.openInputStream(uri)?.use { inputStream ->
                val content = inputStream.bufferedReader().use { it.readText() }
                onImportComplete?.invoke(content)
            }
        } catch (e: Exception) {
            Logger.apply {
                e("Failed to read file: ${e.message}")
                writeRaw(e.stackTraceToString())
            }
        }
    }
    suspend fun createLogsZip(context: Context): File? = withContext(Dispatchers.IO) {
        try {
            val tempDir = File(context.cacheDir, "log_export")
            tempDir.mkdirs()
            val zipFile = File(context.cacheDir, "grindrplus_logs.zip")
            if (zipFile.exists()) zipFile.delete()
            val deviceInfoFile = File(tempDir, "device_info.json")
            val mainJson = JSONObject()
            val deviceSection = JSONObject().apply {
                put("manufacturer", Build.MANUFACTURER)
                put("model", Build.MODEL)
                put("device", Build.DEVICE)
                put("brand", Build.BRAND)
                put("hardware", Build.HARDWARE)
                put("fingerprint", Build.FINGERPRINT)
            }
            mainJson.put("device", deviceSection)
            val androidSection = JSONObject().apply {
                put("version", Build.VERSION.RELEASE)
                put("sdk_level", Build.VERSION.SDK_INT)
                put("security_patch", Build.VERSION.SECURITY_PATCH)
                put("is_rooted", RootBeer(context).isRooted)
            }
            mainJson.put("android", androidSection)
            val appsSection = JSONObject().apply {
                val grindrPlusPackageInfo = context.packageManager.getPackageInfo(context.packageName, 0)
                val grindrPackageInfo = context.packageManager.getPackageInfo(GRINDR_PACKAGE_NAME, 0)
                val grindrPlusVersionCode = if (Build.VERSION.SDK_INT >= 28) {
                    grindrPlusPackageInfo.longVersionCode
                } else {
                    @Suppress("DEPRECATION")
                    grindrPlusPackageInfo.versionCode.toLong()
                }
                val grindrVersionCode = if (Build.VERSION.SDK_INT >= 28) {
                    grindrPackageInfo.longVersionCode
                } else {
                    @Suppress("DEPRECATION")
                    grindrPackageInfo.versionCode.toLong()
                }
                put("grindrplus_version", "${grindrPlusPackageInfo.versionName} (${grindrPlusVersionCode})")
                put("grindr_version", "${grindrPackageInfo.versionName} (${grindrVersionCode})")
                put("clones", AppCloneUtils.getExistingClones(context).size)
            }
            mainJson.put("apps", appsSection)
            val systemSection = JSONObject().apply {
                put("timestamp", System.currentTimeMillis())
                put("locale", java.util.Locale.getDefault().toString())
                put("timezone", java.util.TimeZone.getDefault().id)
                val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as android.app.ActivityManager
                val memoryInfo = android.app.ActivityManager.MemoryInfo()
                activityManager.getMemoryInfo(memoryInfo)
                put("total_memory_mb", memoryInfo.totalMem / (1024 * 1024))
                put("available_memory_mb", memoryInfo.availMem / (1024 * 1024))
            }
            mainJson.put("system", systemSection)
            deviceInfoFile.writeText(mainJson.toString(4))
            val logFiles = mutableListOf<File>()
            val mainLogFile = File(context.getExternalFilesDir(null), "grindrplus.log")
            if (mainLogFile.exists()) {
                val logCopy = File(tempDir, "grindrplus.log")
                mainLogFile.copyTo(logCopy, overwrite = true)
                logFiles.add(logCopy)
            }
            val backupLogFile = File("${mainLogFile.absolutePath}.bak")
            if (backupLogFile.exists()) {
                val backupCopy = File(tempDir, "grindrplus.log.bak")
                backupLogFile.copyTo(backupCopy, overwrite = true)
                logFiles.add(backupCopy)
            }
            logFiles.add(deviceInfoFile)
            ZipOutputStream(FileOutputStream(zipFile)).use { zipOut ->
                logFiles.forEach { file ->
                    val entry = ZipEntry(file.name)
                    zipOut.putNextEntry(entry)
                    file.inputStream().use { input ->
                        input.copyTo(zipOut)
                    }
                    zipOut.closeEntry()
                }
            }
            tempDir.deleteRecursively()
            return@withContext zipFile
        } catch (e: Exception) {
            Logger.apply {
                e("Failed to create logs zip: ${e.message}")
                writeRaw(e.stackTraceToString())
            }
            return@withContext null
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\utils\FileUtils.kt --- 
package com.grindrplus.manager.utils
/**
 * Validates that a downloaded file is complete and not corrupted
 */
fun validateFile(file: File): Boolean {
    if (!file.exists() || file.length() <= 0) {
        return false
    }
    if (file.name.endsWith(".zip") || file.name.endsWith(".xapk")) {
        try {
            ZipFile(file).close()
            return true
        } catch (e: Exception) {
            Timber.tag("Download").e("Invalid ZIP file: ${e.localizedMessage}")
            file.delete()
            return false
        }
    }
    return true
}
/**
 * Unzips a file to the specified directory with proper error handling
 *
 * @param unzipLocationRoot The target directory (or null to use same directory)
 * @throws IOException If extraction fails
 */
fun File.unzip(unzipLocationRoot: File? = null) {
    if (!exists() || length() <= 0) {
        throw IOException("ZIP file doesn't exist or is empty: $absolutePath")
    }
    val rootFolder =
        unzipLocationRoot ?: File(parentFile!!.absolutePath + File.separator + nameWithoutExtension)
    if (!rootFolder.exists()) {
        if (!rootFolder.mkdirs()) {
            throw IOException("Failed to create output directory: ${rootFolder.absolutePath}")
        }
    }
    try {
        ZipFile(this).use { zip ->
            val entries = zip.entries().asSequence().toList()
            if (entries.isEmpty()) {
                throw IOException("ZIP file is empty: $absolutePath")
            }
            for (entry in entries) {
                val outputFile = File(rootFolder.absolutePath + File.separator + entry.name)
                // cute zip slip vulnerability
                if (!outputFile.canonicalPath.startsWith(rootFolder.canonicalPath + File.separator)) {
                    throw SecurityException("ZIP entry is outside of target directory: ${entry.name}")
                }
                if (entry.isDirectory) {
                    if (!outputFile.exists() && !outputFile.mkdirs()) {
                        throw IOException("Failed to create directory: ${outputFile.absolutePath}")
                    }
                } else {
                    outputFile.parentFile?.let {
                        if (!it.exists() && !it.mkdirs()) {
                            throw IOException("Failed to create parent directory: ${it.absolutePath}")
                        }
                    }
                    zip.getInputStream(entry).use { input ->
                        outputFile.outputStream().use { output ->
                            input.copyTo(output)
                        }
                    }
                }
            }
        }
    } catch (e: Exception) {
        if (unzipLocationRoot != null && unzipLocationRoot.exists()) {
            unzipLocationRoot.deleteRecursively()
        }
        when (e) {
            is SecurityException -> throw e
            else -> throw IOException("Failed to extract ZIP file: ${e.localizedMessage}", e)
        }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\utils\KeyStoreUtils.kt --- 
package com.grindrplus.manager.utils
class KeyStoreUtils(context: Context) {
    val keyStore by lazy {
        File(context.cacheDir, "keystore.jks").also {
            if (!it.exists()) {
                try {
                    newKeystore(it)
                } catch (e: Exception) {
                    Toast.makeText(context, "Failed to create keystore: ${e.localizedMessage}", Toast.LENGTH_SHORT).show()
                    throw e
                }
            }
        }
    }
    private val signerConfig: ApkSigner.SignerConfig by lazy {
        val keyStore = KeyStore.getInstance(KeyStore.getDefaultType())
        this.keyStore.inputStream().use { stream ->
            keyStore.load(stream, null)
        }
        val alias = keyStore.aliases().nextElement()
        val certificate = keyStore.getCertificate(alias) as X509Certificate
        ApkSigner.SignerConfig.Builder(
            "GrindrPlus",
            keyStore.getKey(alias, "password".toCharArray()) as PrivateKey,
            listOf(certificate)
        ).build()
    }
    /**
     * Creates a new keystore file with a self-signed certificate for APK signing
     *
     * @param out The output keystore file
     * @throws Exception If keystore creation fails
     */
    @SuppressLint("NewApi")
    fun newKeystore(out: File) {
        try {
            val key = createKey()
            KeyStore.getInstance(KeyStore.getDefaultType()).apply {
                load(null, "password".toCharArray())
                setKeyEntry(
                    "alias",
                    key.privateKey,
                    "password".toCharArray(),
                    arrayOf<Certificate>(key.publicKey)
                )
                store(out.outputStream(), "password".toCharArray())
            }
        } catch (e: Exception) {
            if (out.exists()) out.delete()
            throw IOException("Failed to create keystore: ${e.localizedMessage}", e)
        }
    }
    /**
     * Creates a key pair for signing APKs
     */
    private fun createKey(): KeySet {
        try {
            var serialNumber: BigInteger
            do serialNumber = SecureRandom().nextInt().toBigInteger()
            while (serialNumber < BigInteger.ZERO)
            val x500Name = X500Name("CN=GrindrPlus")
            val pair = KeyPairGenerator.getInstance("RSA").run {
                initialize(2048)
                generateKeyPair()
            }
            // Valid for 30 years
            val notBefore = Date(System.currentTimeMillis() - 1000L * 60L * 60L * 24L * 30L)
            val notAfter = Date(System.currentTimeMillis() + 1000L * 60L * 60L * 24L * 366L * 30L)
            val builder = X509v3CertificateBuilder(
                x500Name,
                serialNumber,
                notBefore,
                notAfter,
                Locale.ENGLISH,
                x500Name,
                SubjectPublicKeyInfo.getInstance(pair.public.encoded)
            )
            val signer = JcaContentSignerBuilder("SHA256withRSA").build(pair.private)
            return KeySet(
                JcaX509CertificateConverter().getCertificate(builder.build(signer)),
                pair.private
            )
        } catch (e: Exception) {
            throw IOException("Failed to create signing key: ${e.localizedMessage}", e)
        }
    }
    fun signApk(apkFile: File, output: File) {
        ApkSigner.Builder(listOf(signerConfig))
            .setV1SigningEnabled(false) // TODO: enable so api <24 devices can work, however zip-alignment breaks
            .setV2SigningEnabled(true)
            .setV3SigningEnabled(true)
            .setInputApk(apkFile)
            .setOutputApk(output)
            .build()
            .sign()
    }
}
/**
 * Data class to hold a key pair for APK signing
 */
class KeySet(val publicKey: X509Certificate, val privateKey: PrivateKey) 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\utils\ManifestPatcher.kt --- 
package com.grindrplus.manager.utils
// Taken by https://github.com/revenge-mod/revenge-manager/blob/main/app/src/main/java/app/revenge/manager/installer/util/ManifestPatcher.kt
object ManifestPatcher {
    private const val ANDROID_NAMESPACE = "http://schemas.android.com/apk/res/android"
    private const val USES_CLEARTEXT_TRAFFIC = "usesCleartextTraffic"
    private const val DEBUGGABLE = "debuggable"
    private const val REQUEST_LEGACY_EXTERNAL_STORAGE = "requestLegacyExternalStorage"
    private const val LABEL = "label"
    private const val PACKAGE = "package"
    private const val COMPILE_SDK_VERSION = "compileSdkVersion"
    private const val COMPILE_SDK_VERSION_CODENAME = "compileSdkVersionCodename"
    private const val DRNE_PERMISSION = "DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION"
    private const val GRINDR_DRNE_PERMISSION = "$GRINDR_PACKAGE_NAME.$DRNE_PERMISSION"
    fun patchManifest(
        manifestBytes: ByteArray,
        packageName: String,
        appName: String,
        debuggable: Boolean,
    ): ByteArray {
        val reader = AxmlReader(manifestBytes)
        val writer = AxmlWriter()
        reader.accept(object : AxmlVisitor(writer) {
            override fun child(ns: String?, name: String?) =
                object : ReplaceAttrsVisitor(
                    super.child(ns, name),
                    mapOf(
                        PACKAGE to packageName,
                        COMPILE_SDK_VERSION to 23,
                        COMPILE_SDK_VERSION_CODENAME to "6.0-2438415"
                    )
                ) {
                    private var addExternalStoragePerm = false
                    override fun child(ns: String?, name: String): NodeVisitor {
                        val nv = super.child(ns, name)
                        // Add MANAGE_EXTERNAL_STORAGE when necessary
                        if (addExternalStoragePerm) {
                            super
                                .child(null, "uses-permission")
                                .attr(
                                    ANDROID_NAMESPACE,
                                    "name",
                                    android.R.attr.name,
                                    TYPE_STRING,
                                    Manifest.permission.MANAGE_EXTERNAL_STORAGE
                                )
                            addExternalStoragePerm = false
                        }
                        return when (name) {
                            "permission" -> object : NodeVisitor(nv) {
                                override fun attr(
                                    ns: String?,
                                    name: String?,
                                    resourceId: Int,
                                    type: Int,
                                    value: Any?,
                                ) {
                                    if (name == "name" && value == GRINDR_DRNE_PERMISSION) {
                                        super.attr(
                                            ns,
                                            name,
                                            resourceId,
                                            type,
                                            "$packageName.$DRNE_PERMISSION"
                                        )
                                    } else if (name == "name" && value == GRINDR_PACKAGE_NAME) {
                                        super.attr(
                                            ns,
                                            name,
                                            resourceId,
                                            type,
                                            packageName
                                        )
                                    } else {
                                        super.attr(ns, name, resourceId, type, value)
                                    }
                                }
                            }
                            "uses-permission" -> object : NodeVisitor(nv) {
                                override fun attr(
                                    ns: String?,
                                    name: String?,
                                    resourceId: Int,
                                    type: Int,
                                    value: Any?,
                                ) {
                                    if (name == "name" && value == GRINDR_DRNE_PERMISSION) {
                                        super.attr(
                                            ns,
                                            name,
                                            resourceId,
                                            type,
                                            "$packageName.$DRNE_PERMISSION"
                                        )
                                    }
                                    if (name == "name" && value == GRINDR_PACKAGE_NAME) {
                                        super.attr(
                                            ns,
                                            name,
                                            resourceId,
                                            type,
                                            packageName
                                        )
                                    }
                                    if (name != "maxSdkVersion") {
                                        super.attr(ns, name, resourceId, type, value)
                                    }
                                    // Set the add external storage permission to be added after WRITE_EXTERNAL_STORAGE (which is after read)
                                    if (name == "name" && value == Manifest.permission.READ_EXTERNAL_STORAGE) {
                                        addExternalStoragePerm = true
                                    }
                                }
                            }
                            "application" -> object : ReplaceAttrsVisitor(
                                nv,
                                mapOf(
                                    LABEL to appName,
                                    DEBUGGABLE to debuggable,
                                    USES_CLEARTEXT_TRAFFIC to true,
                                    REQUEST_LEGACY_EXTERNAL_STORAGE to true
                                )
                            ) {
                                private var addDebuggable = debuggable
                                private var addLegacyStorage = true
                                private var addUseClearTextTraffic = true
                                override fun attr(
                                    ns: String?,
                                    name: String,
                                    resourceId: Int,
                                    type: Int,
                                    value: Any?,
                                ) {
                                    super.attr(ns, name, resourceId, type, value)
                                    if (name == REQUEST_LEGACY_EXTERNAL_STORAGE) addLegacyStorage =
                                        false
                                    if (name == DEBUGGABLE) addDebuggable = false
                                    if (name == USES_CLEARTEXT_TRAFFIC) addUseClearTextTraffic =
                                        false
                                }
                                override fun child(ns: String?, name: String): NodeVisitor {
                                    val visitor = super.child(ns, name)
                                    return when (name) {
                                        "activity-alias" -> object : NodeVisitor(visitor) {
                                            override fun attr(
                                                ns: String?,
                                                name: String?,
                                                resourceId: Int,
                                                type: Int,
                                                value: Any?,
                                            ) {
                                                if (name == "label") {
                                                    super.attr(ns, name, resourceId, TYPE_STRING, appName)
                                                } else {
                                                    super.attr(ns, name, resourceId, type, value)
                                                }
                                            }
                                        }
                                        "provider" -> object : NodeVisitor(visitor) {
                                            override fun attr(
                                                ns: String?,
                                                name: String,
                                                resourceId: Int,
                                                type: Int,
                                                value: Any?,
                                            ) {
                                                super.attr(
                                                    ns,
                                                    name,
                                                    resourceId,
                                                    type,
                                                    if (name == "authorities") {
                                                        (value as String).replace(
                                                            GRINDR_PACKAGE_NAME,
                                                            packageName
                                                        )
                                                    } else {
                                                        value
                                                    }
                                                )
                                            }
                                        }
                                        else -> visitor
                                    }
                                }
                                override fun end() {
                                    if (addLegacyStorage) super.attr(
                                        ANDROID_NAMESPACE,
                                        REQUEST_LEGACY_EXTERNAL_STORAGE,
                                        -1,
                                        TYPE_INT_BOOLEAN,
                                        1
                                    )
                                    if (addDebuggable) super.attr(
                                        ANDROID_NAMESPACE,
                                        DEBUGGABLE,
                                        -1,
                                        TYPE_INT_BOOLEAN,
                                        1
                                    )
                                    if (addUseClearTextTraffic) super.attr(
                                        ANDROID_NAMESPACE,
                                        USES_CLEARTEXT_TRAFFIC,
                                        -1,
                                        TYPE_INT_BOOLEAN,
                                        1
                                    )
                                    super.end()
                                }
                            }
                            else -> nv
                        }
                    }
                }
        })
        return writer.toByteArray()
    }
    fun renamePackage(
        manifestBytes: ByteArray,
        packageName: String,
    ): ByteArray {
        val reader = AxmlReader(manifestBytes)
        val writer = AxmlWriter()
        reader.accept(
            object : AxmlVisitor(writer) {
                override fun child(ns: String?, name: String?): NodeVisitor {
                    val nv = super.child(ns, name)
                    if (name == "manifest") {
                        return ReplaceAttrsVisitor(nv, mapOf("package" to packageName))
                    }
                    return nv
                }
            }
        )
        return writer.toByteArray()
    }
    private open class ReplaceAttrsVisitor(
        nv: NodeVisitor,
        private val attrs: Map<String, Any>,
    ) : NodeVisitor(nv) {
        override fun attr(ns: String?, name: String, resourceId: Int, type: Int, value: Any?) {
            val replace = attrs.containsKey(name)
            val newValue = attrs[name]
            super.attr(
                ns,
                name,
                resourceId,
                if (newValue is String) TYPE_STRING else type,
                if (replace) newValue else value
            )
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\utils\MiscUtils.kt --- 
package com.grindrplus.manager.utils
suspend fun uploadAndShare(text: String, context: Context) {
    val response = withContext(Dispatchers.IO) {
        Socket("termbin.com", 9999).use { socket ->
            socket.getOutputStream().write(text.toByteArray())
            socket.getInputStream().bufferedReader().readText()
        }.trim().replace("\n", "")
    }
    val sendIntent = Intent().apply {
        action = Intent.ACTION_SEND
        type = "text/plain"
        putExtra(Intent.EXTRA_TEXT, response)
    }
    val shareIntent =
        Intent.createChooser(sendIntent, "Share installation logs")
    context.startActivity(shareIntent)
}
fun isRooted(context: Context): Boolean {
    return try {
        RootBeer(context).isRooted
    } catch (e: Exception) {
        e.printStackTrace()
        false
    }
}
fun isLSPosed(): Boolean {
    // This gets hooked by LSPosed, so if it
    // returns true, LSPosed is installed
    return false;
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\utils\SessionInstaller.kt --- 
package com.grindrplus.manager.utils
/**
 * Helper class for installing APK files using the PackageInstaller API
 */
class SessionInstaller {
    companion object {
        private const val TAG = "SessionInstaller"
        private const val ACTION_INSTALL_COMPLETE = "com.grindrplus.INSTALL_COMPLETE"
        private const val DEFAULT_BUFFER_SIZE = 8192
    }
    /**
     * Install multiple APK files (split APKs) using PackageInstaller
     *
     * @param context The application context
     * @param apks List of APK files to install
     * @param silent Whether to install silently (requires privileged permissions)
     * @param callback Optional callback to report success/failure
     * @return True if installation was successful, false otherwise
     */
    suspend fun installApks(
        context: Context,
        apks: List<File>,
        silent: Boolean = false,
        callback: ((success: Boolean, message: String) -> Unit)? = null,
        log: (String) -> Unit,
    ): Boolean = suspendCoroutine { continuation ->
        if (apks.isEmpty()) {
            val message = "No APK files provided."
            Timber.Forest.tag(TAG).e(message)
            callback?.invoke(false, message)
            continuation.resumeWithException(IOException(message))
            return@suspendCoroutine
        }
        // Validate all APK files exist
        val missingApks = apks.filter { !it.exists() || it.length() <= 0 }
        if (missingApks.isNotEmpty()) {
            val message =
                "Missing or empty APK files: ${missingApks.joinToString { it.absolutePath }}"
            Timber.Forest.tag(TAG).e(message)
            log("ERROR: $message")
            callback?.invoke(false, message)
            continuation.resumeWithException(IOException(message))
            return@suspendCoroutine
        }
        val packageInstaller = context.packageManager.packageInstaller
        // Create installation session
        val params =
            PackageInstaller.SessionParams(PackageInstaller.SessionParams.MODE_FULL_INSTALL).apply {
                setInstallReason(PackageManager.INSTALL_REASON_USER)
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                    setInstallScenario(PackageManager.INSTALL_SCENARIO_FAST)
                    if (silent) {
                        setRequireUserAction(PackageInstaller.SessionParams.USER_ACTION_NOT_REQUIRED)
                    }
                }
            }
        // Create the session
        val sessionId = try {
            packageInstaller.createSession(params)
        } catch (e: IOException) {
            val message = "Failed to create install session: ${e.message}"
            Timber.Forest.tag(TAG).e(e, message)
            log("ERROR: $message")
            callback?.invoke(false, message)
            continuation.resumeWithException(e)
            return@suspendCoroutine
        }
        // Process for completion
        val installCompleteReceiver = object : BroadcastReceiver() {
            @SuppressLint("UnsafeIntentLaunch")
            override fun onReceive(context: Context, intent: Intent) {
                try {
                    val status = intent.getIntExtra(
                        PackageInstaller.EXTRA_STATUS,
                        PackageInstaller.STATUS_FAILURE
                    )
                    val message = intent.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE)
                        ?: "Unknown status"
                    Timber.Forest.tag(TAG).d("Installation status: $status, message: $message")
                    log("DEBUG: $message")
                    when (status) {
                        PackageInstaller.STATUS_SUCCESS -> {
                            callback?.invoke(true, "Installation successful")
                            log("Installed!")
                            context.unregisterReceiver(this)
                            continuation.resume(true)
                        }
                        PackageInstaller.STATUS_PENDING_USER_ACTION -> {
                            Timber.Forest.tag(TAG).d("Installation requires user confirmation")
                            log("DEBUG: Installation requires user confirmation")
                            val confirmationIntent =
                                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                                    intent.getParcelableExtra(
                                        Intent.EXTRA_INTENT,
                                        Intent::class.java
                                    )
                                } else {
                                    @Suppress("DEPRECATION")
                                    intent.getParcelableExtra(Intent.EXTRA_INTENT)
                                }
                            if (confirmationIntent != null) {
                                confirmationIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                                try {
                                    context.startActivity(confirmationIntent)
                                    // Don't complete the coroutine yet - wait for final result
                                } catch (e: Exception) {
                                    val errorMsg =
                                        "Failed to start installer activity: ${e.message}"
                                    log("ERROR: $errorMsg")
                                    Timber.Forest.tag(TAG).e(e, errorMsg)
                                    context.unregisterReceiver(this)
                                    callback?.invoke(false, errorMsg)
                                    continuation.resumeWithException(IOException(errorMsg))
                                }
                            } else {
                                val errorMsg = "Missing confirmation intent"
                                log("ERROR: $errorMsg")
                                Timber.Forest.tag(TAG).e(errorMsg)
                                context.unregisterReceiver(this)
                                callback?.invoke(false, errorMsg)
                                continuation.resumeWithException(IOException(errorMsg))
                            }
                        }
                        PackageInstaller.STATUS_FAILURE,
                        PackageInstaller.STATUS_FAILURE_ABORTED,
                        PackageInstaller.STATUS_FAILURE_BLOCKED,
                        PackageInstaller.STATUS_FAILURE_CONFLICT,
                        PackageInstaller.STATUS_FAILURE_INCOMPATIBLE,
                        PackageInstaller.STATUS_FAILURE_INVALID,
                        PackageInstaller.STATUS_FAILURE_STORAGE,
                            -> {
                            val errorMsg = "Installation failed: $message (code: $status)"
                            Timber.Forest.tag(TAG).e(errorMsg)
                            context.unregisterReceiver(this)
                            callback?.invoke(false, errorMsg)
                            continuation.resumeWithException(IOException(errorMsg))
                        }
                        else -> {
                            val errorMsg = "Unknown status code: $status - $message"
                            Timber.Forest.tag(TAG).e(errorMsg)
                            context.unregisterReceiver(this)
                            callback?.invoke(false, errorMsg)
                            continuation.resumeWithException(IOException(errorMsg))
                        }
                    }
                } catch (e: Exception) {
                    Timber.Forest.tag(TAG).e(e, "Error in broadcast receiver")
                    context.unregisterReceiver(this)
                    callback?.invoke(false, "Error processing installation result: ${e.message}")
                    continuation.resumeWithException(e)
                }
            }
        }
        try {
            val intent = Intent(ACTION_INSTALL_COMPLETE).apply {
                setPackage(context.packageName)
                addFlags(Intent.FLAG_RECEIVER_FOREGROUND)
            }
            val flags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE
            } else {
                PendingIntent.FLAG_UPDATE_CURRENT
            }
            ContextCompat.registerReceiver(
                context,
                installCompleteReceiver,
                IntentFilter(ACTION_INSTALL_COMPLETE),
                ContextCompat.RECEIVER_EXPORTED
            )
            val pendingIntent = PendingIntent.getBroadcast(context, sessionId, intent, flags)
            packageInstaller.openSession(sessionId).use { session ->
                for (apk in apks) {
                    Timber.Forest.tag(TAG)
                        .d("Writing APK to session: ${apk.name} (${apk.length()} bytes)")
                    apk.inputStream().use { inputStream ->
                        session.openWrite(apk.name, 0, apk.length()).use { outputStream ->
                            inputStream.copyTo(outputStream, DEFAULT_BUFFER_SIZE)
                            session.fsync(outputStream)
                        }
                    }
                }
                Timber.Forest.tag(TAG).d("Committing installation session...")
                session.commit(pendingIntent.intentSender)
            }
        } catch (e: Exception) {
            try {
                packageInstaller.abandonSession(sessionId)
            } catch (_: Exception) {
            }
            try {
                context.unregisterReceiver(installCompleteReceiver)
            } catch (_: Exception) {
            }
            val message = "Installation failed: ${e.message}"
            Timber.Forest.tag(TAG).e(e, message)
            callback?.invoke(false, message)
            continuation.resumeWithException(e)
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\manager\utils\StorageUtils.kt --- 
package com.grindrplus.manager.utils
object StorageUtils {
    private const val TAG = "StorageUtils"
    fun getAvailableSpace(path: File): Long {
        return try {
            if (!path.exists()) {
                path.mkdirs()
            }
            val stat = StatFs(path.path)
            val blockSize = stat.blockSizeLong
            val availableBlocks = stat.availableBlocksLong
            blockSize * availableBlocks
        } catch (e: Exception) {
            Timber.tag(TAG).e(e, "Error checking available space")
            0L
        }
    }
    fun cleanupOldInstallationFiles(
        context: Context,
        keepLatestVersion: Boolean = true,
        latestVersion: String? = null
    ) {
        try {
            val folder = context.getExternalFilesDir(null) ?: return
            val threeDaysAgo = System.currentTimeMillis() - (3 * 24 * 60 * 60 * 1000)
            val splitApksDir = File(folder, "splitApks/")
            if (splitApksDir.exists() && splitApksDir.isDirectory) {
                if (splitApksDir.lastModified() < threeDaysAgo) {
                    splitApksDir.deleteRecursively()
                }
            }
            val outputDir = File(folder, "LSPatchOutput/")
            if (outputDir.exists() && outputDir.isDirectory) {
                if (outputDir.lastModified() < threeDaysAgo) {
                    outputDir.deleteRecursively()
                }
            }
            folder.listFiles()?.forEach { file ->
                if (file.name.startsWith("grindr-") && file.name.endsWith(".xapk")) {
                    val version = file.name.removePrefix("grindr-").removeSuffix(".xapk")
                    if (!keepLatestVersion || version != latestVersion) {
                        if (file.lastModified() < threeDaysAgo) {
                            file.delete()
                        }
                    }
                }
            }
            folder.listFiles()?.forEach { file ->
                if (file.name.startsWith("mod-") && file.name.endsWith(".zip")) {
                    val version = file.name.removePrefix("mod-").removeSuffix(".zip")
                    if (!keepLatestVersion || version != latestVersion) {
                        if (file.lastModified() < threeDaysAgo) {
                            file.delete()
                        }
                    }
                }
            }
        } catch (e: Exception) {
            Timber.tag(TAG).e(e, "Error during cleanup")
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\GPDatabase.kt --- 
package com.grindrplus.persistence
@Database(
    entities = [
        AlbumEntity::class,
        AlbumContentEntity::class,
        TeleportLocationEntity::class,
        SavedPhraseEntity::class,
        ViewedSummary::class,
        ViewedProfile::class,
        MediaItem::class,
        ArchivedConversationEntity::class,
        ArchivedChatMessageEntity::class,
        ChatBackup::class,
        ConversationBackup::class,  // Add this
        ParticipantBackup::class    // Add this
    ],
    version = 8, // Increment version
    exportSchema = false
)
@TypeConverters(DateConverter::class, ListConverter::class)
abstract class GPDatabase : RoomDatabase() {
    abstract fun albumDao(): AlbumDao
    abstract fun teleportLocationDao(): TeleportLocationDao
    abstract fun savedPhraseDao(): SavedPhraseDao
    abstract fun chatBackupDao(): ChatBackupDao  // Add this
    companion object {
        private const val DATABASE_NAME = "grindrplus.db"
        @Volatile
        private var INSTANCE: GPDatabase? = null
      /*  fun create(context: Context): GPDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    GPDatabase::class.java,
                    DATABASE_NAME
                )
                    .fallbackToDestructiveMigration() // <-- ADD THIS LINE
                    .setJournalMode(JournalMode.WRITE_AHEAD_LOGGING)
                    .build()
                INSTANCE = instance
                instance
            }
        }
    }
    }
        */
        fun create(context: Context): GPDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context,
                    GPDatabase::class.java,
                    DATABASE_NAME
                )
                    .addMigrations(MIGRATION_5_6, MIGRATION_6_7, MIGRATION_7_8)
                    .setJournalMode(JournalMode.WRITE_AHEAD_LOGGING)
                    .build()
                INSTANCE = instance
                instance
            }
        }
     private val MIGRATION_7_8 = object : Migration(7, 8) {
            override fun migrate(db: SupportSQLiteDatabase) {
                // Create chat_backup table
                db.execSQL(
                    """
                    CREATE TABLE IF NOT EXISTS `chat_backup` (
                        `message_id` TEXT NOT NULL PRIMARY KEY,
                        `conversation_id` TEXT NOT NULL,
                        `sender` TEXT NOT NULL,
                        `body` TEXT NOT NULL,
                        `timestamp` INTEGER NOT NULL,
                        `type` TEXT NOT NULL
                    )
                """
                )
                // Create conversation_backup table
                db.execSQL(
                    """
                    CREATE TABLE IF NOT EXISTS `conversation_backup` (
                        `conversation_id` TEXT NOT NULL PRIMARY KEY,
                        `name` TEXT NOT NULL DEFAULT '',
                        `last_message_timestamp` INTEGER NOT NULL,
                        `unread` INTEGER NOT NULL DEFAULT 0
                    )
                """
                )
                // Create participant_backup table
                db.execSQL(
                    """
                    CREATE TABLE IF NOT EXISTS `participant_backup` (
                        `id` INTEGER PRIMARY KEY AUTOINCREMENT,
                        `conversation_id` TEXT NOT NULL,
                        `profile_id` TEXT NOT NULL,
                        `last_online` INTEGER NOT NULL
                    )
                """
                )
                // Create indices
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_chat_backup_conversation_id` ON `chat_backup` (`conversation_id`)")
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_participant_backup_conversation_id` ON `participant_backup` (`conversation_id`)")
            }
        }
        private val MIGRATION_5_6 = object : Migration(5, 6) {
            override fun migrate(database: SupportSQLiteDatabase) {
                database.execSQL(
                    """
                    CREATE TABLE IF NOT EXISTS `viewed_summary` (
                        `id` INTEGER NOT NULL PRIMARY KEY,
                        `viewedCount` INTEGER NOT NULL,
                        `mostRecentProfileId` TEXT
                    )
                """
                )
                database.execSQL(
                    """
                    CREATE TABLE IF NOT EXISTS `viewed_profiles` (
                        `profileId` TEXT NOT NULL PRIMARY KEY,
                        `viewCount` INTEGER NOT NULL,
                        `lastTimestamp` INTEGER NOT NULL,
                        `photoHashes` TEXT NOT NULL
                    )
                """
                )
                database.execSQL(
                    """
                    CREATE TABLE IF NOT EXISTS `media_items` (
                        `imageHash` TEXT NOT NULL PRIMARY KEY,
                        `mediaId` INTEGER,
                        `url` TEXT NOT NULL,
                        `width` INTEGER NOT NULL,
                        `height` INTEGER NOT NULL,
                        `takenOnGrindr` INTEGER NOT NULL,
                        `createdAt` INTEGER NOT NULL,
                        `imageType` INTEGER NOT NULL,
                        `tapType` INTEGER NOT NULL,
                        `localPath` TEXT
                    )
                """
                )
            }
        }
        private val MIGRATION_6_7 = object : Migration(6, 7) {
            override fun migrate(db: SupportSQLiteDatabase) {
                db.execSQL(
                    """
                    CREATE TABLE IF NOT EXISTS `archived_conversations` (
                        `conversationId` TEXT NOT NULL PRIMARY KEY,
                        `name` TEXT,
                        `lastMessageTimestamp` INTEGER
                    )
                """
                )
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_archived_conversations_conversationId` ON `archived_conversations` (`conversationId`)")
                db.execSQL(
                    """
                    CREATE TABLE IF NOT EXISTS `archived_chat_messages` (
                        `messageId` TEXT NOT NULL PRIMARY KEY,
                        `conversationId` TEXT NOT NULL,
                        `senderId` TEXT,
                        `timestamp` INTEGER,
                        `body` TEXT
                    )
                """
                )
                db.execSQL("CREATE INDEX IF NOT EXISTS `index_archived_chat_messages_conversationId` ON `archived_chat_messages` (`conversationId`)")
            }
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\converters\DateConverter.kt --- 
package com.grindrplus.persistence.converters
class DateConverter {
    companion object {
        private val dateFormat = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US).apply {
            timeZone = TimeZone.getTimeZone("UTC")
        }
    }
    @TypeConverter
    fun fromTimestamp(value: String?): Date? {
        return value?.let {
            try {
                dateFormat.parse(it)
            } catch (e: Exception) {
                null
            }
        }
    }
    @TypeConverter
    fun dateToTimestamp(date: Date?): String? {
        return date?.let { dateFormat.format(it) }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\converters\ListConverter.kt --- 
package com.grindrplus.persistence.converters
class ListConverter {
    @TypeConverter
    fun fromString(value: String): List<String> {
        val array = JSONArray(value)
        return (0 until array.length()).map { array.getString(it) }
    }
    @TypeConverter
    fun fromList(list: List<String>): String {
        return JSONArray(list).toString()
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\dao\AlbumDao.kt --- 
package com.grindrplus.persistence.dao
@Dao
interface AlbumDao {
    /**
     * Gets all albums from the database
     * @return List of all albums
     */
    @Query("SELECT * FROM AlbumEntity ORDER BY updatedAt DESC")
    suspend fun getAlbums(): List<AlbumEntity>
    /**
     * Gets all albums for a specific profile
     * @param profileId The profile ID to filter by
     * @return List of albums belonging to the specified profile
     */
    @Query("SELECT * FROM AlbumEntity WHERE profileId = :profileId ORDER BY updatedAt DESC")
    suspend fun getAlbums(profileId: Long): List<AlbumEntity>
    /**
     * Gets a single album by ID
     * @param id The album ID
     * @return The album entity or null if not found
     */
    @Query("SELECT * FROM AlbumEntity WHERE id = :id")
    suspend fun getAlbum(id: Long): AlbumEntity?
    /**
     * Upserts (insert or update) an album
     * @param album The album entity to upsert
     */
    @Upsert
    suspend fun upsertAlbum(album: AlbumEntity)
    /**
     * Batch upsert for multiple albums
     * @param albums The list of album entities to upsert
     */
    @Upsert
    suspend fun upsertAlbums(albums: List<AlbumEntity>)
    /**
     * Inserts an album from album brief information, ignoring conflicts
     * @param albumEntity The album entity to insert
     */
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insertAlbumFromAlbumBrief(albumEntity: AlbumEntity)
    /**
     * Gets all album content for a specific album
     * @param albumId The album ID
     * @return List of album content entities
     */
    @Query("SELECT * FROM AlbumContentEntity WHERE albumId = :albumId")
    suspend fun getAlbumContent(albumId: Long): List<AlbumContentEntity>
    /**
     * Upserts an album content entity
     * @param dbAlbumContent The album content entity to upsert
     */
    @Upsert
    suspend fun upsertAlbumContent(dbAlbumContent: AlbumContentEntity)
    /**
     * Batch upsert for multiple album content entities
     * @param contents The list of album content entities to upsert
     */
    @Upsert
    suspend fun upsertAlbumContents(contents: List<AlbumContentEntity>)
    /**
     * Deletes an album and its contents
     * @param id The album ID to delete
     */
    @Query("DELETE FROM AlbumEntity WHERE id = :id")
    suspend fun deleteAlbum(id: Long)
    /**
     * Checks if an album exists
     * @param id The album ID to check
     * @return True if the album exists, false otherwise
     */
    @Query("SELECT EXISTS(SELECT 1 FROM AlbumEntity WHERE id = :id)")
    suspend fun albumExists(id: Long): Boolean
    /**
     * Deletes all albums and their content for a profile
     * @param profileId The profile ID
     */
    @Query("DELETE FROM AlbumEntity WHERE profileId = :profileId")
    suspend fun deleteProfileAlbums(profileId: Long)
    /**
     * Complete transaction to save an album and its content in one atomic operation
     * @param album The album entity
     * @param contents The list of album content entities
     */
    @Transaction
    suspend fun saveAlbumWithContent(album: AlbumEntity, contents: List<AlbumContentEntity>) {
        upsertAlbum(album)
        upsertAlbumContents(contents)
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\dao\ChatBackupDao.kt --- 
package com.grindrplus.persistence.dao
@Dao
interface ChatBackupDao {
    // Chat messages
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertMessage(chatBackup: ChatBackup)
    @Query("SELECT * FROM chat_backup WHERE conversation_id = :conversationId ORDER BY timestamp ASC")
    suspend fun getMessagesByConversation(conversationId: String): List<ChatBackup>
    // Conversations
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertConversation(conversationBackup: ConversationBackup)
    @Query("SELECT * FROM conversation_backup")
    suspend fun getAllConversations(): List<ConversationBackup>
    // Participants
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertParticipant(participantBackup: ParticipantBackup)
    @Query("SELECT * FROM participant_backup WHERE conversation_id = :conversationId")
    suspend fun getParticipantsByConversation(conversationId: String): List<ParticipantBackup>
}
/*
@Dao
interface ChatBackupDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(chatBackup: ChatBackup)
    @Query("SELECT * FROM chat_backup WHERE conversation_id = :conversationId ORDER BY timestamp ASC")
    suspend fun getMessagesByConversation(conversationId: String): List<ChatBackup>
    @Query("DELETE FROM chat_backup WHERE message_id = :messageId")
    suspend fun deleteMessage(messageId: String)
    @Query("SELECT COUNT(*) FROM chat_backup WHERE conversation_id = :conversationId")
    suspend fun getMessageCount(conversationId: String): Int
}*/
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\dao\MediaItemDao.kt --- 
package com.grindrplus.persistence.dao
@Dao
interface MediaItemDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertMediaItem(mediaItem: MediaItem)
    @Query("SELECT * FROM media_items WHERE imageHash = :hash")
    suspend fun getMediaItemByHash(hash: String): MediaItem?
    suspend fun downloadAndSaveMedia(context: Context, mediaItem: MediaItem): MediaItem? {
        if (mediaItem.localPath != null && File(mediaItem.localPath).exists()) {
            return mediaItem
        }
        return try {
            val directory = File(context.filesDir, "media")
            directory.mkdirs()
            val file = File(directory, "${mediaItem.imageHash}.jpg")
            withContext(Dispatchers.IO) {
                URL(mediaItem.url).openStream().use { input ->
                    FileOutputStream(file).use { output ->
                        input.copyTo(output)
                    }
                }
            }
            val updatedMediaItem = mediaItem.copy(localPath = file.absolutePath)
            insertMediaItem(updatedMediaItem)
            updatedMediaItem
        } catch (e: Exception) {
            // Handle exceptions, e.g., logging
            null
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\dao\SavedPhraseDao.kt --- 
package com.grindrplus.persistence.dao
@Dao
interface SavedPhraseDao {
    /**
     * Get all saved phrases
     * @return A list of saved phrases, ordered by frequency and timestamp
     */
    @Query("SELECT * FROM SavedPhraseEntity ORDER BY frequency DESC, timestamp DESC")
    suspend fun getPhraseList(): List<SavedPhraseEntity>
    /**
     * Get a phrase by ID
     * @param phraseId The ID of the phrase
     */
    @Query("SELECT * FROM SavedPhraseEntity WHERE phraseId = :phraseId")
    suspend fun getPhrase(phraseId: Long): SavedPhraseEntity?
    /**
     * Add a new phrase
     * @param phrase The phrase entity to add
     */
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun addPhrase(phrase: SavedPhraseEntity): Long
    /**
     * Update an existing phrase
     * @param phrase The phrase entity to update
     */
    @Upsert
    suspend fun upsertPhrase(phrase: SavedPhraseEntity)
    /**
     * Delete a phrase
     * @param phraseId The ID of the phrase to delete
     */
    @Query("DELETE FROM SavedPhraseEntity WHERE phraseId = :phraseId")
    suspend fun deletePhrase(phraseId: Long): Int
    /**
     * Get the highest phrase ID
     * @return The highest phrase ID or null if no phrases exist
     */
    @Query("SELECT MAX(phraseId) FROM SavedPhraseEntity")
    suspend fun getCurrentPhraseIndex(): Long?
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\dao\TeleportLocationDao.kt --- 
package com.grindrplus.persistence.dao
@Dao
interface TeleportLocationDao {
    /**
     * Get all teleport locations
     * @return A list of teleport locations
     */
    @Query("SELECT * FROM TeleportLocationEntity")
    suspend fun getLocations(): List<TeleportLocationEntity>
    /**
     * Get a location by name
     * @param name The name of the location
     * @return The location entity or null if not found
     */
    @Query("SELECT * FROM TeleportLocationEntity WHERE name = :name")
    suspend fun getLocation(name: String): TeleportLocationEntity?
    /**
     * Add a new location
     */
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun addLocation(location: TeleportLocationEntity): Long
    /**
     * Update an existing location
     */
    @Upsert
    suspend fun upsertLocation(location: TeleportLocationEntity)
    /**
     * Delete a location
     */
    @Query("DELETE FROM TeleportLocationEntity WHERE name = :name")
    suspend fun deleteLocation(name: String): Int
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\dao\ViewedProfileDao.kt --- 
package com.grindrplus.persistence.dao
@Dao
interface ViewedProfileDao {
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insertProfile(profile: ViewedProfile)
    @Update
    suspend fun updateProfile(profile: ViewedProfile)
    @Query("SELECT * FROM viewed_profiles WHERE profileId = :profileId")
    suspend fun getProfileById(profileId: String): ViewedProfile?
    @Query("SELECT profileId FROM viewed_profiles ORDER BY lastTimestamp DESC LIMIT 1")
    suspend fun getMostRecentProfileId(): String?
    @Query("SELECT SUM(viewCount) FROM viewed_profiles")
    suspend fun getTotalViewedCount(): Int
    @Transaction
    suspend fun handleNewProfileView(profileId: String, photoHash: String, timestamp: Long) {
        val existingProfile = getProfileById(profileId)
        if (existingProfile == null) {
            val newProfile = ViewedProfile(profileId, 1, timestamp, listOf(photoHash))
            insertProfile(newProfile)
        } else {
            val updatedHashes = if (photoHash !in existingProfile.photoHashes) {
                existingProfile.photoHashes + photoHash
            } else {
                existingProfile.photoHashes
            }
            val updatedTimestamp = maxOf(existingProfile.lastTimestamp, timestamp)
            val updatedProfile = existingProfile.copy(
                viewCount = existingProfile.viewCount + 1,
                lastTimestamp = updatedTimestamp,
                photoHashes = updatedHashes
            )
            updateProfile(updatedProfile)
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\dao\ViewedSummaryDao.kt --- 
package com.grindrplus.persistence.dao
@Dao
interface ViewedSummaryDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdateSummary(summary: ViewedSummary)
    @Query("SELECT * FROM viewed_summary WHERE id = 1")
    suspend fun getSummary(): ViewedSummary?
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\mappers\AlbumMapper.kt --- 
package com.grindrplus.persistence.mappers
private val dateFormat = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US)
private const val ALBUM_CLASS = "com.grindrapp.android.model.Album"
private const val ALBUM_BRIEF_CLASS = "com.grindrapp.android.model.albums.AlbumBrief"
private const val ALBUM_CONTENT_CLASS = "com.grindrapp.android.model.AlbumContent"
fun Any.asAlbumToAlbumEntity(): AlbumEntity {
    return try {
        val id = getObjectField(this, "albumId") as Long
        val name = getObjectField(this, "albumName") as String?
        val profileId = getObjectField(this, "profileId") as Long
        val createdAt = getObjectField(this, "createdAt") as String
        val updatedAt = getObjectField(this, "updatedAt") as String
        AlbumEntity(
            id = id,
            albumName = name,
            createdAt = createdAt,
            profileId = profileId,
            updatedAt = updatedAt
        )
    } catch (e: Throwable) {
        Logger.e("Error converting Album to AlbumEntity: ${e.message}")
        val currentTime = dateFormat.format(Date())
        AlbumEntity(
            id = System.currentTimeMillis(),
            albumName = "Unknown Album",
            createdAt = currentTime,
            profileId = 0L,
            updatedAt = currentTime
        )
    }
}
fun Any.asAlbumBriefToAlbumEntity(): AlbumEntity {
    return try {
        val id = getObjectField(this, "albumId") as Long
        val profileIdObj = getObjectField(this, "profileId")
        val profileId = when (profileIdObj) {
            is String -> parseLong(profileIdObj)
            is Long -> profileIdObj
            else -> 0L
        }
        val name = try { getObjectField(this, "albumName") as String? } catch (_: Throwable) { null }
        val createdAt = try { getObjectField(this, "createdAt") as String } catch (_: Throwable) { "" }
        val updatedAt = try { getObjectField(this, "updatedAt") as String } catch (_: Throwable) { "" }
        AlbumEntity(
            id = id,
            albumName = name,
            createdAt = createdAt,
            profileId = profileId,
            updatedAt = updatedAt
        )
    } catch (e: Throwable) {
        Logger.e("Error converting AlbumBrief to AlbumEntity: ${e.message}")
        val currentTime = dateFormat.format(Date())
        AlbumEntity(
            id = System.currentTimeMillis(),
            albumName = "Unknown Album",
            createdAt = currentTime,
            profileId = 0L,
            updatedAt = currentTime
        )
    }
}
fun Any.toAlbumContentEntity(albumId: Long): AlbumContentEntity {
    return try {
        val id = getObjectField(this, "contentId") as Long
        val contentType = getObjectField(this, "contentType") as String?
        val coverUrl = getObjectField(this, "coverUrl") as String?
        val thumbUrl = getObjectField(this, "thumbUrl") as String?
        val url = getObjectField(this, "url") as String?
        AlbumContentEntity(
            id = id,
            albumId = albumId,
            contentType = contentType,
            coverUrl = coverUrl,
            thumbUrl = thumbUrl,
            url = url
        )
    } catch (e: Throwable) {
        Logger.e("Error converting AlbumContent to AlbumContentEntity: ${e.message}")
        AlbumContentEntity(
            id = System.currentTimeMillis() + albumId,
            albumId = albumId,
            contentType = "unknown",
            coverUrl = null,
            thumbUrl = null,
            url = null
        )
    }
}
fun AlbumEntity.toGrindrAlbum(dbContent: List<AlbumContentEntity>): Any {
    try {
        val albumConstructor = GrindrPlus.loadClass(ALBUM_CLASS).constructors.first()
        return albumConstructor.newInstance(
            id, // albumId
            profileId, // profileId
            0, // sharedCount
            dbContent.map { it.toGrindrAlbumContent() }, // content
            false, // isSelected
            false, // isPromoAlbum
            null, // promoAlbumName
            null, // promoAlbumProfileImage
            null, // promoAlbumData
            false, // hasUnseenContent
            true, // albumViewable
            true, // isShareable
            Long.MAX_VALUE, // viewableUntil
            albumName, // albumName
            0, // albumNumber
            0, // totalAlbumsShared
            null, // contentCount
            createdAt, // createdAt
            updatedAt, // updatedAt
            emptyList<Any>() // sharedWithProfileIds
        )
    } catch (e: Throwable) {
        Logger.e("Error creating Album instance: ${e.message}")
        Logger.writeRaw(e.stackTraceToString())
        try {
            val albumClass = GrindrPlus.loadClass(ALBUM_CLASS)
            val constructors = albumClass.constructors
            Logger.d("Available constructors for Album: ${constructors.size}")
            constructors.forEachIndexed { index, constructor ->
                Logger.d("Constructor $index: ${constructor.parameterTypes.joinToString()}")
            }
        } catch (e2: Throwable) {
            Logger.e("Failed to inspect Album constructors: ${e2.message}")
        }
        throw e
    }
}
fun AlbumEntity.toGrindrAlbumBrief(dbContent: AlbumContentEntity): Any {
    try {
        val albumBriefConstructor = GrindrPlus.loadClass(ALBUM_BRIEF_CLASS).constructors.first()
        return albumBriefConstructor.newInstance(
            id, // albumId
            profileId.toString(), // profileId
            dbContent.toGrindrAlbumContent(), // content
            false, // hasUnseenContent
            true, // albumViewable
            0, // albumNumber
            0, // totalAlbumsShared
            null // contentCount
        )
    } catch (e: Throwable) {
        Logger.e("Error creating AlbumBrief instance: ${e.message}")
        try {
            val albumBriefClass = GrindrPlus.loadClass(ALBUM_BRIEF_CLASS)
            val constructors = albumBriefClass.constructors
            Logger.d("Available constructors for AlbumBrief: ${constructors.size}")
            constructors.forEachIndexed { index, constructor ->
                Logger.d("Constructor $index: ${constructor.parameterTypes.joinToString()}")
            }
        } catch (e2: Throwable) {
            Logger.e("Failed to inspect AlbumBrief constructors: ${e2.message}")
        }
        throw e
    }
}
fun AlbumContentEntity.toGrindrAlbumContent(): Any {
    try {
        val albumContentConstructor = GrindrPlus.loadClass(ALBUM_CONTENT_CLASS).constructors.first()
        return albumContentConstructor.newInstance(
            id, // contentId
            contentType, // contentType
            url, // url
            false, // isProcessing
            thumbUrl, // thumbUrl
            coverUrl, // coverUrl
            -1 // remainingViews
        )
    } catch (e: Throwable) {
        Logger.e("Error creating AlbumContent instance: ${e.message}")
        try {
            val albumContentClass = GrindrPlus.loadClass(ALBUM_CONTENT_CLASS)
            val constructors = albumContentClass.constructors
            Logger.d("Available constructors for AlbumContent: ${constructors.size}")
            constructors.forEachIndexed { index, constructor ->
                Logger.d("Constructor $index: ${constructor.parameterTypes.joinToString()}")
            }
        } catch (e2: Throwable) {
            Logger.e("Failed to inspect AlbumContent constructors: ${e2.message}")
        }
        throw e
    }
}
fun AlbumEntity.toGrindrAlbumWithoutContent(): Any {
    try {
        val albumConstructor = GrindrPlus.loadClass(ALBUM_CLASS).constructors.first()
        return albumConstructor.newInstance(
            id, // albumId
            profileId, // profileId
            0, // sharedCount
            emptyList<Any>(), // content
            false, // isSelected
            false, // isPromoAlbum
            null, // promoAlbumName
            null, // promoAlbumProfileImage
            null, // promoAlbumData
            false, // hasUnseenContent
            true, // albumViewable
            true, // isShareable
            Long.MAX_VALUE, // viewableUntil
            albumName, // albumName
            0, // albumNumber
            0, // totalAlbumsShared
            null, // contentCount
            createdAt, // createdAt
            updatedAt, // updatedAt
            emptyList<Any>() // sharedWithProfileIds
        )
    } catch (e: Throwable) {
        Logger.e("Error creating Album instance without content: ${e.message}")
        Logger.writeRaw(e.stackTraceToString())
        throw e
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\model\AlbumContentEntity.kt --- 
package com.grindrplus.persistence.model
@Entity(
    foreignKeys = [
        ForeignKey(
            entity = AlbumEntity::class,
            parentColumns = ["id"],
            childColumns = ["albumId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index("albumId")]
)
data class AlbumContentEntity(
    @PrimaryKey val id: Long,
    val albumId: Long,
    val contentType: String?,
    val coverUrl: String?,
    val thumbUrl: String?,
    val url: String?
) 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\model\AlbumEntity.kt --- 
package com.grindrplus.persistence.model
@Entity(indices = [Index("profileId")])
data class AlbumEntity(
    @PrimaryKey val id: Long,
    val albumName: String?,
    val createdAt: String,
    val profileId: Long,
    val updatedAt: String,
) 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\model\ChatBackupEntity.kt --- 
package com.grindrplus.persistence.model
@Entity(tableName = "archived_conversations", indices = [Index("conversationId")])
data class ArchivedConversationEntity(
    @PrimaryKey val conversationId: String,
    val name: String?,
    val lastMessageTimestamp: Long?
)
@Entity(tableName = "archived_chat_messages", indices = [Index("conversationId")])
data class ArchivedChatMessageEntity(
    @PrimaryKey val messageId: String,
    val conversationId: String,
    val senderId: String?,
    val timestamp: Long?,
    val body: String? // Storing the raw JSON body
)
@Entity(tableName = "chat_backup")
data class ChatBackup(
    @PrimaryKey
    val message_id: String,
    val conversation_id: String,
    val sender: String,
    val body: String,
    val timestamp: Long,
    val type: String
) 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\model\ConversationBackup.kt --- 
package com.grindrplus.persistence.model
@Entity(tableName = "conversation_backup")
data class ConversationBackup(
    @PrimaryKey
    val conversation_id: String,
    val name: String = "",
    val last_message_timestamp: Long,
    val unread: Int = 0
)
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\model\MediaItem.kt --- 
package com.grindrplus.persistence.model
@Entity(tableName = "media_items")
data class MediaItem(
    @PrimaryKey val imageHash: String,
    val mediaId: Long? = null,
    val url: String,
    val width: Int,
    val height: Int,
    val takenOnGrindr: Boolean,
    val createdAt: Long,
    val imageType: Int,
    val tapType: Int,
    val localPath: String? = null
) 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\model\ParticipantBackup.kt --- 
package com.grindrplus.persistence.model
@Entity(tableName = "participant_backup")
data class ParticipantBackup(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val conversation_id: String,
    val profile_id: String,
    val last_online: Long
) 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\model\SavedPhraseEntity.kt --- 
package com.grindrplus.persistence.model
@Entity
data class SavedPhraseEntity(
    @PrimaryKey val phraseId: Long,
    val text: String,
    val frequency: Int,
    val timestamp: Long
) 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\model\TeleportLocationEntity.kt --- 
package com.grindrplus.persistence.model
@Entity
data class TeleportLocationEntity(
    @PrimaryKey val name: String,
    val latitude: Double,
    val longitude: Double
) 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\model\ViewedProfile.kt --- 
package com.grindrplus.persistence.model
@Entity(tableName = "viewed_profiles")
data class ViewedProfile(
    @PrimaryKey val profileId: String,
    val viewCount: Int,
    val lastTimestamp: Long,
    val photoHashes: List<String>
) 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\persistence\model\ViewedSummary.kt --- 
package com.grindrplus.persistence.model
@Entity(tableName = "viewed_summary")
data class ViewedSummary(
    @PrimaryKey val id: Int = 1,
    val viewedCount: Int = 0,
    val mostRecentProfileId: String? = null
) 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\tasks\AlwaysOnline.kt --- 
package com.grindrplus.tasks
class AlwaysOnline :
    Task(
        id = "Always Online",
        description = "Keeps you online by periodically fetching cascade",
        initialDelayMillis = 30 * 1000,
        intervalMillis = 5 * 60 * 1000
    ) {
    override suspend fun execute() {
        try {
            val serverDrivenCascadeRepoInstance =
                GrindrPlus.instanceManager.getInstance<Any>(GrindrPlus.serverDrivenCascadeRepo)
            val grindrLocationProviderInstance =
                GrindrPlus.instanceManager.getInstance<Any>(GrindrPlus.grindrLocationProvider)
            val location = getObjectField(grindrLocationProviderInstance, "e")
            val latitude = callMethod(location, "getLatitude") as Double
            val longitude = callMethod(location, "getLongitude") as Double
            val geoHash = coordsToGeoHash(latitude, longitude)
            val methodName = "fetchCascadePage"
            val method =
                serverDrivenCascadeRepoInstance!!.javaClass.methods.firstOrNull {
                    it.name == methodName
                } ?: throw IllegalStateException("Unable to find $methodName method")
            val params = arrayOf<Any?>(
                geoHash,
                null,
                false, false, false, false,
                null, null, null,
                null, null, null, null,
                null, null, null, null,
                null, null, null, null,
                false,
                1,
                null, null,
                false, false, false,
                null,
                false
            )
            val result = callSuspendFunction { continuation ->
                method.invoke(serverDrivenCascadeRepoInstance, *params, continuation)
            }
            if (result.toString().contains("Success")) {
                logi("AlwaysOnline task executed successfully")
            } else {
                loge("AlwaysOnline task failed: $result")
            }
        } catch (e: Exception) {
            loge("Error in AlwaysOnline task: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
        }
    }
}
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\ui\Utils.kt --- 
package com.grindrplus.ui
object Utils {
    fun getId(name: String, defType: String, context: Context): Int {
        return context.resources.getIdentifier(name, defType, context.packageName)
    }
    fun createButtonDrawable(color: Int): GradientDrawable {
        return GradientDrawable().apply {
            shape = GradientDrawable.RECTANGLE
            setColor(color)
            cornerRadius = 12f
        }
    }
    fun copyToClipboard(label: String, text: String) {
        val clipboard = GrindrPlus.context.getSystemService(ClipboardManager::class.java)
        clipboard.setPrimaryClip(ClipData.newPlainText(label, text))
        GrindrPlus.showToast(Toast.LENGTH_LONG, "$label copied to clipboard.")
    }
    fun formatEpochSeconds(epochSec: Long): String {
        val formatter = DateTimeFormatter.ofPattern(Config.get(
            "date_format", "yyyy-MM-dd") as String)
        return try {
            val instant = Instant.ofEpochSecond(epochSec)
            val dt = LocalDateTime.ofInstant(instant, ZoneOffset.UTC)
            dt.format(formatter)
        } catch (e: Exception) {
            Logger.e("Error formatting date: $epochSec with format: $formatter")
            Logger.writeRaw(e.stackTraceToString())
            "Unknown"
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\utils\FeatureManager.kt --- 
package com.grindrplus.utils
data class Feature(val name: String, var isEnabled: Boolean)
class FeatureManager {
    private val features = mutableMapOf<String, Feature>()
    fun add(feature: Feature) {
        features[feature.name] = feature
    }
    fun isEnabled(featureName: String): Boolean {
        return features[featureName]?.isEnabled ?: false
    }
    fun isManaged(featureName: String): Boolean {
        return features.containsKey(featureName)
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\utils\Hook.kt --- 
package com.grindrplus.utils
abstract class Hook(
    val hookName: String,
    val hookDesc: String = "",
) {
    /**
     * Hook specific initialization.
     */
    open fun init() {}
    /**
     * Hook specific cleanup.
     */
    open fun cleanup() {}
    protected fun isHookEnabled(): Boolean {
        return Config.isHookEnabled(hookName)
    }
    protected fun findClass(name: String): Class<*> {
        return GrindrPlus.loadClass(name)
    }
    protected fun getResource(name: String, type: String): Int {
        return GrindrPlus.context.resources.getIdentifier(
            name, type, GrindrPlus.context.packageName
        )
    }
    protected fun getAttribute(name: String): Int {
        return GrindrPlus.context.resources.getIdentifier(name, "attr"
            , GrindrPlus.context.packageName)
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\utils\HookAdapter.kt --- 
package com.grindrplus.utils
@Suppress("UNCHECKED_CAST")
class HookAdapter<Clazz>(
    private val methodHookParam: XC_MethodHook.MethodHookParam<*>
) {
    fun thisObject(): Clazz {
        return methodHookParam.thisObject as Clazz
    }
    fun nullableThisObject(): Clazz? {
        return methodHookParam.thisObject as Clazz?
    }
    fun method(): Member {
        return methodHookParam.method
    }
    fun <T : Any> arg(index: Int): T {
        return methodHookParam.args[index] as T
    }
    fun <T : Any> arg(index: Int, clazz: Class<T>): T? {
        val argValue = methodHookParam.args[index]
        return try {
            clazz.cast(argValue)
        } catch (e: ClassCastException) {
            convertToType(argValue, clazz) ?: handlePrimitiveDefaults(clazz)
        }
    }
    fun <T : Any> argNullable(index: Int): T? {
        return methodHookParam.args.getOrNull(index) as T?
    }
    fun setArg(index: Int, value: Any?) {
        if (index < 0 || index >= methodHookParam.args.size) return
        methodHookParam.args[index] = value
    }
    fun args(): Array<Any?> {
        return methodHookParam.args
    }
    fun getResult(): Any? {
        return methodHookParam.result
    }
    fun setResult(result: Any?) {
        methodHookParam.result = result
    }
    fun setThrowable(throwable: Throwable) {
        methodHookParam.throwable = throwable
    }
    fun throwable(): Throwable? {
        return methodHookParam.throwable
    }
    fun invokeOriginal(): Any? {
        return XposedBridge.invokeOriginalMethod(method(), thisObject(), args())
    }
    fun invokeOriginal(args: Array<Any?>): Any? {
        return XposedBridge.invokeOriginalMethod(method(), thisObject(), args)
    }
    fun invokeOriginalSafe(errorCallback: Consumer<Throwable>) {
        invokeOriginalSafe(args(), errorCallback)
    }
    fun invokeOriginalSafe(args: Array<Any?>, errorCallback: Consumer<Throwable>) {
        runCatching {
            setResult(XposedBridge.invokeOriginalMethod(method(), thisObject(), args))
        }.onFailure {
            errorCallback.accept(it)
        }
    }
    private fun invokeMethodSafe(obj: Any, methodName: String): Any? {
        return try {
            obj::class.java.getMethod(methodName).invoke(obj)
        } catch (e: NoSuchMethodException) {
            null
        }
    }
    private fun <T : Any> handlePrimitiveDefaults(clazz: Class<T>): T? {
        return when (clazz) {
            Int::class.java -> 0 as T
            Double::class.java -> 0.0 as T
            Float::class.java -> 0f as T
            Long::class.java -> 0L as T
            Boolean::class.java -> false as T
            else -> null
        }
    }
    fun <T : Any> convertToType(arg: Any, clazz: Class<T>): T? {
        return try {
            when (clazz) {
                String::class.java -> invokeMethodSafe(arg, "toString") as T
                Int::class.java -> invokeMethodSafe(arg, "toInt") as T
                Double::class.java -> invokeMethodSafe(arg, "toDouble") as T
                Float::class.java -> invokeMethodSafe(arg, "toFloat") as T
                Long::class.java -> invokeMethodSafe(arg, "toLong") as T
                Boolean::class.java -> invokeMethodSafe(arg, "toBoolean") as T
                else -> null
            }
        } catch (_: Exception) {
            null
        }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\utils\Hooker.kt --- 
package com.grindrplus.utils
enum class HookStage {
    BEFORE,
    AFTER
}
object Hooker {
    inline fun <T> newMethodHook(
        stage: HookStage,
        crossinline consumer: (HookAdapter<T>) -> Unit,
        crossinline filter: ((HookAdapter<T>) -> Boolean) = { true }
    ): XC_MethodHook {
        return when (stage) {
            HookStage.BEFORE -> object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam<*>) {
                    HookAdapter<T>(param).takeIf(filter)?.also(consumer)
                }
            }
            HookStage.AFTER -> object : XC_MethodHook() {
                override fun afterHookedMethod(param: MethodHookParam<*>) {
                    HookAdapter<T>(param).takeIf(filter)?.also(consumer)
                }
            }
        }
    }
    inline fun <T> hook(
        clazz: Class<T>,
        methodName: String,
        stage: HookStage,
        crossinline filter: (HookAdapter<T>) -> Boolean,
        noinline consumer: (HookAdapter<T>) -> Unit
    ): Set<XC_MethodHook.Unhook> = XposedBridge.hookAllMethods(clazz, methodName, newMethodHook(stage, consumer, filter))
    inline fun <T> hook(
        member: Member,
        stage: HookStage,
        crossinline filter: ((HookAdapter<T>) -> Boolean),
        crossinline consumer: (HookAdapter<T>) -> Unit
    ): XC_MethodHook.Unhook {
        return XposedBridge.hookMethod(member, newMethodHook(stage, consumer, filter))
    }
    fun <T> hook(
        clazz: Class<T>,
        methodName: String,
        stage: HookStage,
        consumer: (HookAdapter<T>) -> Unit
    ): Set<XC_MethodHook.Unhook> = hook(clazz, methodName, stage, { true }, consumer)
    fun <T> hook(
        member: Member,
        stage: HookStage,
        consumer: (HookAdapter<T>) -> Unit
    ): XC_MethodHook.Unhook {
        return hook(member, stage, { true }, consumer)
    }
    fun <T> hookConstructor(
        clazz: Class<T>,
        stage: HookStage,
        consumer: (HookAdapter<T>) -> Unit
    ): Set<XC_MethodHook.Unhook> = XposedBridge.hookAllConstructors(clazz, newMethodHook(stage, consumer))
    fun <T> hookConstructor(
        clazz: Class<T>,
        stage: HookStage,
        filter: ((HookAdapter<T>) -> Boolean),
        consumer: (HookAdapter<T>) -> Unit
    ) {
        XposedBridge.hookAllConstructors(clazz, newMethodHook(stage, consumer, filter))
    }
    inline fun <T> hookObjectMethod(
        clazz: Class<T>,
        instance: Any,
        methodName: String,
        stage: HookStage,
        crossinline hookConsumer: (HookAdapter<T>) -> Unit
    ): List<() -> Unit> {
        val unhooks = mutableSetOf<XC_MethodHook.Unhook>()
        hook(clazz, methodName, stage) { param->
            if (param.nullableThisObject().let {
                    if (it == null) unhooks.forEach { u -> u.unhook() }
                    it != instance
                }) return@hook
            hookConsumer(param)
        }.also { unhooks.addAll(it) }
        return unhooks.map {
            { it.unhook() }
        }
    }
    inline fun <T> ephemeralHook(
        clazz: Class<T>,
        methodName: String,
        stage: HookStage,
        crossinline hookConsumer: (HookAdapter<T>) -> Unit
    ) {
        val unhooks: MutableSet<XC_MethodHook.Unhook> = HashSet()
        hook(clazz, methodName, stage) { param->
            hookConsumer(param)
            unhooks.forEach{ it.unhook() }
        }.also { unhooks.addAll(it) }
    }
    inline fun <T> ephemeralHookObjectMethod(
        clazz: Class<T>,
        instance: Any,
        methodName: String,
        stage: HookStage,
        crossinline hookConsumer: (HookAdapter<T>) -> Unit
    ) {
        val unhooks: MutableSet<XC_MethodHook.Unhook> = HashSet()
        hook(clazz, methodName, stage) { param->
            if (param.nullableThisObject() != instance) return@hook
            unhooks.forEach { it.unhook() }
            hookConsumer(param)
        }.also { unhooks.addAll(it) }
    }
    inline fun <T> ephemeralHookConstructor(
        clazz: Class<T>,
        stage: HookStage,
        crossinline hookConsumer: (HookAdapter<T>) -> Unit
    ) {
        val unhooks: MutableSet<XC_MethodHook.Unhook> = HashSet()
        hookConstructor(clazz, stage) { param->
            hookConsumer(param)
            unhooks.forEach{ it.unhook() }
        }.also { unhooks.addAll(it) }
    }
}
fun <T> Class<T>.hookConstructor(
    stage: HookStage,
    consumer: (HookAdapter<T>) -> Unit
) = Hooker.hookConstructor(this, stage, consumer)
fun <T> Class<T>.hookConstructor(
    stage: HookStage,
    filter: ((HookAdapter<T>) -> Boolean),
    consumer: (HookAdapter<T>) -> Unit
) = Hooker.hookConstructor(this, stage, filter, consumer)
fun <T> Class<T>.hook(
    methodName: String,
    stage: HookStage,
    consumer: (HookAdapter<T>) -> Unit
): Set<XC_MethodHook.Unhook> = Hooker.hook(this, methodName, stage, consumer)
fun <T> Class<T>.hook(
    methodName: String,
    stage: HookStage,
    filter: (HookAdapter<T>) -> Boolean,
    consumer: (HookAdapter<T>) -> Unit
): Set<XC_MethodHook.Unhook> = Hooker.hook(this, methodName, stage, filter, consumer)
fun Member.hook(
    stage: HookStage,
    consumer: (HookAdapter<Any>) -> Unit
): XC_MethodHook.Unhook = Hooker.hook(this, stage, consumer)
fun Member.hook(
    stage: HookStage,
    filter: ((HookAdapter<Any>) -> Boolean),
    consumer: (HookAdapter<Any>) -> Unit
): XC_MethodHook.Unhook = Hooker.hook(this, stage, filter, consumer)
fun Array<Method>.hookAll(stage: HookStage, param: (HookAdapter<Any>) -> Unit) {
    filter { it.declaringClass != Object::class.java }.forEach {
        it.hook(stage, param)
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\utils\HookManager.kt --- 
package com.grindrplus.utils
class HookManager {
    private var hooks = mutableMapOf<KClass<out Hook>, Hook>()
    fun registerHooks(init: Boolean = true) {
        runBlocking(Dispatchers.IO) {
            val hookList = listOf(
                WebSocketAlive(),
                TimberLogging(),
                BanManagement(),
                FeatureGranting(),
                EnableUnlimited(),
                AntiDetection(),
                StatusDialog(),
                AntiBlock(),
                NotificationAlerts(),
                DisableUpdates(),
                DisableBoosting(),
                DisableShuffle(),
                AllowScreenshots(),
                ChatIndicators(),
                ChatTerminal(),
                DisableAnalytics(),
                ExpiringMedia(),
                Favorites(),
                LocalSavedPhrases(),
                LocationSpoofer(),
                OnlineIndicator(),
                UnlimitedProfiles(),
                ProfileDetails(),
                ProfileViews(),
                QuickBlock(),
                EmptyCalls(),
                UnlimitedAlbums()
                        //PreventChatDeletion(),
                //ChatBackupHook()
            )
            hookList.forEach { hook ->
                Config.initHookSettings(
                    hook.hookName, hook.hookDesc, true
                )
            }
            if (!init) return@runBlocking
            hooks = hookList.associateBy { it::class }.toMutableMap()
            hooks.values.forEach { hook ->
                if (Config.isHookEnabled(hook.hookName)) {
                    hook.init()
                    Logger.s("Initialized hook: ${hook.hookName}")
                } else {
                    Logger.i("Hook ${hook.hookName} is disabled.")
                }
            }
        }
    }
    fun reloadHooks() {
        runBlocking(Dispatchers.IO) {
            hooks.values.forEach { hook -> hook.cleanup() }
            hooks.clear()
            registerHooks()
            Logger.s("Reloaded hooks")
        }
    }
    fun init() {
        registerHooks()
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\utils\MediaUtils.kt --- 
package com.grindrplus.utils
object MediaUtils {
    private val httpClient by lazy {
        OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .build()
    }
    private val mediaDir: File by lazy {
        File(GrindrPlus.context.filesDir, "saved_media").apply {
            if (!exists()) mkdirs()
        }
    }
    private val imageDir: File by lazy {
        File(mediaDir, "images").apply {
            if (!exists()) mkdirs()
        }
    }
    private val videoDir: File by lazy {
        File(mediaDir, "videos").apply {
            if (!exists()) mkdirs()
        }
    }
    /**
     * Determines media type from URL or content type
     * @param url The media URL
     * @param contentType Optional content type header
     * @return MediaType.IMAGE, MediaType.VIDEO, or MediaType.UNKNOWN
     */
    fun getMediaType(url: String, contentType: String? = null): MediaType {
        if (!contentType.isNullOrBlank()) {
            if (contentType.startsWith("image/")) return MediaType.IMAGE
            if (contentType.startsWith("video/")) return MediaType.VIDEO
        }
        val extension = MimeTypeMap.getFileExtensionFromUrl(url)?.lowercase() ?: ""
        return when {
            extension in imageExtensions -> MediaType.IMAGE
            extension in videoExtensions -> MediaType.VIDEO
            url.contains("image", ignoreCase = true) -> MediaType.IMAGE
            url.contains("video", ignoreCase = true) -> MediaType.VIDEO
            else -> MediaType.UNKNOWN
        }
    }
    /**
     * Converts a ByteArray to a Base64 encoded string
     */
    fun ByteArray.toBase64(): String = Base64.encodeToString(this, Base64.DEFAULT)
    /**
     * Decodes a Base64 string back to ByteArray
     */
    fun String.fromBase64(): ByteArray = Base64.decode(this, Base64.DEFAULT)
    /**
     * Saves a ByteArray to the specified file
     * @return Result containing true on success or an exception on failure
     */
    fun ByteArray.saveToFile(file: File): Result<Boolean> = runCatching {
        FileOutputStream(file).use { it.write(this) }
        true
    }
    /**
     * Downloads media from a URL as a ByteArray using coroutines
     * @param url The URL of the media to download
     * @return Result containing the downloaded ByteArray or an exception on failure
     */
    suspend fun downloadMedia(url: String): Result<ByteArray> = runCatching {
        suspendCancellableCoroutine { continuation ->
            val request = Request.Builder()
                .url(url)
                .get()
                .build()
            val call = httpClient.newCall(request)
            continuation.invokeOnCancellation {
                call.cancel()
            }
            call.enqueue(object : Callback {
                override fun onFailure(call: Call, e: IOException) {
                    continuation.resumeWithException(e)
                }
                override fun onResponse(call: Call, response: Response) {
                    try {
                        if (!response.isSuccessful) {
                            continuation.resumeWithException(
                                IOException("Unexpected HTTP response: ${response.code}")
                            )
                            return
                        }
                        response.body?.bytes()?.let {
                            continuation.resume(it)
                        } ?: continuation.resumeWithException(
                            IOException("Empty response body")
                        )
                    } catch (e: Exception) {
                        continuation.resumeWithException(e)
                    } finally {
                        response.close()
                    }
                }
            })
        }
    }
    /**
     * Synchronously downloads media from a URL as a ByteArray
     * @param url The URL of the media to download
     * @return Result containing the downloaded ByteArray or an exception on failure
     */
    fun downloadMediaSync(url: String): Result<ByteArray> = runCatching {
        val request = Request.Builder()
            .url(url)
            .get()
            .build()
        httpClient.newCall(request).execute().use { response ->
            if (!response.isSuccessful) {
                throw IOException("Unexpected HTTP response: ${response.code}")
            }
            response.body?.bytes() ?: throw IOException("Empty response body")
        }
    }
    /**
     * Saves media permanently and returns its file URL
     *
     * @param mediaId The ID of the media
     * @param mediaData The media data as ByteArray
     * @param mediaType The type of media (image or video)
     * @param extension Optional file extension (defaults to jpg for images, mp4 for videos)
     * @return Result containing the file URI as a string or an exception on failure
     */
    suspend fun saveMedia(
        mediaId: Long,
        mediaData: ByteArray,
        mediaType: MediaType = MediaType.IMAGE,
        extension: String? = null
    ): Result<String> = withContext(Dispatchers.IO) {
        runCatching {
            val directory = when (mediaType) {
                MediaType.IMAGE -> imageDir
                MediaType.VIDEO -> videoDir
                MediaType.UNKNOWN -> mediaDir
            }
            val fileExtension = extension ?: when (mediaType) {
                MediaType.IMAGE -> "jpg"
                MediaType.VIDEO -> "mp4"
                MediaType.UNKNOWN -> "bin"
            }
            val mediaFile = File(directory, "$mediaId.$fileExtension")
            if (!mediaFile.exists()) {
                mediaData.saveToFile(mediaFile).getOrThrow()
                Logger.d("Saved ${mediaType.name.lowercase()} for mediaId $mediaId to ${mediaFile.absolutePath}")
            }
            "file://${mediaFile.absolutePath}"
        }.onFailure {
            Logger.e("Error saving ${mediaType.name.lowercase()} file: ${it.message}")
        }
    }
    /**
     * Gets the file URL for a saved media
     *
     * @param mediaId The ID of the media
     * @param mediaType The type of media (image or video)
     * @param extension Optional file extension to check (if null, defaults to jpg for images, mp4 for videos)
     * @return The file URI as a string, or null if the file doesn't exist
     */
    fun getMediaFileUrl(
        mediaId: Long,
        mediaType: MediaType = MediaType.IMAGE,
        extension: String? = null
    ): String? {
        val directory = when (mediaType) {
            MediaType.IMAGE -> imageDir
            MediaType.VIDEO -> videoDir
            MediaType.UNKNOWN -> mediaDir
        }
        if (extension != null) {
            val specificFile = File(directory, "$mediaId.$extension")
            if (specificFile.exists()) {
                return "file://${specificFile.absolutePath}"
            }
            return null
        }
        val defaultExt = when (mediaType) {
            MediaType.IMAGE -> "jpg"
            MediaType.VIDEO -> "mp4"
            MediaType.UNKNOWN -> null
        }
        if (defaultExt != null) {
            val defaultFile = File(directory, "$mediaId.$defaultExt")
            if (defaultFile.exists()) {
                return "file://${defaultFile.absolutePath}"
            }
        }
        if (mediaType == MediaType.UNKNOWN) {
            val extensions = imageExtensions + videoExtensions
            for (ext in extensions) {
                val file = File(directory, "$mediaId.$ext")
                if (file.exists()) {
                    return "file://${file.absolutePath}"
                }
            }
        }
        return null
    }
    /**
     * Checks if media exists for the given ID
     *
     * @param mediaId The ID of the media
     * @param mediaType The type of media to check for
     * @param extension Optional file extension to check (if null, checks default extensions)
     * @return True if the file exists, false otherwise
     */
    fun mediaExists(
        mediaId: Long,
        mediaType: MediaType = MediaType.UNKNOWN,
        extension: String? = null
    ): Boolean {
        val directories = when (mediaType) {
            MediaType.IMAGE -> listOf(imageDir)
            MediaType.VIDEO -> listOf(videoDir)
            MediaType.UNKNOWN -> listOf(imageDir, videoDir, mediaDir)
        }
        if (extension != null) {
            for (dir in directories) {
                if (File(dir, "$mediaId.$extension").exists()) {
                    return true
                }
            }
            return false
        }
        when (mediaType) {
            MediaType.IMAGE -> {
                if (File(imageDir, "$mediaId.jpg").exists()) {
                    return true
                }
            }
            MediaType.VIDEO -> {
                if (File(videoDir, "$mediaId.mp4").exists()) {
                    return true
                }
            }
            MediaType.UNKNOWN -> {
                if (File(imageDir, "$mediaId.jpg").exists() ||
                    File(videoDir, "$mediaId.mp4").exists()) {
                    return true
                }
            }
        }
        if (mediaType == MediaType.UNKNOWN) {
            val extensions = imageExtensions + videoExtensions
            for (dir in directories) {
                for (ext in extensions) {
                    if (File(dir, "$mediaId.$ext").exists()) {
                        return true
                    }
                }
            }
        }
        return false
    }
    /**
     * Gets the list of all saved media IDs of a specific type
     *
     * @param mediaType The type of media to list
     * @return List of media IDs that have been saved
     */
    fun getAllSavedMediaIds(mediaType: MediaType = MediaType.UNKNOWN): List<Long> {
        val directories = when (mediaType) {
            MediaType.IMAGE -> listOf(imageDir)
            MediaType.VIDEO -> listOf(videoDir)
            MediaType.UNKNOWN -> listOf(imageDir, videoDir, mediaDir)
        }
        return directories.flatMap { dir ->
            dir.listFiles()
                ?.filter { it.isFile }
                ?.mapNotNull { file ->
                    file.nameWithoutExtension.toLongOrNull()
                } ?: emptyList()
        }.distinct()
    }
    enum class MediaType {
        IMAGE, VIDEO, UNKNOWN
    }
    // I'm pretty sure Grindr defaults to both JPG and MP4 but let's keep this
    // flexible in case they change it in the future.
    private val imageExtensions = listOf("jpg", "jpeg", "png", "gif", "webp")
    private val videoExtensions = listOf("mp4", "mkv", "mov", "avi", "webm")
}
/**
 * Utility object specifically for expiring photos, which uses the more generic MediaUtils
 * underneath. This allows legacy code to keep working without changes.
 */
object ExpiringPhotoUtils {
    /**
     * Downloads an image from a URL using coroutines
     * @param url The URL of the image to download
     * @return Result containing the downloaded ByteArray or an exception on failure
     */
    suspend fun downloadImage(url: String): Result<ByteArray> =
        MediaUtils.downloadMedia(url)
    /**
     * Saves an image and returns its file URL
     *
     * @param mediaId The ID of the media
     * @param imageData The image data as ByteArray
     * @param extension Optional file extension (defaults to jpg)
     * @return Result containing the file URI as a string or an exception on failure
     */
    suspend fun saveImage(mediaId: Long, imageData: ByteArray, extension: String? = null): Result<String> =
        MediaUtils.saveMedia(mediaId, imageData, MediaUtils.MediaType.IMAGE, extension)
    /**
     * Gets the file URL for a saved image
     *
     * @param mediaId The ID of the media
     * @param extension Optional file extension (defaults to jpg)
     * @return The file URI as a string, or null if the file doesn't exist
     */
    fun getImageFileUrl(mediaId: Long, extension: String? = null): String? =
        MediaUtils.getMediaFileUrl(mediaId, MediaUtils.MediaType.IMAGE, extension)
    /**
     * Checks if an image file exists for the given media ID
     *
     * @param mediaId The ID of the media
     * @param extension Optional file extension (defaults to jpg)
     * @return True if the file exists, false otherwise
     */
    fun imageFileExists(mediaId: Long, extension: String? = null): Boolean =
        MediaUtils.mediaExists(mediaId, MediaUtils.MediaType.IMAGE, extension)
    /**
     * Gets the list of all saved image IDs
     *
     * @return List of media IDs that have been saved
     */
    fun getAllSavedImageIds(): List<Long> =
        MediaUtils.getAllSavedMediaIds(MediaUtils.MediaType.IMAGE)
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\utils\PCHIP.kt --- 
package com.grindrplus.utils
/**
 * Fritsch–Carlson PCHIP (Piecewise Cubic Hermite Interpolation)
 * for monotonically increasing functions. By https://github.com/Supersonic
 */
class PCHIP(points: List<Pair<Long, Int>>) {
    private val n = points.size
    private val x = DoubleArray(n)
    private val y = DoubleArray(n)
    private val m = DoubleArray(n)
    init {
        require(n >= 2) { "Need at least two data points." }
        // Sanity check to ensure monotonicity
        for (i in points.indices) {
            x[i] = points[i].first.toDouble()
            y[i] = points[i].second.toDouble()
            if (i > 0) {
                require(x[i] > x[i - 1]) { "x must be strictly ascending" }
                require(y[i] >= y[i - 1]) { "y must be non-decreasing" }
            }
        }
        computeSlopes()
    }
    /**
     * 1) Compute the "interval slopes" delta_i = (y_{i+1} - y_i)/(x_{i+1} - x_i), i=0..n-2
     * 2) Set end slopes m_0 = delta_0, m_{n-1} = delta_{n-2}
     * 3) For each interior i=1..n-2:
     *     - if delta_{i-1} * delta_i <= 0 => m_i = 0
     *     - else => smooth them to ensure monotonicity
     */
    private fun computeSlopes() {
        val h = DoubleArray(n - 1)
        val delta = DoubleArray(n - 1)
        for (i in 0 until n - 1) {
            h[i] = x[i + 1] - x[i]
            require(h[i] > 0) {"Duplicate x-value"}
            delta[i] = (y[i + 1] - y[i]) / h[i]
        }
        m[0] = delta[0]
        m[n - 1] = delta[n - 2]
        for (i in 1 until n - 1) {
            if (delta[i - 1] * delta[i] <= 0.0) {
                m[i] = 0.0
            } else {
                // weighted harmonic mean
                val w1 = 2.0 * h[i] + h[i - 1]
                val w2 = h[i] + 2.0 * h[i - 1]
                m[i] = (w1 + w2) / (w1 / delta[i - 1] + w2 / delta[i])
            }
        }
    }
    /**
     * Derive the interpolant at time X (in seconds).
     * If X is outside [x[0], x[n-1]] we extrapolate using the last interval or the first.
     */
    fun interpolate(X: Double): Double {
        val i = findInterval(X)
        // transform X -> local t over [0..1]
        val h = x[i + 1] - x[i]
        val t = (X - x[i]) / h
        // hermite basis
        val t2 = t * t
        val t3 = t2 * t
        val h00 = 2.0 * t3 - 3.0 * t2 + 1.0
        val h10 = t3 - 2.0 * t2 + t
        val h01 = -2.0 * t3 + 3.0 * t2
        val h11 = t3 - t2
        return h00 * y[i] +
                h10 * h * m[i] +
                h01 * y[i + 1] +
                h11 * h * m[i + 1]
    }
    /**
     * Given a target Y (ID), find X via bisection search within the relevant interval,
     */
    fun invert(targetY: Double): Double {
        // ensure we have at least two points
        require(n >= 2) { "Need at least two data points for interpolation" }
        // clamp if targetY is outside [y[0], y[n-1]]
        if (targetY <= y[0]) return x[0]
        // use a linear extension for targetY larger than y[n-1]. Clamp to no later than now
        if (targetY >= y[n - 1]) {
            // prevent division by zero or index out of bounds by checking we have at least 2 points
            val extendedX = if (n > 1) {
                val yDiff = y[n-1] - y[n-2]
                val xDiff = x[n-1] - x[n-2]
                if (abs(yDiff) > 1e-10) {
                    val slopeXbyY = xDiff / yDiff
                    val deltaY = targetY - y[n-1]
                    x[n-1] + deltaY * slopeXbyY
                } else {
                    // if Y values are essentially the same, use the last known X value
                    x[n-1]
                }
            } else {
                // fallback to the only point if there's just one point
                x[0]
            }
            // use current system time as the upper bound
            val nowX = System.currentTimeMillis() / 1000.0
            return minOf(extendedX, nowX)
        }
        val i = findIntervalByY(targetY)
        var left = x[i]
        var right = x[i + 1]
        // 30 iterations is enough for the precision we need
        repeat(30) {
            val mid = 0.5 * (left + right)
            val fMid = interpolate(mid)
            if (fMid < targetY) {
                left = mid
            } else {
                right = mid
            }
        }
        return 0.5 * (left + right)
    }
    private fun findInterval(X: Double): Int {
        if (X <= x[0]) return 0
        if (X >= x[n - 1]) return n - 2
        for (i in 0 until n - 1) {
            if (X < x[i + 1]) {
                return i
            }
        }
        return n - 2
    }
    private fun findIntervalByY(targetY: Double): Int {
        for (i in 0 until n - 1) {
            if (targetY <= y[i + 1]) {
                return i
            }
        }
        // fallback
        return n - 2
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\utils\RetrofitUtils.kt --- 
package com.grindrplus.utils
object RetrofitUtils {
    const val FAIL_CLASS_NAME = "xb.a\$a"
    const val SUCCESS_CLASS_NAME = "xb.a\$b"
    const val SUCCESS_VALUE_NAME = "a"
    const val RETROFIT_NAME = "retrofit2.Retrofit"
    fun findPOSTMethod(clazz: Class<*>, value: String): Method? {
        return clazz.declaredMethods.find { method ->
            method.annotations.any {
                it.annotationClass.java.name == "retrofit2.http.POST"
                        && callMethod(it, "value") == value
            }
        }
    }
    fun Method.isPOST(value: String): Boolean {
        return this.annotations.any {
            it.annotationClass.java.name == "retrofit2.http.POST"
                    && callMethod(it, "value") == value
        }
    }
    fun Method.isDELETE(value: String): Boolean {
        return this.annotations.any {
            it.annotationClass.java.name == "retrofit2.http.DELETE"
                    && callMethod(it, "value") == value
        }
    }
    fun Method.isGET(value: String): Boolean {
        return this.annotations.any {
            it.annotationClass.java.name == "retrofit2.http.GET"
                    && callMethod(it, "value") == value
        }
    }
    fun Method.isPUT(value: String): Boolean {
        return this.annotations.any {
            it.annotationClass.java.name == "retrofit2.http.PUT"
                    && callMethod(it, "value") == value
        }
    }
    fun Any.isFail(): Boolean {
        return javaClass.name == FAIL_CLASS_NAME
    }
    fun Any.isSuccess(): Boolean {
        return javaClass.name == SUCCESS_CLASS_NAME
    }
    fun Any.getSuccessValue(): Any {
        return getObjectField(this, SUCCESS_VALUE_NAME)
    }
    fun Any.getFailValue(): Any {
        return getObjectField(this, SUCCESS_VALUE_NAME)
    }
    fun createSuccess(value: Any): Any {
        val successClass = GrindrPlus.loadClass(SUCCESS_CLASS_NAME)
        return successClass.constructors.first().newInstance(value)
    }
    fun createServiceProxy(
        originalService: Any,
        serviceClass: Class<*>,
        blacklist: Array<String> = emptyArray()
    ): Any {
        val invocationHandler = Proxy.getInvocationHandler(originalService)
        val successConstructor =
            GrindrPlus.loadClass(SUCCESS_CLASS_NAME).constructors.firstOrNull()
        return Proxy.newProxyInstance(
            originalService.javaClass.classLoader,
            arrayOf(serviceClass)
        ) { proxy, method, args ->
            if (successConstructor != null && (blacklist.isEmpty() || method.name in blacklist)) {
                successConstructor.newInstance(Unit)
            } else {
                invocationHandler.invoke(proxy, method, args)
            }
        }
    }
    fun hookService(
        serviceClass: Class<*>,
        invoke: (originalHandler: InvocationHandler, proxy: Any, method: Method, args: Array<Any?>) -> Any?
    ) {
        GrindrPlus.loadClass(RETROFIT_NAME)
            .hook("create", HookStage.AFTER) { param ->
                val serviceInstance = param.getResult()
                if (serviceInstance != null && serviceClass.isAssignableFrom(serviceInstance.javaClass)) {
                    val invocationHandler = Proxy.getInvocationHandler(serviceInstance)
                    param.setResult(Proxy.newProxyInstance(
                        serviceInstance.javaClass.classLoader,
                        arrayOf(serviceClass)
                    ) { proxy, method, args ->
                        invoke(invocationHandler, proxy, method, args)
                    })
                }
            }
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\utils\SuspendResultUtils.kt --- 
package com.grindrplus.utils
fun withSuspendResult(args: Array<Any?>, result: Any, onResult: (Array<Any?>, Any) -> Any): Any {
    return if (result.toString() == "COROUTINE_SUSPENDED") {
        var unhook: Set<XC_MethodHook.Unhook>? = null
        unhook = args.last()!!.javaClass.hook("invokeSuspend", HookStage.BEFORE) {
            unhook?.forEach(XC_MethodHook.Unhook::unhook)
            unhook = null
            it.setArg(0, onResult(args, it.arg(0)))
        }
        result
    } else {
        onResult(args, result)
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\utils\Task.kt --- 
package com.grindrplus.utils
abstract class Task(
    val id: String,
    val description: String,
    val initialDelayMillis: Long = 30 * 1000, // 30 seconds
    val intervalMillis: Long = 10 * 60 * 1000 // 10 minutes
) {
    private var job: Job? = null
    /**
     * Check if the task is enabled in config
     */
    fun isTaskEnabled(): Boolean {
        return Config.isTaskEnabled(id)
    }
    /**
     * Override this method to implement task-specific logic
     */
    abstract suspend fun execute()
    /**
     * Start the task if it's enabled in config
     */
    fun start() {
        if (!isTaskEnabled()) {
            Logger.i("Task $id is disabled", LogSource.MODULE)
            return
        }
        job = GrindrPlus.taskManager.startPeriodicTask(
            taskId = id,
            initialDelayMillis = initialDelayMillis,
            intervalMillis = intervalMillis,
            action = {
                try {
                    execute()
                    Logger.i("Task $id executed successfully", LogSource.MODULE)
                } catch (e: Exception) {
                    Logger.e("Task $id failed: ${e.message}", LogSource.MODULE)
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
        )
        Logger.i("Task $id started", LogSource.MODULE)
    }
    /**
     * Stop the task
     */
    fun stop() {
        job?.let {
            if (GrindrPlus.taskManager.isTaskRunning(id)) {
                GrindrPlus.taskManager.cancelTask(id)
                Logger.i("Task $id stopped", LogSource.MODULE)
            }
        }
        job = null
    }
    /**
     * Called when task is first registered
     */
    open fun register() {
        Config.initTaskSettings(
            id,
            description,
            false // disabled by default
        )
    }
} 
--- File: D:\ANDROID\GPlus4.6\app\src\main\java\com\grindrplus\utils\TaskManager.kt --- 
package com.grindrplus.utils
class TaskManager(private val scheduler: TaskScheduler? = null) {
    private val tasks = mutableMapOf<KClass<out Task>, Task>()
    fun registerTasks(startTasks: Boolean = true) {
        runBlocking(Dispatchers.IO) {
            val taskList = listOf(
                AlwaysOnline(),
            )
            taskList.forEach { task ->
                task.register()
            }
            tasks.clear()
            taskList.forEach { task ->
                tasks[task::class] = task
                if (startTasks && task.isTaskEnabled()) {
                    task.start()
                    Logger.i("Started task: ${task.id}", LogSource.MODULE)
                } else if (!startTasks) {
                    Logger.i("Registered task: ${task.id}", LogSource.MODULE)
                } else {
                    Logger.i("Task ${task.id} is disabled", LogSource.MODULE)
                }
            }
        }
    }
    fun reloadTasks() {
        runBlocking(Dispatchers.IO) {
            tasks.values.forEach { task -> task.stop() }
            tasks.clear()
            registerTasks()
            Logger.s("Reloaded tasks", LogSource.MODULE)
        }
    }
    @Suppress("UNCHECKED_CAST")
    fun <T : Task> getTask(taskClass: KClass<T>): T? {
        return tasks[taskClass] as? T
    }
    fun toggleTask(taskId: String, enabled: Boolean) {
        val task = tasks.values.find { it.id == taskId } ?: return
        Config.setTaskEnabled(taskId, enabled)
        if (enabled) {
            task.start()
        } else {
            task.stop()
        }
    }
    fun stopAllTasks() {
        tasks.values.forEach { it.stop() }
    }
    fun startPeriodicTask(
        taskId: String,
        initialDelayMillis: Long,
        intervalMillis: Long,
        action: suspend () -> Unit
    ): Job {
        val scheduler = scheduler ?: error("TaskScheduler is not initialized")
        if (scheduler.isTaskRunning(taskId)) {
            scheduler.cancelTask(taskId)
        }
        return scheduler.periodic(
            name = taskId,
            intervalMs = intervalMillis
        ) {
            if (initialDelayMillis > 0) {
                delay(initialDelayMillis)
            }
            action()
        }
    }
    fun startOnceTask(taskId: String, action: suspend () -> Unit): Job {
        val scheduler = scheduler ?: error("TaskScheduler is not initialized")
        return scheduler.once(taskId, action)
    }
    fun startTaskWithRetry(
        taskId: String,
        retries: Int = 3,
        delayMs: Long = 1000,
        action: suspend () -> Unit
    ): Job {
        val scheduler = scheduler ?: error("TaskScheduler is not initialized")
        return scheduler.withRetry(taskId, retries, delayMs, action)
    }
    fun isTaskRunning(taskId: String): Boolean {
        return scheduler?.isTaskRunning(taskId) ?: false
    }
    fun cancelTask(taskId: String) {
        scheduler?.cancelTask(taskId)
    }
} 